"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/components/VimEditor.tsx":
/*!**************************************!*\
  !*** ./src/components/VimEditor.tsx ***!
  \**************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var _chakra_ui_react__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @chakra-ui/react */ \"(app-pages-browser)/./node_modules/@chakra-ui/react/dist/esm/components/box/box.js\");\n/* harmony import */ var _chakra_ui_react__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @chakra-ui/react */ \"(app-pages-browser)/./node_modules/@chakra-ui/react/dist/esm/components/flex/flex.js\");\n/* harmony import */ var _chakra_ui_react__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @chakra-ui/react */ \"(app-pages-browser)/./node_modules/@chakra-ui/react/dist/esm/components/typography/text.js\");\n/* harmony import */ var _chakra_ui_react__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! @chakra-ui/react */ \"(app-pages-browser)/./node_modules/@chakra-ui/react/dist/esm/components/stack/h-stack.js\");\n/* harmony import */ var _chakra_ui_react__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! @chakra-ui/react */ \"(app-pages-browser)/./node_modules/@chakra-ui/react/dist/esm/components/icon/icon.js\");\n/* harmony import */ var _chakra_ui_react__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! @chakra-ui/react */ \"(app-pages-browser)/./node_modules/@chakra-ui/react/dist/esm/components/button/button.js\");\n/* harmony import */ var _uiw_react_codemirror__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @uiw/react-codemirror */ \"(app-pages-browser)/./node_modules/@uiw/react-codemirror/esm/index.js\");\n/* harmony import */ var _codemirror_lang_html__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @codemirror/lang-html */ \"(app-pages-browser)/./node_modules/@codemirror/lang-html/dist/index.js\");\n/* harmony import */ var _codemirror_lang_css__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @codemirror/lang-css */ \"(app-pages-browser)/./node_modules/@codemirror/lang-css/dist/index.js\");\n/* harmony import */ var _codemirror_lang_javascript__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! @codemirror/lang-javascript */ \"(app-pages-browser)/./node_modules/@codemirror/lang-javascript/dist/index.js\");\n/* harmony import */ var _codemirror_theme_one_dark__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @codemirror/theme-one-dark */ \"(app-pages-browser)/./node_modules/@codemirror/theme-one-dark/dist/index.js\");\n/* harmony import */ var _replit_codemirror_vim__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @replit/codemirror-vim */ \"(app-pages-browser)/./node_modules/@replit/codemirror-vim/dist/index.js\");\n/* harmony import */ var framer_motion__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! framer-motion */ \"(app-pages-browser)/./node_modules/framer-motion/dist/es/render/components/motion/proxy.mjs\");\n/* harmony import */ var framer_motion__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! framer-motion */ \"(app-pages-browser)/./node_modules/framer-motion/dist/es/components/AnimatePresence/index.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _barrel_optimize_names_FiCommand_FiEdit_FiRefreshCw_FiTerminal_react_icons_fi__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! __barrel_optimize__?names=FiCommand,FiEdit,FiRefreshCw,FiTerminal!=!react-icons/fi */ \"(app-pages-browser)/./node_modules/react-icons/fi/index.mjs\");\n// --- サンプルコード・VimTips定数 ---\n\nvar _s = $RefreshSig$();\nconst htmlSample = '<div class=\"container\">\\n  <h1>Hello Vim!</h1>\\n  <p>これはVim練習用のサンプルです。</p>\\n</div>\\n';\nconst cssSample = \".container {\\n  max-width: 600px;\\n  margin: 0 auto;\\n  padding: 2rem;\\n  background: #f5f5f5;\\n}\\n\";\nconst jsSample = \"document.querySelector('.container').addEventListener('click', function() {\\n  alert('Vimで編集してみよう！');\\n});\\n\";\nconst vimTips = \"// --- おまけ: よく使うVimコマンド ---\\n// h / j / k / l : 左右上下にカーソル移動\\n// w / b / e : 単語単位で移動\\n// 0 / $ / ^ : 行頭・行末・最初の非空白文字へ\\n// gg / G : ファイル先頭・末尾へ移動\\n// i / a / o / O : 挿入モード\\n// x : 文字削除\\n// dd : 行削除\\n// yy : 行コピー\\n// p / P : 貼り付け\\n// u / Ctrl+r : アンドゥ・リドゥ\\n// cw / cc / c$ : 単語・行・行末まで変更\\n// . : 直前の操作を繰り返し\\n// /pattern : 検索\\n// n / N : 次・前の検索結果へ\\n// :%s/old/new/g : 置換\\n// v / V : 選択開始\\n// y / d : コピー・削除\\n\";\n// --- Vimモード情報・型定義 ---\n\n\n\n\n\n\n\n\n\n\nconst MotionBox = (0,framer_motion__WEBPACK_IMPORTED_MODULE_3__.motion)(_chakra_ui_react__WEBPACK_IMPORTED_MODULE_4__.Box);\n_c = MotionBox;\nconst MotionFlex = (0,framer_motion__WEBPACK_IMPORTED_MODULE_3__.motion)(_chakra_ui_react__WEBPACK_IMPORTED_MODULE_5__.Flex);\n_c1 = MotionFlex;\nconst MotionText = (0,framer_motion__WEBPACK_IMPORTED_MODULE_3__.motion)(_chakra_ui_react__WEBPACK_IMPORTED_MODULE_6__.Text);\n_c2 = MotionText;\nconst modeInfo = {\n    normal: {\n        text: \"NORMAL\",\n        color: \"orange.400\",\n        icon: _barrel_optimize_names_FiCommand_FiEdit_FiRefreshCw_FiTerminal_react_icons_fi__WEBPACK_IMPORTED_MODULE_7__.FiCommand,\n        hint: \"Press i to enter insert mode\"\n    },\n    insert: {\n        text: \"INSERT\",\n        color: \"green.400\",\n        icon: _barrel_optimize_names_FiCommand_FiEdit_FiRefreshCw_FiTerminal_react_icons_fi__WEBPACK_IMPORTED_MODULE_7__.FiEdit,\n        hint: \"Press Esc to return to normal mode\"\n    },\n    visual: {\n        text: \"VISUAL\",\n        color: \"purple.400\",\n        icon: _barrel_optimize_names_FiCommand_FiEdit_FiRefreshCw_FiTerminal_react_icons_fi__WEBPACK_IMPORTED_MODULE_7__.FiCommand,\n        hint: \"Select text with h,j,k,l or use y to copy\"\n    }\n};\nfunction VimEditor() {\n    _s();\n    const [mode, setMode] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(\"html\");\n    const [vimMode, setVimMode] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(\"normal\");\n    // SSR/CSR差異によるeditor描画遅延対策: isMounted判定を廃止\n    // editorRef, viewRefは不要\n    // isMounted判定を廃止\n    // アニメーション用のvariants\n    const containerVariants = {\n        hidden: {\n            opacity: 0,\n            scale: 0.98\n        },\n        visible: {\n            opacity: 1,\n            scale: 1,\n            transition: {\n                duration: 0.4\n            }\n        }\n    };\n    const modeIndicatorVariants = {\n        hidden: {\n            opacity: 0,\n            x: -15,\n            scale: 0.9\n        },\n        visible: {\n            opacity: 1,\n            x: 0,\n            scale: 1,\n            transition: {\n                duration: 0.3\n            }\n        },\n        exit: {\n            opacity: 0,\n            x: 15,\n            scale: 0.9,\n            transition: {\n                duration: 0.2\n            }\n        }\n    };\n    // 言語拡張取得（@uiw/react-codemirror用）\n    function getExtensions() {\n        switch(mode){\n            case \"html\":\n                return [\n                    (0,_codemirror_lang_html__WEBPACK_IMPORTED_MODULE_8__.html)(),\n                    (0,_replit_codemirror_vim__WEBPACK_IMPORTED_MODULE_9__.vim)(),\n                    _codemirror_theme_one_dark__WEBPACK_IMPORTED_MODULE_10__.oneDark\n                ];\n            case \"css\":\n                return [\n                    (0,_codemirror_lang_css__WEBPACK_IMPORTED_MODULE_11__.css)(),\n                    (0,_replit_codemirror_vim__WEBPACK_IMPORTED_MODULE_9__.vim)(),\n                    _codemirror_theme_one_dark__WEBPACK_IMPORTED_MODULE_10__.oneDark\n                ];\n            case \"js\":\n                return [\n                    (0,_codemirror_lang_javascript__WEBPACK_IMPORTED_MODULE_12__.javascript)(),\n                    (0,_replit_codemirror_vim__WEBPACK_IMPORTED_MODULE_9__.vim)(),\n                    _codemirror_theme_one_dark__WEBPACK_IMPORTED_MODULE_10__.oneDark\n                ];\n            default:\n                return [\n                    (0,_replit_codemirror_vim__WEBPACK_IMPORTED_MODULE_9__.vim)(),\n                    _codemirror_theme_one_dark__WEBPACK_IMPORTED_MODULE_10__.oneDark\n                ];\n        }\n    }\n    const [html, setHtml] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(htmlSample);\n    const [css, setCss] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(cssSample);\n    const [js, setJs] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(jsSample);\n    const [code, setCode] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(htmlSample + vimTips);\n    // 初回レンダリング時に必ずhtmlSample+vimTipsで初期化\n    // editor初期化・Vimモード監視はonUpdate/onChangeで十分\n    // Vimモード監視（@uiw/react-codemirrorのonUpdateで判定）\n    // Vimモード判定はonChangeで常にnormalに戻す（insertはVim拡張で自動）\n    const onUpdate = (0,react__WEBPACK_IMPORTED_MODULE_2__.useCallback)((_viewUpdate)=>{}, []);\n    const getSample = (0,react__WEBPACK_IMPORTED_MODULE_2__.useCallback)(()=>{\n        if (mode === \"html\") return htmlSample + vimTips;\n        if (mode === \"css\") return cssSample + vimTips;\n        return jsSample + vimTips;\n    }, [\n        mode\n    ]);\n    // 上記で宣言済みなので重複削除\n    const [showPreview, setShowPreview] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(false);\n    const handleReset = (0,react__WEBPACK_IMPORTED_MODULE_2__.useCallback)(()=>{\n        setHtml(htmlSample);\n        setCss(cssSample);\n        setJs(jsSample);\n        setCode(mode === \"html\" ? htmlSample + vimTips : mode === \"css\" ? cssSample + vimTips : jsSample + vimTips);\n        setVimMode(\"normal\");\n        setShowPreview(false);\n    }, [\n        mode\n    ]);\n    const handleModeChange = (0,react__WEBPACK_IMPORTED_MODULE_2__.useCallback)((m)=>{\n        // 現在の内容を保存\n        if (mode === \"html\") setHtml(code.replace(vimTips, \"\"));\n        if (mode === \"css\") setCss(code.replace(vimTips, \"\"));\n        if (mode === \"js\") setJs(code.replace(vimTips, \"\"));\n        // モード切り替え\n        setMode(m);\n        // 切り替え先の内容を表示\n        if (m === \"html\") setCode(html + vimTips);\n        else if (m === \"css\") setCode(css + vimTips);\n        else setCode(js + vimTips);\n        setShowPreview(false);\n    }, [\n        mode,\n        code,\n        html,\n        css,\n        js\n    ]);\n    // プレビュー用HTML生成（最新のhtml, css, js内容を合成）\n    const previewSrcDoc = '\\n    <!DOCTYPE html>\\n    <html lang=\"ja\">\\n    <head>\\n      <meta charset=\"UTF-8\" />\\n      <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\\n      <title>Preview</title>\\n      <style>\\n      '.concat(css, \"\\n      </style>\\n    </head>\\n    <body>\\n      \").concat(html, \"\\n      <script>\\n      \").concat(js, \"\\n      </script>\\n    </body>\\n    </html>\\n  \");\n    const onChange = (0,react__WEBPACK_IMPORTED_MODULE_2__.useCallback)((value)=>{\n        setCode(value);\n        // 編集内容を保存\n        if (mode === \"html\") setHtml(value.replace(vimTips, \"\"));\n        if (mode === \"css\") setCss(value.replace(vimTips, \"\"));\n        if (mode === \"js\") setJs(value.replace(vimTips, \"\"));\n    }, [\n        mode\n    ]);\n    // SSR/CSR差異による高さ0問題を防ぐ\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(MotionBox, {\n        bgGradient: \"gradient.primary\",\n        color: \"text.primary\",\n        p: {\n            base: 2,\n            md: 4\n        },\n        borderRadius: \"2xl\",\n        boxShadow: \"glass\",\n        display: \"flex\",\n        flexDirection: \"column\",\n        borderWidth: 1,\n        borderColor: \"border.primary\",\n        position: \"relative\",\n        overflow: \"hidden\",\n        flex: 1,\n        minH: {\n            base: \"400px\",\n            md: \"520px\",\n            lg: \"600px\"\n        },\n        maxH: {\n            base: \"520px\",\n            md: \"640px\",\n            lg: \"700px\"\n        },\n        h: {\n            base: \"440px\",\n            md: \"600px\",\n            lg: \"680px\"\n        },\n        initial: \"hidden\",\n        animate: \"visible\",\n        variants: containerVariants,\n        _before: {\n            content: '\"\"',\n            position: \"absolute\",\n            top: 0,\n            left: 0,\n            right: 0,\n            bottom: 0,\n            background: \"gradient.glass\",\n            borderRadius: \"inherit\",\n            pointerEvents: \"none\"\n        },\n        _hover: {\n            boxShadow: \"glass-hover\",\n            transform: \"translateY(-1px)\"\n        },\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(MotionFlex, {\n                alignItems: \"center\",\n                px: [\n                    2,\n                    4\n                ],\n                py: [\n                    2,\n                    3\n                ],\n                borderBottomWidth: 1,\n                borderColor: \"primary.700\",\n                bgGradient: \"linear(to-r, primary.900, primary.800)\",\n                justifyContent: \"space-between\",\n                position: \"relative\",\n                _before: {\n                    content: '\"\"',\n                    position: \"absolute\",\n                    top: 0,\n                    left: 0,\n                    right: 0,\n                    bottom: 0,\n                    background: \"linear-gradient(90deg, rgba(255,152,0,0.08) 0%, transparent 50%, rgba(255,152,0,0.03) 100%)\",\n                    pointerEvents: \"none\"\n                },\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_chakra_ui_react__WEBPACK_IMPORTED_MODULE_5__.Flex, {\n                        alignItems: \"center\",\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_chakra_ui_react__WEBPACK_IMPORTED_MODULE_13__.HStack, {\n                                gap: 2,\n                                marginRight: 5,\n                                children: [\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_chakra_ui_react__WEBPACK_IMPORTED_MODULE_4__.Box, {\n                                        w: 3,\n                                        h: 3,\n                                        borderRadius: \"full\",\n                                        bg: \"red.400\"\n                                    }, void 0, false, {\n                                        fileName: \"C:\\\\Users\\\\hr-hm\\\\Desktop\\\\study\\\\vimapp\\\\src\\\\components\\\\VimEditor.tsx\",\n                                        lineNumber: 276,\n                                        columnNumber: 13\n                                    }, this),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_chakra_ui_react__WEBPACK_IMPORTED_MODULE_4__.Box, {\n                                        w: 3,\n                                        h: 3,\n                                        borderRadius: \"full\",\n                                        bg: \"yellow.400\"\n                                    }, void 0, false, {\n                                        fileName: \"C:\\\\Users\\\\hr-hm\\\\Desktop\\\\study\\\\vimapp\\\\src\\\\components\\\\VimEditor.tsx\",\n                                        lineNumber: 277,\n                                        columnNumber: 13\n                                    }, this),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_chakra_ui_react__WEBPACK_IMPORTED_MODULE_4__.Box, {\n                                        w: 3,\n                                        h: 3,\n                                        borderRadius: \"full\",\n                                        bg: \"green.400\"\n                                    }, void 0, false, {\n                                        fileName: \"C:\\\\Users\\\\hr-hm\\\\Desktop\\\\study\\\\vimapp\\\\src\\\\components\\\\VimEditor.tsx\",\n                                        lineNumber: 278,\n                                        columnNumber: 13\n                                    }, this)\n                                ]\n                            }, void 0, true, {\n                                fileName: \"C:\\\\Users\\\\hr-hm\\\\Desktop\\\\study\\\\vimapp\\\\src\\\\components\\\\VimEditor.tsx\",\n                                lineNumber: 275,\n                                columnNumber: 11\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_chakra_ui_react__WEBPACK_IMPORTED_MODULE_5__.Flex, {\n                                alignItems: \"center\",\n                                children: [\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_chakra_ui_react__WEBPACK_IMPORTED_MODULE_14__.Icon, {\n                                        as: _barrel_optimize_names_FiCommand_FiEdit_FiRefreshCw_FiTerminal_react_icons_fi__WEBPACK_IMPORTED_MODULE_7__.FiTerminal,\n                                        color: \"secondary.400\",\n                                        mr: 2\n                                    }, void 0, false, {\n                                        fileName: \"C:\\\\Users\\\\hr-hm\\\\Desktop\\\\study\\\\vimapp\\\\src\\\\components\\\\VimEditor.tsx\",\n                                        lineNumber: 281,\n                                        columnNumber: 13\n                                    }, this),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(MotionText, {\n                                        fontFamily: \"mono\",\n                                        fontWeight: \"medium\",\n                                        letterSpacing: \"tight\",\n                                        color: \"white\",\n                                        initial: {\n                                            opacity: 0,\n                                            y: -10\n                                        },\n                                        animate: {\n                                            opacity: 1,\n                                            y: 0\n                                        },\n                                        transition: {\n                                            duration: 0.3\n                                        },\n                                        children: [\n                                            mode.toUpperCase(),\n                                            \" Editor\"\n                                        ]\n                                    }, mode, true, {\n                                        fileName: \"C:\\\\Users\\\\hr-hm\\\\Desktop\\\\study\\\\vimapp\\\\src\\\\components\\\\VimEditor.tsx\",\n                                        lineNumber: 282,\n                                        columnNumber: 13\n                                    }, this)\n                                ]\n                            }, void 0, true, {\n                                fileName: \"C:\\\\Users\\\\hr-hm\\\\Desktop\\\\study\\\\vimapp\\\\src\\\\components\\\\VimEditor.tsx\",\n                                lineNumber: 280,\n                                columnNumber: 11\n                            }, this)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"C:\\\\Users\\\\hr-hm\\\\Desktop\\\\study\\\\vimapp\\\\src\\\\components\\\\VimEditor.tsx\",\n                        lineNumber: 274,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_chakra_ui_react__WEBPACK_IMPORTED_MODULE_13__.HStack, {\n                        justifyContent: \"flex-end\",\n                        gap: 2,\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_chakra_ui_react__WEBPACK_IMPORTED_MODULE_15__.Button, {\n                                onClick: ()=>setShowPreview((prev)=>!prev),\n                                colorScheme: showPreview ? \"purple\" : \"gray\",\n                                bg: showPreview ? \"linear-gradient(135deg, rgba(128,90,213,0.2), rgba(128,90,213,0.1))\" : \"transparent\",\n                                color: showPreview ? \"purple.400\" : \"gray.400\",\n                                borderRadius: \"md\",\n                                px: 3,\n                                py: 1.5,\n                                height: \"auto\",\n                                fontFamily: \"mono\",\n                                fontWeight: showPreview ? \"bold\" : \"medium\",\n                                letterSpacing: \"tight\",\n                                borderWidth: showPreview ? 1 : 0,\n                                borderColor: showPreview ? \"purple.800\" : \"transparent\",\n                                _hover: {\n                                    bg: \"linear-gradient(135deg, rgba(128,90,213,0.3), rgba(128,90,213,0.15))\",\n                                    color: \"purple.400\",\n                                    transform: \"translateY(-1px)\",\n                                    boxShadow: \"0 4px 8px rgba(0,0,0,0.3)\"\n                                },\n                                _active: {\n                                    bg: \"blackAlpha.500\",\n                                    transform: \"translateY(0)\"\n                                },\n                                _focus: {\n                                    outline: \"none\"\n                                },\n                                _focusVisible: {\n                                    outline: \"none\"\n                                },\n                                transition: \"all 0.2s cubic-bezier(0.4, 0, 0.2, 1)\",\n                                mr: 1,\n                                \"aria-label\": \"プレビュー表示切り替え\",\n                                \"aria-pressed\": showPreview,\n                                children: \"Preview\"\n                            }, void 0, false, {\n                                fileName: \"C:\\\\Users\\\\hr-hm\\\\Desktop\\\\study\\\\vimapp\\\\src\\\\components\\\\VimEditor.tsx\",\n                                lineNumber: 297,\n                                columnNumber: 11\n                            }, this),\n                            [\n                                \"html\",\n                                \"css\",\n                                \"js\"\n                            ].map((m)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_chakra_ui_react__WEBPACK_IMPORTED_MODULE_15__.Button, {\n                                    onClick: ()=>handleModeChange(m),\n                                    colorScheme: mode === m ? \"orange\" : \"gray\",\n                                    bg: mode === m ? \"linear-gradient(135deg, rgba(255,152,0,0.2), rgba(255,152,0,0.1))\" : \"transparent\",\n                                    color: mode === m ? \"secondary.400\" : \"gray.400\",\n                                    borderRadius: \"md\",\n                                    px: 3,\n                                    py: 1.5,\n                                    height: \"auto\",\n                                    fontFamily: \"mono\",\n                                    fontWeight: mode === m ? \"bold\" : \"medium\",\n                                    letterSpacing: \"tight\",\n                                    borderWidth: mode === m ? 1 : 0,\n                                    borderColor: mode === m ? \"secondary.800\" : \"transparent\",\n                                    _hover: {\n                                        bg: mode === m ? \"linear-gradient(135deg, rgba(255,152,0,0.3), rgba(255,152,0,0.15))\" : \"blackAlpha.300\",\n                                        color: \"secondary.400\",\n                                        transform: \"translateY(-1px)\",\n                                        boxShadow: \"0 4px 8px rgba(0,0,0,0.3)\"\n                                    },\n                                    _active: {\n                                        bg: \"blackAlpha.500\",\n                                        transform: \"translateY(0)\"\n                                    },\n                                    _focus: {\n                                        outline: \"none\",\n                                        boxShadow: \"none\"\n                                    },\n                                    _focusVisible: {\n                                        outline: \"2px solid\",\n                                        outlineColor: \"secondary.400\",\n                                        outlineOffset: \"2px\",\n                                        boxShadow: \"0 0 0 2px rgba(255,152,0,0.3)\",\n                                        borderColor: mode === m ? \"secondary.800\" : \"transparent\"\n                                    },\n                                    transition: \"all 0.2s cubic-bezier(0.4, 0, 0.2, 1)\",\n                                    mr: 1,\n                                    \"aria-label\": \"\".concat(m.toUpperCase(), \"エディターモードに切り替え\"),\n                                    \"aria-pressed\": mode === m,\n                                    children: m.toUpperCase()\n                                }, m, false, {\n                                    fileName: \"C:\\\\Users\\\\hr-hm\\\\Desktop\\\\study\\\\vimapp\\\\src\\\\components\\\\VimEditor.tsx\",\n                                    lineNumber: 335,\n                                    columnNumber: 13\n                                }, this)),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_chakra_ui_react__WEBPACK_IMPORTED_MODULE_15__.Button, {\n                                onClick: handleReset,\n                                colorScheme: \"gray\",\n                                bg: \"transparent\",\n                                color: \"gray.400\",\n                                borderRadius: \"md\",\n                                px: 3,\n                                py: 1.5,\n                                height: \"auto\",\n                                fontFamily: \"mono\",\n                                fontWeight: \"medium\",\n                                letterSpacing: \"tight\",\n                                borderWidth: 0,\n                                _hover: {\n                                    bg: \"linear-gradient(135deg, rgba(128,90,213,0.2), rgba(128,90,213,0.1))\",\n                                    color: \"purple.400\",\n                                    transform: \"translateY(-1px)\",\n                                    boxShadow: \"0 4px 8px rgba(0,0,0,0.3)\"\n                                },\n                                _active: {\n                                    bg: \"blackAlpha.500\",\n                                    transform: \"translateY(0)\"\n                                },\n                                _focus: {\n                                    outline: \"none\"\n                                },\n                                _focusVisible: {\n                                    outline: \"none\"\n                                },\n                                transition: \"all 0.2s cubic-bezier(0.4, 0, 0.2, 1)\",\n                                ml: 2,\n                                \"aria-label\": \"エディターの内容をリセット\",\n                                children: [\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_chakra_ui_react__WEBPACK_IMPORTED_MODULE_14__.Icon, {\n                                        as: _barrel_optimize_names_FiCommand_FiEdit_FiRefreshCw_FiTerminal_react_icons_fi__WEBPACK_IMPORTED_MODULE_7__.FiRefreshCw,\n                                        mr: 1\n                                    }, void 0, false, {\n                                        fileName: \"C:\\\\Users\\\\hr-hm\\\\Desktop\\\\study\\\\vimapp\\\\src\\\\components\\\\VimEditor.tsx\",\n                                        lineNumber: 415,\n                                        columnNumber: 13\n                                    }, this),\n                                    \" Reset\"\n                                ]\n                            }, void 0, true, {\n                                fileName: \"C:\\\\Users\\\\hr-hm\\\\Desktop\\\\study\\\\vimapp\\\\src\\\\components\\\\VimEditor.tsx\",\n                                lineNumber: 386,\n                                columnNumber: 11\n                            }, this)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"C:\\\\Users\\\\hr-hm\\\\Desktop\\\\study\\\\vimapp\\\\src\\\\components\\\\VimEditor.tsx\",\n                        lineNumber: 296,\n                        columnNumber: 9\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"C:\\\\Users\\\\hr-hm\\\\Desktop\\\\study\\\\vimapp\\\\src\\\\components\\\\VimEditor.tsx\",\n                lineNumber: 253,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(MotionFlex, {\n                position: \"absolute\",\n                bottom: 0,\n                left: 0,\n                right: 0,\n                px: 4,\n                py: 1.5,\n                bg: \"linear-gradient(135deg, rgba(0,0,0,0.8), rgba(0,0,0,0.6))\",\n                borderTopWidth: 1,\n                borderColor: \"primary.700\",\n                zIndex: 5,\n                fontSize: \"sm\",\n                fontFamily: \"mono\",\n                justifyContent: \"space-between\",\n                alignItems: \"center\",\n                backdropFilter: \"blur(10px)\",\n                _before: {\n                    content: '\"\"',\n                    position: \"absolute\",\n                    top: 0,\n                    left: 0,\n                    right: 0,\n                    height: \"1px\",\n                    background: \"linear-gradient(90deg, transparent, \".concat(modeInfo[vimMode].color, \", transparent)\"),\n                    opacity: 0.6\n                },\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(framer_motion__WEBPACK_IMPORTED_MODULE_16__.AnimatePresence, {\n                        mode: \"wait\",\n                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(MotionFlex, {\n                            alignItems: \"center\",\n                            variants: modeIndicatorVariants,\n                            initial: \"hidden\",\n                            animate: \"visible\",\n                            exit: \"exit\",\n                            children: [\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_chakra_ui_react__WEBPACK_IMPORTED_MODULE_14__.Icon, {\n                                    as: modeInfo[vimMode].icon,\n                                    color: modeInfo[vimMode].color,\n                                    mr: 2\n                                }, void 0, false, {\n                                    fileName: \"C:\\\\Users\\\\hr-hm\\\\Desktop\\\\study\\\\vimapp\\\\src\\\\components\\\\VimEditor.tsx\",\n                                    lineNumber: 456,\n                                    columnNumber: 13\n                                }, this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(MotionText, {\n                                    color: modeInfo[vimMode].color,\n                                    fontWeight: \"medium\",\n                                    fontSize: \"sm\",\n                                    textShadow: \"0 0 8px \".concat(modeInfo[vimMode].color, \"40\"),\n                                    children: modeInfo[vimMode].text\n                                }, void 0, false, {\n                                    fileName: \"C:\\\\Users\\\\hr-hm\\\\Desktop\\\\study\\\\vimapp\\\\src\\\\components\\\\VimEditor.tsx\",\n                                    lineNumber: 461,\n                                    columnNumber: 13\n                                }, this)\n                            ]\n                        }, vimMode, true, {\n                            fileName: \"C:\\\\Users\\\\hr-hm\\\\Desktop\\\\study\\\\vimapp\\\\src\\\\components\\\\VimEditor.tsx\",\n                            lineNumber: 448,\n                            columnNumber: 11\n                        }, this)\n                    }, void 0, false, {\n                        fileName: \"C:\\\\Users\\\\hr-hm\\\\Desktop\\\\study\\\\vimapp\\\\src\\\\components\\\\VimEditor.tsx\",\n                        lineNumber: 447,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_chakra_ui_react__WEBPACK_IMPORTED_MODULE_6__.Text, {\n                        color: \"gray.500\",\n                        fontSize: \"xs\",\n                        children: modeInfo[vimMode].hint\n                    }, void 0, false, {\n                        fileName: \"C:\\\\Users\\\\hr-hm\\\\Desktop\\\\study\\\\vimapp\\\\src\\\\components\\\\VimEditor.tsx\",\n                        lineNumber: 471,\n                        columnNumber: 9\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"C:\\\\Users\\\\hr-hm\\\\Desktop\\\\study\\\\vimapp\\\\src\\\\components\\\\VimEditor.tsx\",\n                lineNumber: 420,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_chakra_ui_react__WEBPACK_IMPORTED_MODULE_4__.Box, {\n                flex: 1,\n                minHeight: 0,\n                borderRadius: \"lg\",\n                overflow: \"hidden\",\n                width: \"100%\",\n                display: \"flex\",\n                position: \"relative\",\n                mb: 8,\n                height: \"100%\",\n                maxH: \"100%\",\n                children: [\n                    !showPreview && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_chakra_ui_react__WEBPACK_IMPORTED_MODULE_4__.Box, {\n                        w: \"100%\",\n                        h: \"100%\",\n                        maxH: {\n                            base: \"340px\",\n                            md: \"480px\",\n                            lg: \"560px\"\n                        },\n                        minH: {\n                            base: \"220px\",\n                            md: \"320px\"\n                        },\n                        overflowY: \"auto\",\n                        borderRadius: \"md\",\n                        bg: \"transparent\",\n                        boxShadow: \"none\",\n                        style: {\n                            height: \"100%\",\n                            fontSize: \"16px\",\n                            outline: \"none\"\n                        },\n                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_uiw_react_codemirror__WEBPACK_IMPORTED_MODULE_1__[\"default\"], {\n                            value: code,\n                            height: \"100%\",\n                            extensions: getExtensions(),\n                            theme: _codemirror_theme_one_dark__WEBPACK_IMPORTED_MODULE_10__.oneDark,\n                            onChange: onChange,\n                            onUpdate: onUpdate,\n                            style: {\n                                fontSize: \"16px\",\n                                background: \"transparent\"\n                            }\n                        }, void 0, false, {\n                            fileName: \"C:\\\\Users\\\\hr-hm\\\\Desktop\\\\study\\\\vimapp\\\\src\\\\components\\\\VimEditor.tsx\",\n                            lineNumber: 505,\n                            columnNumber: 13\n                        }, this)\n                    }, void 0, false, {\n                        fileName: \"C:\\\\Users\\\\hr-hm\\\\Desktop\\\\study\\\\vimapp\\\\src\\\\components\\\\VimEditor.tsx\",\n                        lineNumber: 490,\n                        columnNumber: 11\n                    }, this),\n                    showPreview && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_chakra_ui_react__WEBPACK_IMPORTED_MODULE_4__.Box, {\n                        w: \"100%\",\n                        h: \"100%\",\n                        maxH: {\n                            base: \"340px\",\n                            md: \"480px\",\n                            lg: \"560px\"\n                        },\n                        minH: {\n                            base: \"220px\",\n                            md: \"320px\"\n                        },\n                        overflowY: \"auto\",\n                        borderRadius: \"md\",\n                        bg: \"white\",\n                        boxShadow: \"md\",\n                        position: \"relative\",\n                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"iframe\", {\n                            title: \"Preview\",\n                            srcDoc: previewSrcDoc,\n                            style: {\n                                width: \"100%\",\n                                height: \"100%\",\n                                border: \"none\",\n                                background: \"white\"\n                            },\n                            sandbox: \"allow-scripts allow-same-origin\"\n                        }, void 0, false, {\n                            fileName: \"C:\\\\Users\\\\hr-hm\\\\Desktop\\\\study\\\\vimapp\\\\src\\\\components\\\\VimEditor.tsx\",\n                            lineNumber: 528,\n                            columnNumber: 13\n                        }, this)\n                    }, void 0, false, {\n                        fileName: \"C:\\\\Users\\\\hr-hm\\\\Desktop\\\\study\\\\vimapp\\\\src\\\\components\\\\VimEditor.tsx\",\n                        lineNumber: 517,\n                        columnNumber: 11\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"C:\\\\Users\\\\hr-hm\\\\Desktop\\\\study\\\\vimapp\\\\src\\\\components\\\\VimEditor.tsx\",\n                lineNumber: 476,\n                columnNumber: 7\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"C:\\\\Users\\\\hr-hm\\\\Desktop\\\\study\\\\vimapp\\\\src\\\\components\\\\VimEditor.tsx\",\n        lineNumber: 217,\n        columnNumber: 5\n    }, this);\n}\n_s(VimEditor, \"fZ9mlgngsbH1AsnQyHZ43PlLZvA=\");\n_c3 = VimEditor;\n/* harmony default export */ __webpack_exports__[\"default\"] = (VimEditor);\nvar _c, _c1, _c2, _c3;\n$RefreshReg$(_c, \"MotionBox\");\n$RefreshReg$(_c1, \"MotionFlex\");\n$RefreshReg$(_c2, \"MotionText\");\n$RefreshReg$(_c3, \"VimEditor\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL1ZpbUVkaXRvci50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLDRCQUE0Qjs7O0FBQzVCLE1BQU1BLGFBQWM7QUFLcEIsTUFBTUMsWUFBYTtBQU9uQixNQUFNQyxXQUFZO0FBSWxCLE1BQU1DLFVBQVc7QUFvQmpCLHVCQUF1QjtBQUNrRDtBQUMxQjtBQUNVO0FBQ0g7QUFDYTtBQUdkO0FBRVI7QUFFVztBQUNTO0FBRVc7QUFFNUUsTUFBTXdCLFlBQVlQLHFEQUFNQSxDQUFDaEIsaURBQUdBO0tBQXRCdUI7QUFDTixNQUFNQyxhQUFhUixxREFBTUEsQ0FBQ2Qsa0RBQUlBO01BQXhCc0I7QUFDTixNQUFNQyxhQUFhVCxxREFBTUEsQ0FBQ1gsa0RBQUlBO01BQXhCb0I7QUFDTixNQUFNQyxXQUFXO0lBQ2ZDLFFBQVE7UUFDTkMsTUFBTTtRQUNOQyxPQUFPO1FBQ1BDLE1BQU1YLG9IQUFTQTtRQUNmWSxNQUFNO0lBQ1I7SUFDQUMsUUFBUTtRQUNOSixNQUFNO1FBQ05DLE9BQU87UUFDUEMsTUFBTVYsaUhBQU1BO1FBQ1pXLE1BQU07SUFDUjtJQUNBRSxRQUFRO1FBQ05MLE1BQU07UUFDTkMsT0FBTztRQUNQQyxNQUFNWCxvSEFBU0E7UUFDZlksTUFBTTtJQUNSO0FBQ0Y7QUFFQSxTQUFTRzs7SUFDUCxNQUFNLENBQUNDLE1BQU1DLFFBQVEsR0FBR2xCLCtDQUFRQSxDQUF3QjtJQUN4RCxNQUFNLENBQUNtQixTQUFTQyxXQUFXLEdBQUdwQiwrQ0FBUUEsQ0FBVTtJQUNoRCwyQ0FBMkM7SUFDM0Msd0JBQXdCO0lBRXhCLGlCQUFpQjtJQUVqQixvQkFBb0I7SUFDcEIsTUFBTXFCLG9CQUFvQjtRQUN4QkMsUUFBUTtZQUFFQyxTQUFTO1lBQUdDLE9BQU87UUFBSztRQUNsQ0MsU0FBUztZQUNQRixTQUFTO1lBQ1RDLE9BQU87WUFDUEUsWUFBWTtnQkFDVkMsVUFBVTtZQUNaO1FBQ0Y7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QVNBLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2NvbXBvbmVudHMvVmltRWRpdG9yLnRzeD8wYjk4Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIC0tLSDjgrXjg7Pjg5fjg6vjgrPjg7zjg4njg7tWaW1UaXBz5a6a5pWwIC0tLVxuY29uc3QgaHRtbFNhbXBsZSA9IGA8ZGl2IGNsYXNzPVwiY29udGFpbmVyXCI+XG4gIDxoMT5IZWxsbyBWaW0hPC9oMT5cbiAgPHA+44GT44KM44GvVmlt57e057+S55So44Gu44K144Oz44OX44Or44Gn44GZ44CCPC9wPlxuPC9kaXY+XG5gO1xuY29uc3QgY3NzU2FtcGxlID0gYC5jb250YWluZXIge1xuICBtYXgtd2lkdGg6IDYwMHB4O1xuICBtYXJnaW46IDAgYXV0bztcbiAgcGFkZGluZzogMnJlbTtcbiAgYmFja2dyb3VuZDogI2Y1ZjVmNTtcbn1cbmA7XG5jb25zdCBqc1NhbXBsZSA9IGBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuY29udGFpbmVyJykuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbigpIHtcbiAgYWxlcnQoJ1ZpbeOBp+e3qOmbhuOBl+OBpuOBv+OCiOOBhu+8gScpO1xufSk7XG5gO1xuY29uc3QgdmltVGlwcyA9IGAvLyAtLS0g44GK44G+44GROiDjgojjgY/kvb/jgYZWaW3jgrPjg57jg7Pjg4kgLS0tXG4vLyBoIC8gaiAvIGsgLyBsIDog5bem5Y+z5LiK5LiL44Gr44Kr44O844K944Or56e75YuVXG4vLyB3IC8gYiAvIGUgOiDljZjoqp7ljZjkvY3jgafnp7vli5Vcbi8vIDAgLyAkIC8gXiA6IOihjOmgreODu+ihjOacq+ODu+acgOWIneOBrumdnuepuueZveaWh+Wtl+OBuFxuLy8gZ2cgLyBHIDog44OV44Kh44Kk44Or5YWI6aCt44O75pyr5bC+44G456e75YuVXG4vLyBpIC8gYSAvIG8gLyBPIDog5oy/5YWl44Oi44O844OJXG4vLyB4IDog5paH5a2X5YmK6ZmkXG4vLyBkZCA6IOihjOWJiumZpFxuLy8geXkgOiDooYzjgrPjg5Tjg7xcbi8vIHAgLyBQIDog6LK844KK5LuY44GRXG4vLyB1IC8gQ3RybCtyIDog44Ki44Oz44OJ44Kl44O744Oq44OJ44KlXG4vLyBjdyAvIGNjIC8gYyQgOiDljZjoqp7jg7vooYzjg7vooYzmnKvjgb7jgaflpInmm7Rcbi8vIC4gOiDnm7TliY3jga7mk43kvZzjgpLnubDjgorov5TjgZdcbi8vIC9wYXR0ZXJuIDog5qSc57SiXG4vLyBuIC8gTiA6IOasoeODu+WJjeOBruaknOe0oue1kOaenOOBuFxuLy8gOiVzL29sZC9uZXcvZyA6IOe9ruaPm1xuLy8gdiAvIFYgOiDpgbjmip7plovlp4tcbi8vIHkgLyBkIDog44Kz44OU44O844O75YmK6ZmkXG5gO1xuXG4vLyAtLS0gVmlt44Oi44O844OJ5oOF5aCx44O75Z6L5a6a576pIC0tLVxuaW1wb3J0IHsgQm94LCBCdXR0b24sIEZsZXgsIEhTdGFjaywgSWNvbiwgVGV4dCB9IGZyb20gXCJAY2hha3JhLXVpL3JlYWN0XCI7XG5pbXBvcnQgQ29kZU1pcnJvciBmcm9tICdAdWl3L3JlYWN0LWNvZGVtaXJyb3InO1xuaW1wb3J0IHsgaHRtbCBhcyBodG1sTGFuZyB9IGZyb20gJ0Bjb2RlbWlycm9yL2xhbmctaHRtbCc7XG5pbXBvcnQgeyBjc3MgYXMgY3NzTGFuZyB9IGZyb20gJ0Bjb2RlbWlycm9yL2xhbmctY3NzJztcbmltcG9ydCB7IGphdmFzY3JpcHQgYXMganNMYW5nIH0gZnJvbSAnQGNvZGVtaXJyb3IvbGFuZy1qYXZhc2NyaXB0Jztcbi8vIHZpbSBpbXBvcnTjga/kuIvjgacx566H5omA44Gg44GRXG5pbXBvcnQgeyBFZGl0b3JTdGF0ZSB9IGZyb20gXCJAY29kZW1pcnJvci9zdGF0ZVwiO1xuaW1wb3J0IHsgb25lRGFyayB9IGZyb20gXCJAY29kZW1pcnJvci90aGVtZS1vbmUtZGFya1wiO1xuaW1wb3J0IHsgRWRpdG9yVmlldyB9IGZyb20gXCJAY29kZW1pcnJvci92aWV3XCI7XG5pbXBvcnQgeyB2aW0gfSBmcm9tIFwiQHJlcGxpdC9jb2RlbWlycm9yLXZpbVwiO1xuaW1wb3J0IHsgYmFzaWNTZXR1cCB9IGZyb20gXCJjb2RlbWlycm9yXCI7XG5pbXBvcnQgeyBBbmltYXRlUHJlc2VuY2UsIG1vdGlvbiB9IGZyb20gXCJmcmFtZXItbW90aW9uXCI7XG5pbXBvcnQgeyB1c2VDYWxsYmFjaywgdXNlRWZmZWN0LCB1c2VSZWYsIHVzZVN0YXRlIH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgdHlwZSB7IEljb25UeXBlIH0gZnJvbSBcInJlYWN0LWljb25zXCI7XG5pbXBvcnQgeyBGaUNvbW1hbmQsIEZpRWRpdCwgRmlSZWZyZXNoQ3csIEZpVGVybWluYWwgfSBmcm9tIFwicmVhY3QtaWNvbnMvZmlcIjtcblxuY29uc3QgTW90aW9uQm94ID0gbW90aW9uKEJveCk7XG5jb25zdCBNb3Rpb25GbGV4ID0gbW90aW9uKEZsZXgpO1xuY29uc3QgTW90aW9uVGV4dCA9IG1vdGlvbihUZXh0KTtcbmNvbnN0IG1vZGVJbmZvID0ge1xuICBub3JtYWw6IHtcbiAgICB0ZXh0OiBcIk5PUk1BTFwiLFxuICAgIGNvbG9yOiBcIm9yYW5nZS40MDBcIixcbiAgICBpY29uOiBGaUNvbW1hbmQgYXMgSWNvblR5cGUsXG4gICAgaGludDogXCJQcmVzcyBpIHRvIGVudGVyIGluc2VydCBtb2RlXCIsXG4gIH0sXG4gIGluc2VydDoge1xuICAgIHRleHQ6IFwiSU5TRVJUXCIsXG4gICAgY29sb3I6IFwiZ3JlZW4uNDAwXCIsXG4gICAgaWNvbjogRmlFZGl0IGFzIEljb25UeXBlLFxuICAgIGhpbnQ6IFwiUHJlc3MgRXNjIHRvIHJldHVybiB0byBub3JtYWwgbW9kZVwiLFxuICB9LFxuICB2aXN1YWw6IHtcbiAgICB0ZXh0OiBcIlZJU1VBTFwiLFxuICAgIGNvbG9yOiBcInB1cnBsZS40MDBcIixcbiAgICBpY29uOiBGaUNvbW1hbmQgYXMgSWNvblR5cGUsXG4gICAgaGludDogXCJTZWxlY3QgdGV4dCB3aXRoIGgsaixrLGwgb3IgdXNlIHkgdG8gY29weVwiLFxuICB9LFxufSBhcyBjb25zdDtcbnR5cGUgVmltTW9kZSA9IGtleW9mIHR5cGVvZiBtb2RlSW5mbztcbmZ1bmN0aW9uIFZpbUVkaXRvcigpIHtcbiAgY29uc3QgW21vZGUsIHNldE1vZGVdID0gdXNlU3RhdGU8XCJodG1sXCIgfCBcImNzc1wiIHwgXCJqc1wiPihcImh0bWxcIik7XG4gIGNvbnN0IFt2aW1Nb2RlLCBzZXRWaW1Nb2RlXSA9IHVzZVN0YXRlPFZpbU1vZGU+KFwibm9ybWFsXCIpO1xuICAvLyBTU1IvQ1NS5beu55Ww44Gr44KI44KLZWRpdG9y5o+P55S76YGF5bu25a++562WOiBpc01vdW50ZWTliKTlrprjgpLlu4PmraJcbiAgLy8gZWRpdG9yUmVmLCB2aWV3UmVm44Gv5LiN6KaBXG5cbiAgLy8gaXNNb3VudGVk5Yik5a6a44KS5buD5q2iXG5cbiAgLy8g44Ki44OL44Oh44O844K344On44Oz55So44GudmFyaWFudHNcbiAgY29uc3QgY29udGFpbmVyVmFyaWFudHMgPSB7XG4gICAgaGlkZGVuOiB7IG9wYWNpdHk6IDAsIHNjYWxlOiAwLjk4IH0sXG4gICAgdmlzaWJsZToge1xuICAgICAgb3BhY2l0eTogMSxcbiAgICAgIHNjYWxlOiAxLFxuICAgICAgdHJhbnNpdGlvbjoge1xuICAgICAgICBkdXJhdGlvbjogMC40LFxuICAgICAgfSxcbiAgICB9LFxuICB9O1xuXG4gIGNvbnN0IG1vZGVJbmRpY2F0b3JWYXJpYW50cyA9IHtcbiAgICBoaWRkZW46IHsgb3BhY2l0eTogMCwgeDogLTE1LCBzY2FsZTogMC45IH0sXG4gICAgdmlzaWJsZToge1xuICAgICAgb3BhY2l0eTogMSxcbiAgICAgIHg6IDAsXG4gICAgICBzY2FsZTogMSxcbiAgICAgIHRyYW5zaXRpb246IHtcbiAgICAgICAgZHVyYXRpb246IDAuMyxcbiAgICAgIH0sXG4gICAgfSxcbiAgICBleGl0OiB7XG4gICAgICBvcGFjaXR5OiAwLFxuICAgICAgeDogMTUsXG4gICAgICBzY2FsZTogMC45LFxuICAgICAgdHJhbnNpdGlvbjoge1xuICAgICAgICBkdXJhdGlvbjogMC4yLFxuICAgICAgfSxcbiAgICB9LFxuICB9O1xuXG4gIC8vIOiogOiqnuaLoeW8teWPluW+l++8iEB1aXcvcmVhY3QtY29kZW1pcnJvcueUqO+8iVxuICBmdW5jdGlvbiBnZXRFeHRlbnNpb25zKCkge1xuICAgIHN3aXRjaCAobW9kZSkge1xuICAgICAgY2FzZSBcImh0bWxcIjpcbiAgICAgICAgcmV0dXJuIFtodG1sTGFuZygpLCB2aW0oKSwgb25lRGFya107XG4gICAgICBjYXNlIFwiY3NzXCI6XG4gICAgICAgIHJldHVybiBbY3NzTGFuZygpLCB2aW0oKSwgb25lRGFya107XG4gICAgICBjYXNlIFwianNcIjpcbiAgICAgICAgcmV0dXJuIFtqc0xhbmcoKSwgdmltKCksIG9uZURhcmtdO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIFt2aW0oKSwgb25lRGFya107XG4gICAgfVxuICB9XG5cbiAgY29uc3QgW2h0bWwsIHNldEh0bWxdID0gdXNlU3RhdGU8c3RyaW5nPihodG1sU2FtcGxlKTtcbiAgY29uc3QgW2Nzcywgc2V0Q3NzXSA9IHVzZVN0YXRlPHN0cmluZz4oY3NzU2FtcGxlKTtcbiAgY29uc3QgW2pzLCBzZXRKc10gPSB1c2VTdGF0ZTxzdHJpbmc+KGpzU2FtcGxlKTtcbiAgY29uc3QgW2NvZGUsIHNldENvZGVdID0gdXNlU3RhdGU8c3RyaW5nPihodG1sU2FtcGxlICsgdmltVGlwcyk7XG5cbiAgLy8g5Yid5Zue44Os44Oz44OA44Oq44Oz44Kw5pmC44Gr5b+F44GaaHRtbFNhbXBsZSt2aW1UaXBz44Gn5Yid5pyf5YyWXG4gIC8vIGVkaXRvcuWIneacn+WMluODu1ZpbeODouODvOODieebo+imluOBr29uVXBkYXRlL29uQ2hhbmdl44Gn5Y2B5YiGXG4gIC8vIFZpbeODouODvOODieebo+imlu+8iEB1aXcvcmVhY3QtY29kZW1pcnJvcuOBrm9uVXBkYXRl44Gn5Yik5a6a77yJXG4gIC8vIFZpbeODouODvOODieWIpOWumuOBr29uQ2hhbmdl44Gn5bi444Grbm9ybWFs44Gr5oi744GZ77yIaW5zZXJ044GvVmlt5ouh5by144Gn6Ieq5YuV77yJXG4gIGNvbnN0IG9uVXBkYXRlID0gdXNlQ2FsbGJhY2soKF92aWV3VXBkYXRlOiBhbnkpID0+IHt9LCBbXSk7XG5cbiAgY29uc3QgZ2V0U2FtcGxlID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIGlmIChtb2RlID09PSBcImh0bWxcIikgcmV0dXJuIGh0bWxTYW1wbGUgKyB2aW1UaXBzO1xuICAgIGlmIChtb2RlID09PSBcImNzc1wiKSByZXR1cm4gY3NzU2FtcGxlICsgdmltVGlwcztcbiAgICByZXR1cm4ganNTYW1wbGUgKyB2aW1UaXBzO1xuICB9LCBbbW9kZV0pO1xuXG4gIC8vIOS4iuiomOOBp+Wuo+iogOa4iOOBv+OBquOBruOBp+mHjeikh+WJiumZpFxuICBjb25zdCBbc2hvd1ByZXZpZXcsIHNldFNob3dQcmV2aWV3XSA9IHVzZVN0YXRlPGJvb2xlYW4+KGZhbHNlKTtcblxuICBjb25zdCBoYW5kbGVSZXNldCA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBzZXRIdG1sKGh0bWxTYW1wbGUpO1xuICAgIHNldENzcyhjc3NTYW1wbGUpO1xuICAgIHNldEpzKGpzU2FtcGxlKTtcbiAgICBzZXRDb2RlKFxuICAgICAgbW9kZSA9PT0gXCJodG1sXCJcbiAgICAgICAgPyBodG1sU2FtcGxlICsgdmltVGlwc1xuICAgICAgICA6IG1vZGUgPT09IFwiY3NzXCJcbiAgICAgICAgPyBjc3NTYW1wbGUgKyB2aW1UaXBzXG4gICAgICAgIDoganNTYW1wbGUgKyB2aW1UaXBzXG4gICAgKTtcbiAgICBzZXRWaW1Nb2RlKFwibm9ybWFsXCIpO1xuICAgIHNldFNob3dQcmV2aWV3KGZhbHNlKTtcbiAgfSwgW21vZGVdKTtcblxuICBjb25zdCBoYW5kbGVNb2RlQ2hhbmdlID0gdXNlQ2FsbGJhY2soXG4gICAgKG06IFwiaHRtbFwiIHwgXCJjc3NcIiB8IFwianNcIikgPT4ge1xuICAgICAgLy8g54++5Zyo44Gu5YaF5a6544KS5L+d5a2YXG4gICAgICBpZiAobW9kZSA9PT0gXCJodG1sXCIpIHNldEh0bWwoY29kZS5yZXBsYWNlKHZpbVRpcHMsIFwiXCIpKTtcbiAgICAgIGlmIChtb2RlID09PSBcImNzc1wiKSBzZXRDc3MoY29kZS5yZXBsYWNlKHZpbVRpcHMsIFwiXCIpKTtcbiAgICAgIGlmIChtb2RlID09PSBcImpzXCIpIHNldEpzKGNvZGUucmVwbGFjZSh2aW1UaXBzLCBcIlwiKSk7XG4gICAgICAvLyDjg6Ljg7zjg4nliIfjgormm7/jgYhcbiAgICAgIHNldE1vZGUobSk7XG4gICAgICAvLyDliIfjgormm7/jgYjlhYjjga7lhoXlrrnjgpLooajnpLpcbiAgICAgIGlmIChtID09PSBcImh0bWxcIikgc2V0Q29kZShodG1sICsgdmltVGlwcyk7XG4gICAgICBlbHNlIGlmIChtID09PSBcImNzc1wiKSBzZXRDb2RlKGNzcyArIHZpbVRpcHMpO1xuICAgICAgZWxzZSBzZXRDb2RlKGpzICsgdmltVGlwcyk7XG4gICAgICBzZXRTaG93UHJldmlldyhmYWxzZSk7XG4gICAgfSxcbiAgICBbbW9kZSwgY29kZSwgaHRtbCwgY3NzLCBqc11cbiAgKTtcbiAgLy8g44OX44Os44OT44Ol44O855SoSFRNTOeUn+aIkO+8iOacgOaWsOOBrmh0bWwsIGNzcywganPlhoXlrrnjgpLlkIjmiJDvvIlcbiAgY29uc3QgcHJldmlld1NyY0RvYyA9IGBcbiAgICA8IURPQ1RZUEUgaHRtbD5cbiAgICA8aHRtbCBsYW5nPVwiamFcIj5cbiAgICA8aGVhZD5cbiAgICAgIDxtZXRhIGNoYXJzZXQ9XCJVVEYtOFwiIC8+XG4gICAgICA8bWV0YSBuYW1lPVwidmlld3BvcnRcIiBjb250ZW50PVwid2lkdGg9ZGV2aWNlLXdpZHRoLCBpbml0aWFsLXNjYWxlPTEuMFwiIC8+XG4gICAgICA8dGl0bGU+UHJldmlldzwvdGl0bGU+XG4gICAgICA8c3R5bGU+XG4gICAgICAke2Nzc31cbiAgICAgIDwvc3R5bGU+XG4gICAgPC9oZWFkPlxuICAgIDxib2R5PlxuICAgICAgJHtodG1sfVxuICAgICAgPHNjcmlwdD5cbiAgICAgICR7anN9XG4gICAgICA8L3NjcmlwdD5cbiAgICA8L2JvZHk+XG4gICAgPC9odG1sPlxuICBgO1xuXG4gIGNvbnN0IG9uQ2hhbmdlID0gdXNlQ2FsbGJhY2soXG4gICAgKHZhbHVlOiBzdHJpbmcpID0+IHtcbiAgICAgIHNldENvZGUodmFsdWUpO1xuICAgICAgLy8g57eo6ZuG5YaF5a6544KS5L+d5a2YXG4gICAgICBpZiAobW9kZSA9PT0gXCJodG1sXCIpIHNldEh0bWwodmFsdWUucmVwbGFjZSh2aW1UaXBzLCBcIlwiKSk7XG4gICAgICBpZiAobW9kZSA9PT0gXCJjc3NcIikgc2V0Q3NzKHZhbHVlLnJlcGxhY2UodmltVGlwcywgXCJcIikpO1xuICAgICAgaWYgKG1vZGUgPT09IFwianNcIikgc2V0SnModmFsdWUucmVwbGFjZSh2aW1UaXBzLCBcIlwiKSk7XG4gICAgfSxcbiAgICBbbW9kZV1cbiAgKTtcbiAgLy8gU1NSL0NTUuW3rueVsOOBq+OCiOOCi+mrmOOBlTDllY/poYzjgpLpmLLjgZBcbiAgcmV0dXJuIChcbiAgICA8TW90aW9uQm94XG4gICAgICBiZ0dyYWRpZW50PVwiZ3JhZGllbnQucHJpbWFyeVwiXG4gICAgICBjb2xvcj1cInRleHQucHJpbWFyeVwiXG4gICAgICBwPXt7IGJhc2U6IDIsIG1kOiA0IH19XG4gICAgICBib3JkZXJSYWRpdXM9XCIyeGxcIlxuICAgICAgYm94U2hhZG93PVwiZ2xhc3NcIlxuICAgICAgZGlzcGxheT1cImZsZXhcIlxuICAgICAgZmxleERpcmVjdGlvbj1cImNvbHVtblwiXG4gICAgICBib3JkZXJXaWR0aD17MX1cbiAgICAgIGJvcmRlckNvbG9yPVwiYm9yZGVyLnByaW1hcnlcIlxuICAgICAgcG9zaXRpb249XCJyZWxhdGl2ZVwiXG4gICAgICBvdmVyZmxvdz1cImhpZGRlblwiXG4gICAgICBmbGV4PXsxfVxuICAgICAgbWluSD17eyBiYXNlOiBcIjQwMHB4XCIsIG1kOiBcIjUyMHB4XCIsIGxnOiBcIjYwMHB4XCIgfX1cbiAgICAgIG1heEg9e3sgYmFzZTogXCI1MjBweFwiLCBtZDogXCI2NDBweFwiLCBsZzogXCI3MDBweFwiIH19XG4gICAgICBoPXt7IGJhc2U6IFwiNDQwcHhcIiwgbWQ6IFwiNjAwcHhcIiwgbGc6IFwiNjgwcHhcIiB9fVxuICAgICAgaW5pdGlhbD1cImhpZGRlblwiXG4gICAgICBhbmltYXRlPVwidmlzaWJsZVwiXG4gICAgICB2YXJpYW50cz17Y29udGFpbmVyVmFyaWFudHN9XG4gICAgICBfYmVmb3JlPXt7XG4gICAgICAgIGNvbnRlbnQ6ICdcIlwiJyxcbiAgICAgICAgcG9zaXRpb246IFwiYWJzb2x1dGVcIixcbiAgICAgICAgdG9wOiAwLFxuICAgICAgICBsZWZ0OiAwLFxuICAgICAgICByaWdodDogMCxcbiAgICAgICAgYm90dG9tOiAwLFxuICAgICAgICBiYWNrZ3JvdW5kOiBcImdyYWRpZW50LmdsYXNzXCIsXG4gICAgICAgIGJvcmRlclJhZGl1czogXCJpbmhlcml0XCIsXG4gICAgICAgIHBvaW50ZXJFdmVudHM6IFwibm9uZVwiLFxuICAgICAgfX1cbiAgICAgIF9ob3Zlcj17e1xuICAgICAgICBib3hTaGFkb3c6IFwiZ2xhc3MtaG92ZXJcIixcbiAgICAgICAgdHJhbnNmb3JtOiBcInRyYW5zbGF0ZVkoLTFweClcIixcbiAgICAgIH19XG4gICAgPlxuICAgICAgey8qIC0tLSBFZGl0b3IgSGVhZGVyIChtYWNPU+miqOOCpuOCo+ODs+ODieOCpuOCs+ODs+ODiOODreODvOODqykgLS0tICovfVxuICAgICAgPE1vdGlvbkZsZXhcbiAgICAgICAgYWxpZ25JdGVtcz1cImNlbnRlclwiXG4gICAgICAgIHB4PXtbMiwgNF19XG4gICAgICAgIHB5PXtbMiwgM119XG4gICAgICAgIGJvcmRlckJvdHRvbVdpZHRoPXsxfVxuICAgICAgICBib3JkZXJDb2xvcj1cInByaW1hcnkuNzAwXCJcbiAgICAgICAgYmdHcmFkaWVudD1cImxpbmVhcih0by1yLCBwcmltYXJ5LjkwMCwgcHJpbWFyeS44MDApXCJcbiAgICAgICAganVzdGlmeUNvbnRlbnQ9XCJzcGFjZS1iZXR3ZWVuXCJcbiAgICAgICAgcG9zaXRpb249XCJyZWxhdGl2ZVwiXG4gICAgICAgIF9iZWZvcmU9e3tcbiAgICAgICAgICBjb250ZW50OiAnXCJcIicsXG4gICAgICAgICAgcG9zaXRpb246IFwiYWJzb2x1dGVcIixcbiAgICAgICAgICB0b3A6IDAsXG4gICAgICAgICAgbGVmdDogMCxcbiAgICAgICAgICByaWdodDogMCxcbiAgICAgICAgICBib3R0b206IDAsXG4gICAgICAgICAgYmFja2dyb3VuZDpcbiAgICAgICAgICAgIFwibGluZWFyLWdyYWRpZW50KDkwZGVnLCByZ2JhKDI1NSwxNTIsMCwwLjA4KSAwJSwgdHJhbnNwYXJlbnQgNTAlLCByZ2JhKDI1NSwxNTIsMCwwLjAzKSAxMDAlKVwiLFxuICAgICAgICAgIHBvaW50ZXJFdmVudHM6IFwibm9uZVwiLFxuICAgICAgICB9fVxuICAgICAgPlxuICAgICAgICA8RmxleCBhbGlnbkl0ZW1zPVwiY2VudGVyXCI+XG4gICAgICAgICAgPEhTdGFjayBnYXA9ezJ9IG1hcmdpblJpZ2h0PXs1fT5cbiAgICAgICAgICAgIDxCb3ggdz17M30gaD17M30gYm9yZGVyUmFkaXVzPVwiZnVsbFwiIGJnPVwicmVkLjQwMFwiIC8+XG4gICAgICAgICAgICA8Qm94IHc9ezN9IGg9ezN9IGJvcmRlclJhZGl1cz1cImZ1bGxcIiBiZz1cInllbGxvdy40MDBcIiAvPlxuICAgICAgICAgICAgPEJveCB3PXszfSBoPXszfSBib3JkZXJSYWRpdXM9XCJmdWxsXCIgYmc9XCJncmVlbi40MDBcIiAvPlxuICAgICAgICAgIDwvSFN0YWNrPlxuICAgICAgICAgIDxGbGV4IGFsaWduSXRlbXM9XCJjZW50ZXJcIj5cbiAgICAgICAgICAgIDxJY29uIGFzPXtGaVRlcm1pbmFsfSBjb2xvcj1cInNlY29uZGFyeS40MDBcIiBtcj17Mn0gLz5cbiAgICAgICAgICAgIDxNb3Rpb25UZXh0XG4gICAgICAgICAgICAgIGZvbnRGYW1pbHk9XCJtb25vXCJcbiAgICAgICAgICAgICAgZm9udFdlaWdodD1cIm1lZGl1bVwiXG4gICAgICAgICAgICAgIGxldHRlclNwYWNpbmc9XCJ0aWdodFwiXG4gICAgICAgICAgICAgIGNvbG9yPVwid2hpdGVcIlxuICAgICAgICAgICAgICBrZXk9e21vZGV9XG4gICAgICAgICAgICAgIGluaXRpYWw9e3sgb3BhY2l0eTogMCwgeTogLTEwIH19XG4gICAgICAgICAgICAgIGFuaW1hdGU9e3sgb3BhY2l0eTogMSwgeTogMCB9fVxuICAgICAgICAgICAgICB0cmFuc2l0aW9uPXt7IGR1cmF0aW9uOiAwLjMgfX1cbiAgICAgICAgICAgID5cbiAgICAgICAgICAgICAge21vZGUudG9VcHBlckNhc2UoKX0gRWRpdG9yXG4gICAgICAgICAgICA8L01vdGlvblRleHQ+XG4gICAgICAgICAgPC9GbGV4PlxuICAgICAgICA8L0ZsZXg+XG4gICAgICAgIDxIU3RhY2sganVzdGlmeUNvbnRlbnQ9XCJmbGV4LWVuZFwiIGdhcD17Mn0+XG4gICAgICAgICAgPEJ1dHRvblxuICAgICAgICAgICAgb25DbGljaz17KCkgPT4gc2V0U2hvd1ByZXZpZXcoKHByZXYpID0+ICFwcmV2KX1cbiAgICAgICAgICAgIGNvbG9yU2NoZW1lPXtzaG93UHJldmlldyA/IFwicHVycGxlXCIgOiBcImdyYXlcIn1cbiAgICAgICAgICAgIGJnPXtcbiAgICAgICAgICAgICAgc2hvd1ByZXZpZXdcbiAgICAgICAgICAgICAgICA/IFwibGluZWFyLWdyYWRpZW50KDEzNWRlZywgcmdiYSgxMjgsOTAsMjEzLDAuMiksIHJnYmEoMTI4LDkwLDIxMywwLjEpKVwiXG4gICAgICAgICAgICAgICAgOiBcInRyYW5zcGFyZW50XCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbG9yPXtzaG93UHJldmlldyA/IFwicHVycGxlLjQwMFwiIDogXCJncmF5LjQwMFwifVxuICAgICAgICAgICAgYm9yZGVyUmFkaXVzPVwibWRcIlxuICAgICAgICAgICAgcHg9ezN9XG4gICAgICAgICAgICBweT17MS41fVxuICAgICAgICAgICAgaGVpZ2h0PVwiYXV0b1wiXG4gICAgICAgICAgICBmb250RmFtaWx5PVwibW9ub1wiXG4gICAgICAgICAgICBmb250V2VpZ2h0PXtzaG93UHJldmlldyA/IFwiYm9sZFwiIDogXCJtZWRpdW1cIn1cbiAgICAgICAgICAgIGxldHRlclNwYWNpbmc9XCJ0aWdodFwiXG4gICAgICAgICAgICBib3JkZXJXaWR0aD17c2hvd1ByZXZpZXcgPyAxIDogMH1cbiAgICAgICAgICAgIGJvcmRlckNvbG9yPXtzaG93UHJldmlldyA/IFwicHVycGxlLjgwMFwiIDogXCJ0cmFuc3BhcmVudFwifVxuICAgICAgICAgICAgX2hvdmVyPXt7XG4gICAgICAgICAgICAgIGJnOiBcImxpbmVhci1ncmFkaWVudCgxMzVkZWcsIHJnYmEoMTI4LDkwLDIxMywwLjMpLCByZ2JhKDEyOCw5MCwyMTMsMC4xNSkpXCIsXG4gICAgICAgICAgICAgIGNvbG9yOiBcInB1cnBsZS40MDBcIixcbiAgICAgICAgICAgICAgdHJhbnNmb3JtOiBcInRyYW5zbGF0ZVkoLTFweClcIixcbiAgICAgICAgICAgICAgYm94U2hhZG93OiBcIjAgNHB4IDhweCByZ2JhKDAsMCwwLDAuMylcIixcbiAgICAgICAgICAgIH19XG4gICAgICAgICAgICBfYWN0aXZlPXt7XG4gICAgICAgICAgICAgIGJnOiBcImJsYWNrQWxwaGEuNTAwXCIsXG4gICAgICAgICAgICAgIHRyYW5zZm9ybTogXCJ0cmFuc2xhdGVZKDApXCIsXG4gICAgICAgICAgICB9fVxuICAgICAgICAgICAgX2ZvY3VzPXt7IG91dGxpbmU6IFwibm9uZVwiIH19XG4gICAgICAgICAgICBfZm9jdXNWaXNpYmxlPXt7IG91dGxpbmU6IFwibm9uZVwiIH19XG4gICAgICAgICAgICB0cmFuc2l0aW9uPVwiYWxsIDAuMnMgY3ViaWMtYmV6aWVyKDAuNCwgMCwgMC4yLCAxKVwiXG4gICAgICAgICAgICBtcj17MX1cbiAgICAgICAgICAgIGFyaWEtbGFiZWw9XCLjg5fjg6zjg5Pjg6Xjg7zooajnpLrliIfjgormm7/jgYhcIlxuICAgICAgICAgICAgYXJpYS1wcmVzc2VkPXtzaG93UHJldmlld31cbiAgICAgICAgICA+XG4gICAgICAgICAgICBQcmV2aWV3XG4gICAgICAgICAgPC9CdXR0b24+XG4gICAgICAgICAgeyhbXCJodG1sXCIsIFwiY3NzXCIsIFwianNcIl0gYXMgY29uc3QpLm1hcCgobSkgPT4gKFxuICAgICAgICAgICAgPEJ1dHRvblxuICAgICAgICAgICAgICBrZXk9e219XG4gICAgICAgICAgICAgIG9uQ2xpY2s9eygpID0+IGhhbmRsZU1vZGVDaGFuZ2UobSl9XG4gICAgICAgICAgICAgIGNvbG9yU2NoZW1lPXttb2RlID09PSBtID8gXCJvcmFuZ2VcIiA6IFwiZ3JheVwifVxuICAgICAgICAgICAgICBiZz17XG4gICAgICAgICAgICAgICAgbW9kZSA9PT0gbVxuICAgICAgICAgICAgICAgICAgPyBcImxpbmVhci1ncmFkaWVudCgxMzVkZWcsIHJnYmEoMjU1LDE1MiwwLDAuMiksIHJnYmEoMjU1LDE1MiwwLDAuMSkpXCJcbiAgICAgICAgICAgICAgICAgIDogXCJ0cmFuc3BhcmVudFwiXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY29sb3I9e21vZGUgPT09IG0gPyBcInNlY29uZGFyeS40MDBcIiA6IFwiZ3JheS40MDBcIn1cbiAgICAgICAgICAgICAgYm9yZGVyUmFkaXVzPVwibWRcIlxuICAgICAgICAgICAgICBweD17M31cbiAgICAgICAgICAgICAgcHk9ezEuNX1cbiAgICAgICAgICAgICAgaGVpZ2h0PVwiYXV0b1wiXG4gICAgICAgICAgICAgIGZvbnRGYW1pbHk9XCJtb25vXCJcbiAgICAgICAgICAgICAgZm9udFdlaWdodD17bW9kZSA9PT0gbSA/IFwiYm9sZFwiIDogXCJtZWRpdW1cIn1cbiAgICAgICAgICAgICAgbGV0dGVyU3BhY2luZz1cInRpZ2h0XCJcbiAgICAgICAgICAgICAgYm9yZGVyV2lkdGg9e21vZGUgPT09IG0gPyAxIDogMH1cbiAgICAgICAgICAgICAgYm9yZGVyQ29sb3I9e21vZGUgPT09IG0gPyBcInNlY29uZGFyeS44MDBcIiA6IFwidHJhbnNwYXJlbnRcIn1cbiAgICAgICAgICAgICAgX2hvdmVyPXt7XG4gICAgICAgICAgICAgICAgYmc6XG4gICAgICAgICAgICAgICAgICBtb2RlID09PSBtXG4gICAgICAgICAgICAgICAgICAgID8gXCJsaW5lYXItZ3JhZGllbnQoMTM1ZGVnLCByZ2JhKDI1NSwxNTIsMCwwLjMpLCByZ2JhKDI1NSwxNTIsMCwwLjE1KSlcIlxuICAgICAgICAgICAgICAgICAgICA6IFwiYmxhY2tBbHBoYS4zMDBcIixcbiAgICAgICAgICAgICAgICBjb2xvcjogXCJzZWNvbmRhcnkuNDAwXCIsXG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtOiBcInRyYW5zbGF0ZVkoLTFweClcIixcbiAgICAgICAgICAgICAgICBib3hTaGFkb3c6IFwiMCA0cHggOHB4IHJnYmEoMCwwLDAsMC4zKVwiLFxuICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgICBfYWN0aXZlPXt7XG4gICAgICAgICAgICAgICAgYmc6IFwiYmxhY2tBbHBoYS41MDBcIixcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm06IFwidHJhbnNsYXRlWSgwKVwiLFxuICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgICBfZm9jdXM9e3tcbiAgICAgICAgICAgICAgICBvdXRsaW5lOiBcIm5vbmVcIixcbiAgICAgICAgICAgICAgICBib3hTaGFkb3c6IFwibm9uZVwiLFxuICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgICBfZm9jdXNWaXNpYmxlPXt7XG4gICAgICAgICAgICAgICAgb3V0bGluZTogXCIycHggc29saWRcIixcbiAgICAgICAgICAgICAgICBvdXRsaW5lQ29sb3I6IFwic2Vjb25kYXJ5LjQwMFwiLFxuICAgICAgICAgICAgICAgIG91dGxpbmVPZmZzZXQ6IFwiMnB4XCIsXG4gICAgICAgICAgICAgICAgYm94U2hhZG93OiBcIjAgMCAwIDJweCByZ2JhKDI1NSwxNTIsMCwwLjMpXCIsXG4gICAgICAgICAgICAgICAgYm9yZGVyQ29sb3I6IG1vZGUgPT09IG0gPyBcInNlY29uZGFyeS44MDBcIiA6IFwidHJhbnNwYXJlbnRcIixcbiAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgICAgdHJhbnNpdGlvbj1cImFsbCAwLjJzIGN1YmljLWJlemllcigwLjQsIDAsIDAuMiwgMSlcIlxuICAgICAgICAgICAgICBtcj17MX1cbiAgICAgICAgICAgICAgYXJpYS1sYWJlbD17YCR7bS50b1VwcGVyQ2FzZSgpfeOCqOODh+OCo+OCv+ODvOODouODvOODieOBq+WIh+OCiuabv+OBiGB9XG4gICAgICAgICAgICAgIGFyaWEtcHJlc3NlZD17bW9kZSA9PT0gbX1cbiAgICAgICAgICAgID5cbiAgICAgICAgICAgICAge20udG9VcHBlckNhc2UoKX1cbiAgICAgICAgICAgIDwvQnV0dG9uPlxuICAgICAgICAgICkpfVxuICAgICAgICAgIDxCdXR0b25cbiAgICAgICAgICAgIG9uQ2xpY2s9e2hhbmRsZVJlc2V0fVxuICAgICAgICAgICAgY29sb3JTY2hlbWU9XCJncmF5XCJcbiAgICAgICAgICAgIGJnPVwidHJhbnNwYXJlbnRcIlxuICAgICAgICAgICAgY29sb3I9XCJncmF5LjQwMFwiXG4gICAgICAgICAgICBib3JkZXJSYWRpdXM9XCJtZFwiXG4gICAgICAgICAgICBweD17M31cbiAgICAgICAgICAgIHB5PXsxLjV9XG4gICAgICAgICAgICBoZWlnaHQ9XCJhdXRvXCJcbiAgICAgICAgICAgIGZvbnRGYW1pbHk9XCJtb25vXCJcbiAgICAgICAgICAgIGZvbnRXZWlnaHQ9XCJtZWRpdW1cIlxuICAgICAgICAgICAgbGV0dGVyU3BhY2luZz1cInRpZ2h0XCJcbiAgICAgICAgICAgIGJvcmRlcldpZHRoPXswfVxuICAgICAgICAgICAgX2hvdmVyPXt7XG4gICAgICAgICAgICAgIGJnOiBcImxpbmVhci1ncmFkaWVudCgxMzVkZWcsIHJnYmEoMTI4LDkwLDIxMywwLjIpLCByZ2JhKDEyOCw5MCwyMTMsMC4xKSlcIixcbiAgICAgICAgICAgICAgY29sb3I6IFwicHVycGxlLjQwMFwiLFxuICAgICAgICAgICAgICB0cmFuc2Zvcm06IFwidHJhbnNsYXRlWSgtMXB4KVwiLFxuICAgICAgICAgICAgICBib3hTaGFkb3c6IFwiMCA0cHggOHB4IHJnYmEoMCwwLDAsMC4zKVwiLFxuICAgICAgICAgICAgfX1cbiAgICAgICAgICAgIF9hY3RpdmU9e3tcbiAgICAgICAgICAgICAgYmc6IFwiYmxhY2tBbHBoYS41MDBcIixcbiAgICAgICAgICAgICAgdHJhbnNmb3JtOiBcInRyYW5zbGF0ZVkoMClcIixcbiAgICAgICAgICAgIH19XG4gICAgICAgICAgICBfZm9jdXM9e3sgb3V0bGluZTogXCJub25lXCIgfX1cbiAgICAgICAgICAgIF9mb2N1c1Zpc2libGU9e3sgb3V0bGluZTogXCJub25lXCIgfX1cbiAgICAgICAgICAgIHRyYW5zaXRpb249XCJhbGwgMC4ycyBjdWJpYy1iZXppZXIoMC40LCAwLCAwLjIsIDEpXCJcbiAgICAgICAgICAgIG1sPXsyfVxuICAgICAgICAgICAgYXJpYS1sYWJlbD1cIuOCqOODh+OCo+OCv+ODvOOBruWGheWuueOCkuODquOCu+ODg+ODiFwiXG4gICAgICAgICAgPlxuICAgICAgICAgICAgPEljb24gYXM9e0ZpUmVmcmVzaEN3fSBtcj17MX0gLz4gUmVzZXRcbiAgICAgICAgICA8L0J1dHRvbj5cbiAgICAgICAgPC9IU3RhY2s+XG4gICAgICA8L01vdGlvbkZsZXg+XG4gICAgICB7LyogLS0tIFZpbeODouODvOODieihqOekuuOCueODhuODvOOCv+OCueODkOODvCAtLS0gKi99XG4gICAgICA8TW90aW9uRmxleFxuICAgICAgICBwb3NpdGlvbj1cImFic29sdXRlXCJcbiAgICAgICAgYm90dG9tPXswfVxuICAgICAgICBsZWZ0PXswfVxuICAgICAgICByaWdodD17MH1cbiAgICAgICAgcHg9ezR9XG4gICAgICAgIHB5PXsxLjV9XG4gICAgICAgIGJnPVwibGluZWFyLWdyYWRpZW50KDEzNWRlZywgcmdiYSgwLDAsMCwwLjgpLCByZ2JhKDAsMCwwLDAuNikpXCJcbiAgICAgICAgYm9yZGVyVG9wV2lkdGg9ezF9XG4gICAgICAgIGJvcmRlckNvbG9yPVwicHJpbWFyeS43MDBcIlxuICAgICAgICB6SW5kZXg9ezV9XG4gICAgICAgIGZvbnRTaXplPVwic21cIlxuICAgICAgICBmb250RmFtaWx5PVwibW9ub1wiXG4gICAgICAgIGp1c3RpZnlDb250ZW50PVwic3BhY2UtYmV0d2VlblwiXG4gICAgICAgIGFsaWduSXRlbXM9XCJjZW50ZXJcIlxuICAgICAgICBiYWNrZHJvcEZpbHRlcj1cImJsdXIoMTBweClcIlxuICAgICAgICBfYmVmb3JlPXt7XG4gICAgICAgICAgY29udGVudDogJ1wiXCInLFxuICAgICAgICAgIHBvc2l0aW9uOiBcImFic29sdXRlXCIsXG4gICAgICAgICAgdG9wOiAwLFxuICAgICAgICAgIGxlZnQ6IDAsXG4gICAgICAgICAgcmlnaHQ6IDAsXG4gICAgICAgICAgaGVpZ2h0OiBcIjFweFwiLFxuICAgICAgICAgIGJhY2tncm91bmQ6IGBsaW5lYXItZ3JhZGllbnQoOTBkZWcsIHRyYW5zcGFyZW50LCAke21vZGVJbmZvW3ZpbU1vZGVdLmNvbG9yfSwgdHJhbnNwYXJlbnQpYCxcbiAgICAgICAgICBvcGFjaXR5OiAwLjYsXG4gICAgICAgIH19XG4gICAgICA+XG4gICAgICAgIDxBbmltYXRlUHJlc2VuY2UgbW9kZT1cIndhaXRcIj5cbiAgICAgICAgICA8TW90aW9uRmxleFxuICAgICAgICAgICAgYWxpZ25JdGVtcz1cImNlbnRlclwiXG4gICAgICAgICAgICBrZXk9e3ZpbU1vZGV9XG4gICAgICAgICAgICB2YXJpYW50cz17bW9kZUluZGljYXRvclZhcmlhbnRzfVxuICAgICAgICAgICAgaW5pdGlhbD1cImhpZGRlblwiXG4gICAgICAgICAgICBhbmltYXRlPVwidmlzaWJsZVwiXG4gICAgICAgICAgICBleGl0PVwiZXhpdFwiXG4gICAgICAgICAgPlxuICAgICAgICAgICAgPEljb25cbiAgICAgICAgICAgICAgYXM9e21vZGVJbmZvW3ZpbU1vZGVdLmljb259XG4gICAgICAgICAgICAgIGNvbG9yPXttb2RlSW5mb1t2aW1Nb2RlXS5jb2xvcn1cbiAgICAgICAgICAgICAgbXI9ezJ9XG4gICAgICAgICAgICAvPlxuICAgICAgICAgICAgPE1vdGlvblRleHRcbiAgICAgICAgICAgICAgY29sb3I9e21vZGVJbmZvW3ZpbU1vZGVdLmNvbG9yfVxuICAgICAgICAgICAgICBmb250V2VpZ2h0PVwibWVkaXVtXCJcbiAgICAgICAgICAgICAgZm9udFNpemU9XCJzbVwiXG4gICAgICAgICAgICAgIHRleHRTaGFkb3c9e2AwIDAgOHB4ICR7bW9kZUluZm9bdmltTW9kZV0uY29sb3J9NDBgfVxuICAgICAgICAgICAgPlxuICAgICAgICAgICAgICB7bW9kZUluZm9bdmltTW9kZV0udGV4dH1cbiAgICAgICAgICAgIDwvTW90aW9uVGV4dD5cbiAgICAgICAgICA8L01vdGlvbkZsZXg+XG4gICAgICAgIDwvQW5pbWF0ZVByZXNlbmNlPlxuICAgICAgICA8VGV4dCBjb2xvcj1cImdyYXkuNTAwXCIgZm9udFNpemU9XCJ4c1wiPlxuICAgICAgICAgIHttb2RlSW5mb1t2aW1Nb2RlXS5oaW50fVxuICAgICAgICA8L1RleHQ+XG4gICAgICA8L01vdGlvbkZsZXg+XG4gICAgICB7LyogLS0tIEVkaXRvcuacrOS9k+OCqOODquOCoiBvciDjg5fjg6zjg5Pjg6Xjg7wgLS0tICovfVxuICAgICAgPEJveFxuICAgICAgICBmbGV4PXsxfVxuICAgICAgICBtaW5IZWlnaHQ9ezB9XG4gICAgICAgIGJvcmRlclJhZGl1cz1cImxnXCJcbiAgICAgICAgb3ZlcmZsb3c9XCJoaWRkZW5cIlxuICAgICAgICB3aWR0aD1cIjEwMCVcIlxuICAgICAgICBkaXNwbGF5PVwiZmxleFwiXG4gICAgICAgIHBvc2l0aW9uPVwicmVsYXRpdmVcIlxuICAgICAgICBtYj17OH1cbiAgICAgICAgaGVpZ2h0PVwiMTAwJVwiXG4gICAgICAgIG1heEg9XCIxMDAlXCJcbiAgICAgID5cbiAgICAgICAgey8qIFNTUi9DU1Llt67nlbDjgavjgojjgovpq5jjgZUw5ZWP6aGM44KS6Ziy44GQ44Gf44KB44CB44Oe44Km44Oz44OI5b6M44Gu44G/5o+P55S7ICovfVxuICAgICAgICB7IXNob3dQcmV2aWV3ICYmIChcbiAgICAgICAgICA8Qm94XG4gICAgICAgICAgICB3PVwiMTAwJVwiXG4gICAgICAgICAgICBoPVwiMTAwJVwiXG4gICAgICAgICAgICBtYXhIPXt7IGJhc2U6IFwiMzQwcHhcIiwgbWQ6IFwiNDgwcHhcIiwgbGc6IFwiNTYwcHhcIiB9fVxuICAgICAgICAgICAgbWluSD17eyBiYXNlOiBcIjIyMHB4XCIsIG1kOiBcIjMyMHB4XCIgfX1cbiAgICAgICAgICAgIG92ZXJmbG93WT1cImF1dG9cIlxuICAgICAgICAgICAgYm9yZGVyUmFkaXVzPVwibWRcIlxuICAgICAgICAgICAgYmc9XCJ0cmFuc3BhcmVudFwiXG4gICAgICAgICAgICBib3hTaGFkb3c9XCJub25lXCJcbiAgICAgICAgICAgIHN0eWxlPXt7XG4gICAgICAgICAgICAgIGhlaWdodDogXCIxMDAlXCIsXG4gICAgICAgICAgICAgIGZvbnRTaXplOiBcIjE2cHhcIixcbiAgICAgICAgICAgICAgb3V0bGluZTogXCJub25lXCIsXG4gICAgICAgICAgICB9fVxuICAgICAgICAgID5cbiAgICAgICAgICAgIDxDb2RlTWlycm9yXG4gICAgICAgICAgICAgIHZhbHVlPXtjb2RlfVxuICAgICAgICAgICAgICBoZWlnaHQ9XCIxMDAlXCJcbiAgICAgICAgICAgICAgZXh0ZW5zaW9ucz17Z2V0RXh0ZW5zaW9ucygpfVxuICAgICAgICAgICAgICB0aGVtZT17b25lRGFya31cbiAgICAgICAgICAgICAgb25DaGFuZ2U9e29uQ2hhbmdlfVxuICAgICAgICAgICAgICBvblVwZGF0ZT17b25VcGRhdGV9XG4gICAgICAgICAgICAgIHN0eWxlPXt7IGZvbnRTaXplOiBcIjE2cHhcIiwgYmFja2dyb3VuZDogXCJ0cmFuc3BhcmVudFwiIH19XG4gICAgICAgICAgICAvPlxuICAgICAgICAgIDwvQm94PlxuICAgICAgICApfVxuICB7c2hvd1ByZXZpZXcgJiYgKFxuICAgICAgICAgIDxCb3hcbiAgICAgICAgICAgIHc9XCIxMDAlXCJcbiAgICAgICAgICAgIGg9XCIxMDAlXCJcbiAgICAgICAgICAgIG1heEg9e3sgYmFzZTogXCIzNDBweFwiLCBtZDogXCI0ODBweFwiLCBsZzogXCI1NjBweFwiIH19XG4gICAgICAgICAgICBtaW5IPXt7IGJhc2U6IFwiMjIwcHhcIiwgbWQ6IFwiMzIwcHhcIiB9fVxuICAgICAgICAgICAgb3ZlcmZsb3dZPVwiYXV0b1wiXG4gICAgICAgICAgICBib3JkZXJSYWRpdXM9XCJtZFwiXG4gICAgICAgICAgICBiZz1cIndoaXRlXCJcbiAgICAgICAgICAgIGJveFNoYWRvdz1cIm1kXCJcbiAgICAgICAgICAgIHBvc2l0aW9uPVwicmVsYXRpdmVcIlxuICAgICAgICAgID5cbiAgICAgICAgICAgIDxpZnJhbWVcbiAgICAgICAgICAgICAgdGl0bGU9XCJQcmV2aWV3XCJcbiAgICAgICAgICAgICAgc3JjRG9jPXtwcmV2aWV3U3JjRG9jfVxuICAgICAgICAgICAgICBzdHlsZT17e1xuICAgICAgICAgICAgICAgIHdpZHRoOiBcIjEwMCVcIixcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IFwiMTAwJVwiLFxuICAgICAgICAgICAgICAgIGJvcmRlcjogXCJub25lXCIsXG4gICAgICAgICAgICAgICAgYmFja2dyb3VuZDogXCJ3aGl0ZVwiLFxuICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgICBzYW5kYm94PVwiYWxsb3ctc2NyaXB0cyBhbGxvdy1zYW1lLW9yaWdpblwiXG4gICAgICAgICAgICAvPlxuICAgICAgICAgIDwvQm94PlxuICAgICAgICApfVxuICAgICAgPC9Cb3g+XG4gICAgPC9Nb3Rpb25Cb3g+XG4gICk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IFZpbUVkaXRvcjtcbiJdLCJuYW1lcyI6WyJodG1sU2FtcGxlIiwiY3NzU2FtcGxlIiwianNTYW1wbGUiLCJ2aW1UaXBzIiwiQm94IiwiQnV0dG9uIiwiRmxleCIsIkhTdGFjayIsIkljb24iLCJUZXh0IiwiQ29kZU1pcnJvciIsImh0bWwiLCJodG1sTGFuZyIsImNzcyIsImNzc0xhbmciLCJqYXZhc2NyaXB0IiwianNMYW5nIiwib25lRGFyayIsInZpbSIsIkFuaW1hdGVQcmVzZW5jZSIsIm1vdGlvbiIsInVzZUNhbGxiYWNrIiwidXNlU3RhdGUiLCJGaUNvbW1hbmQiLCJGaUVkaXQiLCJGaVJlZnJlc2hDdyIsIkZpVGVybWluYWwiLCJNb3Rpb25Cb3giLCJNb3Rpb25GbGV4IiwiTW90aW9uVGV4dCIsIm1vZGVJbmZvIiwibm9ybWFsIiwidGV4dCIsImNvbG9yIiwiaWNvbiIsImhpbnQiLCJpbnNlcnQiLCJ2aXN1YWwiLCJWaW1FZGl0b3IiLCJtb2RlIiwic2V0TW9kZSIsInZpbU1vZGUiLCJzZXRWaW1Nb2RlIiwiY29udGFpbmVyVmFyaWFudHMiLCJoaWRkZW4iLCJvcGFjaXR5Iiwic2NhbGUiLCJ2aXNpYmxlIiwidHJhbnNpdGlvbiIsImR1cmF0aW9uIiwibW9kZUluZGljYXRvclZhcmlhbnRzIiwieCIsImV4aXQiLCJnZXRFeHRlbnNpb25zIiwic2V0SHRtbCIsInNldENzcyIsImpzIiwic2V0SnMiLCJjb2RlIiwic2V0Q29kZSIsIm9uVXBkYXRlIiwiX3ZpZXdVcGRhdGUiLCJnZXRTYW1wbGUiLCJzaG93UHJldmlldyIsInNldFNob3dQcmV2aWV3IiwiaGFuZGxlUmVzZXQiLCJoYW5kbGVNb2RlQ2hhbmdlIiwibSIsInJlcGxhY2UiLCJwcmV2aWV3U3JjRG9jIiwib25DaGFuZ2UiLCJ2YWx1ZSIsImJnR3JhZGllbnQiLCJwIiwiYmFzZSIsIm1kIiwiYm9yZGVyUmFkaXVzIiwiYm94U2hhZG93IiwiZGlzcGxheSIsImZsZXhEaXJlY3Rpb24iLCJib3JkZXJXaWR0aCIsImJvcmRlckNvbG9yIiwicG9zaXRpb24iLCJvdmVyZmxvdyIsImZsZXgiLCJtaW5IIiwibGciLCJtYXhIIiwiaCIsImluaXRpYWwiLCJhbmltYXRlIiwidmFyaWFudHMiLCJfYmVmb3JlIiwiY29udGVudCIsInRvcCIsImxlZnQiLCJyaWdodCIsImJvdHRvbSIsImJhY2tncm91bmQiLCJwb2ludGVyRXZlbnRzIiwiX2hvdmVyIiwidHJhbnNmb3JtIiwiYWxpZ25JdGVtcyIsInB4IiwicHkiLCJib3JkZXJCb3R0b21XaWR0aCIsImp1c3RpZnlDb250ZW50IiwiZ2FwIiwibWFyZ2luUmlnaHQiLCJ3IiwiYmciLCJhcyIsIm1yIiwiZm9udEZhbWlseSIsImZvbnRXZWlnaHQiLCJsZXR0ZXJTcGFjaW5nIiwieSIsInRvVXBwZXJDYXNlIiwib25DbGljayIsInByZXYiLCJjb2xvclNjaGVtZSIsImhlaWdodCIsIl9hY3RpdmUiLCJfZm9jdXMiLCJvdXRsaW5lIiwiX2ZvY3VzVmlzaWJsZSIsImFyaWEtbGFiZWwiLCJhcmlhLXByZXNzZWQiLCJtYXAiLCJvdXRsaW5lQ29sb3IiLCJvdXRsaW5lT2Zmc2V0IiwibWwiLCJib3JkZXJUb3BXaWR0aCIsInpJbmRleCIsImZvbnRTaXplIiwiYmFja2Ryb3BGaWx0ZXIiLCJ0ZXh0U2hhZG93IiwibWluSGVpZ2h0Iiwid2lkdGgiLCJtYiIsIm92ZXJmbG93WSIsInN0eWxlIiwiZXh0ZW5zaW9ucyIsInRoZW1lIiwiaWZyYW1lIiwidGl0bGUiLCJzcmNEb2MiLCJib3JkZXIiLCJzYW5kYm94Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/VimEditor.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@replit/codemirror-vim/dist/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/@replit/codemirror-vim/dist/index.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CodeMirror: function() { return /* binding */ CodeMirror; },\n/* harmony export */   Vim: function() { return /* binding */ Vim; },\n/* harmony export */   getCM: function() { return /* binding */ getCM; },\n/* harmony export */   vim: function() { return /* binding */ vim; }\n/* harmony export */ });\n/* harmony import */ var _codemirror_state__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @codemirror/state */ \"(app-pages-browser)/./node_modules/@codemirror/state/dist/index.js\");\n/* harmony import */ var _codemirror_language__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @codemirror/language */ \"(app-pages-browser)/./node_modules/@codemirror/language/dist/index.js\");\n/* harmony import */ var _codemirror_view__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @codemirror/view */ \"(app-pages-browser)/./node_modules/@codemirror/view/dist/index.js\");\n/* harmony import */ var _codemirror_search__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @codemirror/search */ \"(app-pages-browser)/./node_modules/@codemirror/search/dist/index.js\");\n/* harmony import */ var _codemirror_commands__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @codemirror/commands */ \"(app-pages-browser)/./node_modules/@codemirror/commands/dist/index.js\");\n\n\n\n\n\n\n\n//@ts-check\n\n// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/5/LICENSE\n\n/**\n * Supported keybindings:\n *   Too many to list. Refer to defaultKeymap below.\n *\n * Supported Ex commands:\n *   Refer to defaultExCommandMap below.\n *\n * Registers: unnamed, -, ., :, /, _, a-z, A-Z, 0-9\n *   (Does not respect the special case for number registers when delete\n *    operator is made with these commands: %, (, ),  , /, ?, n, N, {, } )\n *   TODO: Implement the remaining registers.\n *\n * Marks: a-z, A-Z, and 0-9\n *   TODO: Implement the remaining special marks. They have more complex\n *       behavior.\n *\n * Events:\n *  'vim-mode-change' - raised on the editor anytime the current mode changes,\n *                      Event object: {mode: \"visual\", subMode: \"linewise\"}\n *\n * Code structure:\n *  1. Default keymap\n *  2. Variable declarations and short basic helpers\n *  3. Instance (External API) implementation\n *  4. Internal state tracking objects (input state, counter) implementation\n *     and instantiation\n *  5. Key handler (the main command dispatcher) implementation\n *  6. Motion, operator, and action implementations\n *  7. Helper functions for the key handler, motions, operators, and actions\n *  8. Set up Vim to work as a keymap for CodeMirror.\n *  9. Ex command implementations.\n */\n\n\n/** @arg {typeof import(\"./cm_adapter\").CodeMirror} CM */\nfunction initVim(CM) {\n\n/**\n * @typedef { import(\"./cm_adapter\").CodeMirror } CodeMirror\n * @typedef { import(\"./types\").CodeMirrorV} CodeMirrorV\n * @typedef { import(\"./types\").Pos } Pos\n * @typedef { import(\"./types\").vimState } vimState \n * @typedef { import(\"./types\").ExFn } ExFn\n * @typedef { import(\"./types\").MotionArgs } MotionArgs\n * @typedef { import(\"./types\").ActionArgs } ActionArgs\n * @typedef { import(\"./types\").OperatorArgs } OperatorArgs\n * @typedef { import(\"./types\").vimKey } vimKey\n * @typedef { import(\"./types\").Marker } Marker\n * @typedef { import(\"./types\").InputStateInterface } InputStateInterface\n * @typedef { import(\"./types\").SearchStateInterface } SearchStateInterface\n * @typedef { import(\"./types\").InsertModeChanges } InsertModeChanges\n */\n  var Pos = CM.Pos;\n\n  /** @arg {CodeMirror} cm @arg {Pos} curStart @arg {Pos} curEnd */\n  function updateSelectionForSurrogateCharacters(cm, curStart, curEnd) {\n    // start and character position when no selection \n    // is the same in visual mode, and differs in 1 character in normal mode\n    if (curStart.line === curEnd.line && curStart.ch >= curEnd.ch - 1) {\n      var text = cm.getLine(curStart.line);\n      var charCode = text.charCodeAt(curStart.ch);\n      if (0xD800 <= charCode && charCode <= 0xD8FF) {\n        curEnd.ch += 1;\n      }\n    }\n\n    return {start: curStart, end: curEnd};\n  }\n  /** @type {import(\"./types\").vimKeyMap} */\n  var defaultKeymap = [\n    // Key to key mapping. This goes first to make it possible to override\n    // existing mappings.\n    { keys: '<Left>', type: 'keyToKey', toKeys: 'h' },\n    { keys: '<Right>', type: 'keyToKey', toKeys: 'l' },\n    { keys: '<Up>', type: 'keyToKey', toKeys: 'k' },\n    { keys: '<Down>', type: 'keyToKey', toKeys: 'j' },\n    { keys: 'g<Up>', type: 'keyToKey', toKeys: 'gk' },\n    { keys: 'g<Down>', type: 'keyToKey', toKeys: 'gj' },\n    { keys: '<Space>', type: 'keyToKey', toKeys: 'l' },\n    { keys: '<BS>', type: 'keyToKey', toKeys: 'h'},\n    { keys: '<Del>', type: 'keyToKey', toKeys: 'x' },\n    { keys: '<C-Space>', type: 'keyToKey', toKeys: 'W' },\n    { keys: '<C-BS>', type: 'keyToKey', toKeys: 'B' },\n    { keys: '<S-Space>', type: 'keyToKey', toKeys: 'w' },\n    { keys: '<S-BS>', type: 'keyToKey', toKeys: 'b' },\n    { keys: '<C-n>', type: 'keyToKey', toKeys: 'j' },\n    { keys: '<C-p>', type: 'keyToKey', toKeys: 'k' },\n    { keys: '<C-[>', type: 'keyToKey', toKeys: '<Esc>' },\n    { keys: '<C-c>', type: 'keyToKey', toKeys: '<Esc>' },\n    { keys: '<C-[>', type: 'keyToKey', toKeys: '<Esc>', context: 'insert' },\n    { keys: '<C-c>', type: 'keyToKey', toKeys: '<Esc>', context: 'insert' },\n    { keys: '<C-Esc>', type: 'keyToKey', toKeys: '<Esc>' }, // ipad keyboard sends C-Esc instead of C-[\n    { keys: '<C-Esc>', type: 'keyToKey', toKeys: '<Esc>', context: 'insert' },\n    { keys: 's', type: 'keyToKey', toKeys: 'cl', context: 'normal' },\n    { keys: 's', type: 'keyToKey', toKeys: 'c', context: 'visual'},\n    { keys: 'S', type: 'keyToKey', toKeys: 'cc', context: 'normal' },\n    { keys: 'S', type: 'keyToKey', toKeys: 'VdO', context: 'visual' },\n    { keys: '<Home>', type: 'keyToKey', toKeys: '0' },\n    { keys: '<End>', type: 'keyToKey', toKeys: '$' },\n    { keys: '<PageUp>', type: 'keyToKey', toKeys: '<C-b>' },\n    { keys: '<PageDown>', type: 'keyToKey', toKeys: '<C-f>' },\n    { keys: '<CR>', type: 'keyToKey', toKeys: 'j^', context: 'normal' },\n    { keys: '<Ins>', type: 'keyToKey', toKeys: 'i', context: 'normal'},\n    { keys: '<Ins>', type: 'action', action: 'toggleOverwrite', context: 'insert' },\n    // Motions\n    { keys: 'H', type: 'motion', motion: 'moveToTopLine', motionArgs: { linewise: true, toJumplist: true }},\n    { keys: 'M', type: 'motion', motion: 'moveToMiddleLine', motionArgs: { linewise: true, toJumplist: true }},\n    { keys: 'L', type: 'motion', motion: 'moveToBottomLine', motionArgs: { linewise: true, toJumplist: true }},\n    { keys: 'h', type: 'motion', motion: 'moveByCharacters', motionArgs: { forward: false }},\n    { keys: 'l', type: 'motion', motion: 'moveByCharacters', motionArgs: { forward: true }},\n    { keys: 'j', type: 'motion', motion: 'moveByLines', motionArgs: { forward: true, linewise: true }},\n    { keys: 'k', type: 'motion', motion: 'moveByLines', motionArgs: { forward: false, linewise: true }},\n    { keys: 'gj', type: 'motion', motion: 'moveByDisplayLines', motionArgs: { forward: true }},\n    { keys: 'gk', type: 'motion', motion: 'moveByDisplayLines', motionArgs: { forward: false }},\n    { keys: 'w', type: 'motion', motion: 'moveByWords', motionArgs: { forward: true, wordEnd: false }},\n    { keys: 'W', type: 'motion', motion: 'moveByWords', motionArgs: { forward: true, wordEnd: false, bigWord: true }},\n    { keys: 'e', type: 'motion', motion: 'moveByWords', motionArgs: { forward: true, wordEnd: true, inclusive: true }},\n    { keys: 'E', type: 'motion', motion: 'moveByWords', motionArgs: { forward: true, wordEnd: true, bigWord: true, inclusive: true }},\n    { keys: 'b', type: 'motion', motion: 'moveByWords', motionArgs: { forward: false, wordEnd: false }},\n    { keys: 'B', type: 'motion', motion: 'moveByWords', motionArgs: { forward: false, wordEnd: false, bigWord: true }},\n    { keys: 'ge', type: 'motion', motion: 'moveByWords', motionArgs: { forward: false, wordEnd: true, inclusive: true }},\n    { keys: 'gE', type: 'motion', motion: 'moveByWords', motionArgs: { forward: false, wordEnd: true, bigWord: true, inclusive: true }},\n    { keys: '{', type: 'motion', motion: 'moveByParagraph', motionArgs: { forward: false, toJumplist: true }},\n    { keys: '}', type: 'motion', motion: 'moveByParagraph', motionArgs: { forward: true, toJumplist: true }},\n    { keys: '(', type: 'motion', motion: 'moveBySentence', motionArgs: { forward: false }},\n    { keys: ')', type: 'motion', motion: 'moveBySentence', motionArgs: { forward: true }},\n    { keys: '<C-f>', type: 'motion', motion: 'moveByPage', motionArgs: { forward: true }},\n    { keys: '<C-b>', type: 'motion', motion: 'moveByPage', motionArgs: { forward: false }},\n    { keys: '<C-d>', type: 'motion', motion: 'moveByScroll', motionArgs: { forward: true, explicitRepeat: true }},\n    { keys: '<C-u>', type: 'motion', motion: 'moveByScroll', motionArgs: { forward: false, explicitRepeat: true }},\n    { keys: 'gg', type: 'motion', motion: 'moveToLineOrEdgeOfDocument', motionArgs: { forward: false, explicitRepeat: true, linewise: true, toJumplist: true }},\n    { keys: 'G', type: 'motion', motion: 'moveToLineOrEdgeOfDocument', motionArgs: { forward: true, explicitRepeat: true, linewise: true, toJumplist: true }},\n    { keys: \"g$\", type: \"motion\", motion: \"moveToEndOfDisplayLine\" },\n    { keys: \"g^\", type: \"motion\", motion: \"moveToStartOfDisplayLine\" },\n    { keys: \"g0\", type: \"motion\", motion: \"moveToStartOfDisplayLine\" },\n    { keys: '0', type: 'motion', motion: 'moveToStartOfLine' },\n    { keys: '^', type: 'motion', motion: 'moveToFirstNonWhiteSpaceCharacter' },\n    { keys: '+', type: 'motion', motion: 'moveByLines', motionArgs: { forward: true, toFirstChar:true }},\n    { keys: '-', type: 'motion', motion: 'moveByLines', motionArgs: { forward: false, toFirstChar:true }},\n    { keys: '_', type: 'motion', motion: 'moveByLines', motionArgs: { forward: true, toFirstChar:true, repeatOffset:-1 }},\n    { keys: '$', type: 'motion', motion: 'moveToEol', motionArgs: { inclusive: true }},\n    { keys: '%', type: 'motion', motion: 'moveToMatchedSymbol', motionArgs: { inclusive: true, toJumplist: true }},\n    { keys: 'f<character>', type: 'motion', motion: 'moveToCharacter', motionArgs: { forward: true , inclusive: true }},\n    { keys: 'F<character>', type: 'motion', motion: 'moveToCharacter', motionArgs: { forward: false }},\n    { keys: 't<character>', type: 'motion', motion: 'moveTillCharacter', motionArgs: { forward: true, inclusive: true }},\n    { keys: 'T<character>', type: 'motion', motion: 'moveTillCharacter', motionArgs: { forward: false }},\n    { keys: ';', type: 'motion', motion: 'repeatLastCharacterSearch', motionArgs: { forward: true }},\n    { keys: ',', type: 'motion', motion: 'repeatLastCharacterSearch', motionArgs: { forward: false }},\n    { keys: '\\'<register>', type: 'motion', motion: 'goToMark', motionArgs: {toJumplist: true, linewise: true}},\n    { keys: '`<register>', type: 'motion', motion: 'goToMark', motionArgs: {toJumplist: true}},\n    { keys: ']`', type: 'motion', motion: 'jumpToMark', motionArgs: { forward: true } },\n    { keys: '[`', type: 'motion', motion: 'jumpToMark', motionArgs: { forward: false } },\n    { keys: ']\\'', type: 'motion', motion: 'jumpToMark', motionArgs: { forward: true, linewise: true } },\n    { keys: '[\\'', type: 'motion', motion: 'jumpToMark', motionArgs: { forward: false, linewise: true } },\n    // the next two aren't motions but must come before more general motion declarations\n    { keys: ']p', type: 'action', action: 'paste', isEdit: true, actionArgs: { after: true, isEdit: true, matchIndent: true}},\n    { keys: '[p', type: 'action', action: 'paste', isEdit: true, actionArgs: { after: false, isEdit: true, matchIndent: true}},\n    { keys: ']<character>', type: 'motion', motion: 'moveToSymbol', motionArgs: { forward: true, toJumplist: true}},\n    { keys: '[<character>', type: 'motion', motion: 'moveToSymbol', motionArgs: { forward: false, toJumplist: true}},\n    { keys: '|', type: 'motion', motion: 'moveToColumn'},\n    { keys: 'o', type: 'motion', motion: 'moveToOtherHighlightedEnd', context:'visual'},\n    { keys: 'O', type: 'motion', motion: 'moveToOtherHighlightedEnd', motionArgs: {sameLine: true}, context:'visual'},\n    // Operators\n    { keys: 'd', type: 'operator', operator: 'delete' },\n    { keys: 'y', type: 'operator', operator: 'yank' },\n    { keys: 'c', type: 'operator', operator: 'change' },\n    { keys: '=', type: 'operator', operator: 'indentAuto' },\n    { keys: '>', type: 'operator', operator: 'indent', operatorArgs: { indentRight: true }},\n    { keys: '<', type: 'operator', operator: 'indent', operatorArgs: { indentRight: false }},\n    { keys: 'g~', type: 'operator', operator: 'changeCase' },\n    { keys: 'gu', type: 'operator', operator: 'changeCase', operatorArgs: {toLower: true}, isEdit: true },\n    { keys: 'gU', type: 'operator', operator: 'changeCase', operatorArgs: {toLower: false}, isEdit: true },\n    { keys: 'n', type: 'motion', motion: 'findNext', motionArgs: { forward: true, toJumplist: true }},\n    { keys: 'N', type: 'motion', motion: 'findNext', motionArgs: { forward: false, toJumplist: true }},\n    { keys: 'gn', type: 'motion', motion: 'findAndSelectNextInclusive', motionArgs: { forward: true }},\n    { keys: 'gN', type: 'motion', motion: 'findAndSelectNextInclusive', motionArgs: { forward: false }},\n    { keys: 'gq', type: 'operator', operator: 'hardWrap' },\n    { keys: 'gw', type: 'operator', operator: 'hardWrap', operatorArgs: {keepCursor: true}},\n    { keys: 'g?', type: 'operator', operator: 'rot13'},\n    // Operator-Motion dual commands\n    { keys: 'x', type: 'operatorMotion', operator: 'delete', motion: 'moveByCharacters', motionArgs: { forward: true }, operatorMotionArgs: { visualLine: false }},\n    { keys: 'X', type: 'operatorMotion', operator: 'delete', motion: 'moveByCharacters', motionArgs: { forward: false }, operatorMotionArgs: { visualLine: true }},\n    { keys: 'D', type: 'operatorMotion', operator: 'delete', motion: 'moveToEol', motionArgs: { inclusive: true }, context: 'normal'},\n    { keys: 'D', type: 'operator', operator: 'delete', operatorArgs: { linewise: true }, context: 'visual'},\n    { keys: 'Y', type: 'operatorMotion', operator: 'yank', motion: 'expandToLine', motionArgs: { linewise: true }, context: 'normal'},\n    { keys: 'Y', type: 'operator', operator: 'yank', operatorArgs: { linewise: true }, context: 'visual'},\n    { keys: 'C', type: 'operatorMotion', operator: 'change', motion: 'moveToEol', motionArgs: { inclusive: true }, context: 'normal'},\n    { keys: 'C', type: 'operator', operator: 'change', operatorArgs: { linewise: true }, context: 'visual'},\n    { keys: '~', type: 'operatorMotion', operator: 'changeCase', motion: 'moveByCharacters', motionArgs: { forward: true }, operatorArgs: { shouldMoveCursor: true }, context: 'normal'},\n    { keys: '~', type: 'operator', operator: 'changeCase', context: 'visual'},\n    { keys: '<C-u>', type: 'operatorMotion', operator: 'delete', motion: 'moveToStartOfLine', context: 'insert' },\n    { keys: '<C-w>', type: 'operatorMotion', operator: 'delete', motion: 'moveByWords', motionArgs: { forward: false, wordEnd: false }, context: 'insert' },\n    //ignore C-w in normal mode\n    { keys: '<C-w>', type: 'idle', context: 'normal' },\n    // Actions\n    { keys: '<C-i>', type: 'action', action: 'jumpListWalk', actionArgs: { forward: true }},\n    { keys: '<C-o>', type: 'action', action: 'jumpListWalk', actionArgs: { forward: false }},\n    { keys: '<C-e>', type: 'action', action: 'scroll', actionArgs: { forward: true, linewise: true }},\n    { keys: '<C-y>', type: 'action', action: 'scroll', actionArgs: { forward: false, linewise: true }},\n    { keys: 'a', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'charAfter' }, context: 'normal' },\n    { keys: 'A', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'eol' }, context: 'normal' },\n    { keys: 'A', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'endOfSelectedArea' }, context: 'visual' },\n    { keys: 'i', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'inplace' }, context: 'normal' },\n    { keys: 'gi', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'lastEdit' }, context: 'normal' },\n    { keys: 'I', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'firstNonBlank'}, context: 'normal' },\n    { keys: 'gI', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'bol'}, context: 'normal' },\n    { keys: 'I', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'startOfSelectedArea' }, context: 'visual' },\n    { keys: 'o', type: 'action', action: 'newLineAndEnterInsertMode', isEdit: true, interlaceInsertRepeat: true, actionArgs: { after: true }, context: 'normal' },\n    { keys: 'O', type: 'action', action: 'newLineAndEnterInsertMode', isEdit: true, interlaceInsertRepeat: true, actionArgs: { after: false }, context: 'normal' },\n    { keys: 'v', type: 'action', action: 'toggleVisualMode' },\n    { keys: 'V', type: 'action', action: 'toggleVisualMode', actionArgs: { linewise: true }},\n    { keys: '<C-v>', type: 'action', action: 'toggleVisualMode', actionArgs: { blockwise: true }},\n    { keys: '<C-q>', type: 'action', action: 'toggleVisualMode', actionArgs: { blockwise: true }},\n    { keys: 'gv', type: 'action', action: 'reselectLastSelection' },\n    { keys: 'J', type: 'action', action: 'joinLines', isEdit: true },\n    { keys: 'gJ', type: 'action', action: 'joinLines', actionArgs: { keepSpaces: true }, isEdit: true },\n    { keys: 'p', type: 'action', action: 'paste', isEdit: true, actionArgs: { after: true, isEdit: true }},\n    { keys: 'P', type: 'action', action: 'paste', isEdit: true, actionArgs: { after: false, isEdit: true }},\n    { keys: 'r<character>', type: 'action', action: 'replace', isEdit: true },\n    { keys: '@<register>', type: 'action', action: 'replayMacro' },\n    { keys: 'q<register>', type: 'action', action: 'enterMacroRecordMode' },\n    // Handle Replace-mode as a special case of insert mode.\n    { keys: 'R', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { replace: true }, context: 'normal'},\n    { keys: 'R', type: 'operator', operator: 'change', operatorArgs: { linewise: true, fullLine: true }, context: 'visual', exitVisualBlock: true},\n    { keys: 'u', type: 'action', action: 'undo', context: 'normal' },\n    { keys: 'u', type: 'operator', operator: 'changeCase', operatorArgs: {toLower: true}, context: 'visual', isEdit: true },\n    { keys: 'U', type: 'operator', operator: 'changeCase', operatorArgs: {toLower: false}, context: 'visual', isEdit: true },\n    { keys: '<C-r>', type: 'action', action: 'redo' },\n    { keys: 'm<register>', type: 'action', action: 'setMark' },\n    { keys: '\"<register>', type: 'action', action: 'setRegister' },\n    { keys: '<C-r><register>', type: 'action', action: 'insertRegister', context: 'insert', isEdit: true },\n    { keys: '<C-o>', type: 'action', action: 'oneNormalCommand', context: 'insert' },\n    { keys: 'zz', type: 'action', action: 'scrollToCursor', actionArgs: { position: 'center' }},\n    { keys: 'z.', type: 'action', action: 'scrollToCursor', actionArgs: { position: 'center' }, motion: 'moveToFirstNonWhiteSpaceCharacter' },\n    { keys: 'zt', type: 'action', action: 'scrollToCursor', actionArgs: { position: 'top' }},\n    { keys: 'z<CR>', type: 'action', action: 'scrollToCursor', actionArgs: { position: 'top' }, motion: 'moveToFirstNonWhiteSpaceCharacter' },\n    { keys: 'zb', type: 'action', action: 'scrollToCursor', actionArgs: { position: 'bottom' }},\n    { keys: 'z-', type: 'action', action: 'scrollToCursor', actionArgs: { position: 'bottom' }, motion: 'moveToFirstNonWhiteSpaceCharacter' },\n    { keys: '.', type: 'action', action: 'repeatLastEdit' },\n    { keys: '<C-a>', type: 'action', action: 'incrementNumberToken', isEdit: true, actionArgs: {increase: true, backtrack: false}},\n    { keys: '<C-x>', type: 'action', action: 'incrementNumberToken', isEdit: true, actionArgs: {increase: false, backtrack: false}},\n    { keys: '<C-t>', type: 'action', action: 'indent', actionArgs: { indentRight: true }, context: 'insert' },\n    { keys: '<C-d>', type: 'action', action: 'indent', actionArgs: { indentRight: false }, context: 'insert' },\n    // Text object motions\n    { keys: 'a<register>', type: 'motion', motion: 'textObjectManipulation' },\n    { keys: 'i<register>', type: 'motion', motion: 'textObjectManipulation', motionArgs: { textObjectInner: true }},\n    // Search\n    { keys: '/', type: 'search', searchArgs: { forward: true, querySrc: 'prompt', toJumplist: true }},\n    { keys: '?', type: 'search', searchArgs: { forward: false, querySrc: 'prompt', toJumplist: true }},\n    { keys: '*', type: 'search', searchArgs: { forward: true, querySrc: 'wordUnderCursor', wholeWordOnly: true, toJumplist: true }},\n    { keys: '#', type: 'search', searchArgs: { forward: false, querySrc: 'wordUnderCursor', wholeWordOnly: true, toJumplist: true }},\n    { keys: 'g*', type: 'search', searchArgs: { forward: true, querySrc: 'wordUnderCursor', toJumplist: true }},\n    { keys: 'g#', type: 'search', searchArgs: { forward: false, querySrc: 'wordUnderCursor', toJumplist: true }},\n    // Ex command\n    { keys: ':', type: 'ex' }\n  ];\n  var usedKeys = Object.create(null);\n  var defaultKeymapLength = defaultKeymap.length;\n\n  /**\n   * Ex commands\n   * Care must be taken when adding to the default Ex command map. For any\n   * pair of commands that have a shared prefix, at least one of their\n   * shortNames must not match the prefix of the other command.\n   */\n  var defaultExCommandMap = [\n    { name: 'colorscheme', shortName: 'colo' },\n    { name: 'map' },\n    { name: 'imap', shortName: 'im' },\n    { name: 'nmap', shortName: 'nm' },\n    { name: 'vmap', shortName: 'vm' },\n    { name: 'omap', shortName: 'om' },\n    { name: 'noremap', shortName: 'no' },\n    { name: 'nnoremap', shortName: 'nn' },\n    { name: 'vnoremap', shortName: 'vn' },\n    { name: 'inoremap', shortName: 'ino' },\n    { name: 'onoremap', shortName: 'ono' },\n    { name: 'unmap' },\n    { name: 'mapclear', shortName: 'mapc' },\n    { name: 'nmapclear', shortName: 'nmapc' },\n    { name: 'vmapclear', shortName: 'vmapc' },\n    { name: 'imapclear', shortName: 'imapc' },\n    { name: 'omapclear', shortName: 'omapc' },\n    { name: 'write', shortName: 'w' },\n    { name: 'undo', shortName: 'u' },\n    { name: 'redo', shortName: 'red' },\n    { name: 'set', shortName: 'se' },\n    { name: 'setlocal', shortName: 'setl' },\n    { name: 'setglobal', shortName: 'setg' },\n    { name: 'sort', shortName: 'sor' },\n    { name: 'substitute', shortName: 's', possiblyAsync: true },\n    { name: 'startinsert', shortName: 'start' },\n    { name: 'nohlsearch', shortName: 'noh' },\n    { name: 'yank', shortName: 'y' },\n    { name: 'delmarks', shortName: 'delm' },\n    { name: 'marks',  excludeFromCommandHistory: true },\n    { name: 'registers', shortName: 'reg', excludeFromCommandHistory: true },\n    { name: 'vglobal', shortName: 'v' },\n    { name: 'delete', shortName: 'd' },\n    { name: 'join', shortName: 'j' },\n    { name: 'normal', shortName: 'norm' },\n    { name: 'global', shortName: 'g' }\n  ];\n\n  /**\n   * Langmap\n   * Determines how to interpret keystrokes in Normal and Visual mode.\n   * Useful for people who use a different keyboard layout than QWERTY\n   */\n  var langmap = parseLangmap('');\n\n  /** @arg {CodeMirror} cm */\n  function enterVimMode(cm) {\n    cm.setOption('disableInput', true);\n    cm.setOption('showCursorWhenSelecting', false);\n    CM.signal(cm, \"vim-mode-change\", {mode: \"normal\"});\n    cm.on('cursorActivity', onCursorActivity);\n    maybeInitVimState(cm);\n    // @ts-ignore\n    CM.on(cm.getInputField(), 'paste', getOnPasteFn(cm));\n  }\n\n  /** @arg {CodeMirror} cm */\n  function leaveVimMode(cm) {\n    cm.setOption('disableInput', false);\n    cm.off('cursorActivity', onCursorActivity);\n    // @ts-ignore\n    CM.off(cm.getInputField(), 'paste', getOnPasteFn(cm));\n    cm.state.vim = null;\n    if (highlightTimeout) clearTimeout(highlightTimeout);\n  }\n\n  /** @arg {CodeMirrorV} cm */\n  function getOnPasteFn(cm) {\n    var vim = cm.state.vim;\n    if (!vim.onPasteFn) {\n      vim.onPasteFn = function() {\n        if (!vim.insertMode) {\n          cm.setCursor(offsetCursor(cm.getCursor(), 0, 1));\n          actions.enterInsertMode(cm, {}, vim);\n        }\n      };\n    }\n    return vim.onPasteFn;\n  }\n\n  var numberRegex = /[\\d]/;\n  var wordCharTest = [CM.isWordChar, function(ch) {\n    return ch && !CM.isWordChar(ch) && !/\\s/.test(ch);\n  }], bigWordCharTest = [function(ch) {\n    return /\\S/.test(ch);\n  }];\n  var validMarks = ['<', '>'];\n  var validRegisters = ['-', '\"', '.', ':', '_', '/', '+'];\n  var latinCharRegex = /^\\w$/;\n  var upperCaseChars = /^[A-Z]$/;\n  try { upperCaseChars = new RegExp(\"^[\\\\p{Lu}]$\", \"u\"); }\n  catch (_) { }\n\n  /** @arg {CodeMirror} cm @arg {number} line */\n  function isLine(cm, line) {\n    return line >= cm.firstLine() && line <= cm.lastLine();\n  }\n  /** @arg {string} k */\n  function isLowerCase(k) {\n    return (/^[a-z]$/).test(k);\n  }\n  /** @arg {string} k */\n  function isMatchableSymbol(k) {\n    return '()[]{}'.indexOf(k) != -1;\n  }\n  /** @arg {string} k */\n  function isNumber(k) {\n    return numberRegex.test(k);\n  }\n  /** @arg {string} k */\n  function isUpperCase(k) {\n    return upperCaseChars.test(k);\n  }\n  /** @arg {string} k */\n  function isWhiteSpaceString(k) {\n    return (/^\\s*$/).test(k);\n  }\n  /** @arg {string} k */\n  function isEndOfSentenceSymbol(k) {\n    return '.?!'.indexOf(k) != -1;\n  }\n  /** @arg {any} val @arg {string | any[]} arr */\n  function inArray(val, arr) {\n    for (var i = 0; i < arr.length; i++) {\n      if (arr[i] == val) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n\n  /** @typedef {import(\"./types\").vimOption} vimOption */\n  /** @type {Object<string, vimOption>} */\n  var options = {};\n  /**\n   * @overload\n   * @arg {string} name \n   * @arg {boolean|null|undefined} defaultValue \n   * @arg {'boolean'} type \n   * @arg {string[]|null} [aliases] \n   * @arg {import(\"./types\").booleanOptionCallback} [callback] \n   * @returns {void}\n   */\n  /**\n   * @overload\n   * @arg {string} name \n   * @arg {number|null|undefined} defaultValue \n   * @arg {'number'} type \n   * @arg {string[]|null} [aliases] \n   * @arg {import(\"./types\").numberOptionCallback} [callback]\n   * @returns {void} \n   */\n  /**\n   * @overload\n   * @arg {string} name \n   * @arg {string|null|undefined} defaultValue \n   * @arg {'string'} type \n   * @arg {string[]|null} [aliases] \n   * @arg {import(\"./types\").stringOptionCallback} [callback]\n   * @returns {void}\n   */\n  /** \n   * @arg {string} name \n   * @arg {any} defaultValue \n   * @arg {'string'} type \n   * @arg {string[]|null} [aliases] \n   * @arg {import(\"./types\").optionCallback} [callback] \n   * */\n  function defineOption(name, defaultValue, type, aliases, callback) {\n    if (defaultValue === undefined && !callback) {\n      throw Error('defaultValue is required unless callback is provided');\n    }\n    if (!type) { type = 'string'; }\n    options[name] = {\n      type: type,\n      defaultValue: defaultValue,\n      callback: callback\n    };\n    if (aliases) {\n      for (var i = 0; i < aliases.length; i++) {\n        options[aliases[i]] = options[name];\n      }\n    }\n    if (defaultValue) {\n      setOption(name, defaultValue);\n    }\n  }\n\n  /**\n   * @arg {string} name \n   * @arg {any} value \n   * @arg {CodeMirrorV} [cm] \n   * @arg {{ scope?: any; } | undefined} [cfg] */\n  function setOption(name, value, cm, cfg) {\n    var option = options[name];\n    cfg = cfg || {};\n    var scope = cfg.scope;\n    if (!option) {\n      return new Error('Unknown option: ' + name);\n    }\n    if (option.type == 'boolean') {\n      if (value && value !== true) {\n        return new Error('Invalid argument: ' + name + '=' + value);\n      } else if (value !== false) {\n        // Boolean options are set to true if value is not defined.\n        value = true;\n      }\n    }\n    if (option.callback) {\n      if (scope !== 'local') {\n        option.callback(value, undefined);\n      }\n      if (scope !== 'global' && cm) {\n        option.callback(value, cm);\n      }\n    } else {\n      if (scope !== 'local') {\n        option.value = option.type == 'boolean' ? !!value : value;\n      }\n      if (scope !== 'global' && cm) {\n        cm.state.vim.options[name] = {value: value};\n      }\n    }\n  }\n\n  /** \n   * @arg {string} name \n   * @arg {CodeMirrorV} [cm] \n   * @arg {{ scope?: any; } | undefined} [cfg] */\n  function getOption(name, cm, cfg) {\n    var option = options[name];\n    cfg = cfg || {};\n    var scope = cfg.scope;\n    if (!option) {\n      return new Error('Unknown option: ' + name);\n    }\n    if (option.callback) {\n      let local = cm && option.callback(undefined, cm);\n      if (scope !== 'global' && local !== undefined) {\n        return local;\n      }\n      if (scope !== 'local') {\n        return option.callback();\n      }\n      return;\n    } else {\n      let local = (scope !== 'global') && (cm && cm.state.vim.options[name]);\n      return (local || (scope !== 'local') && option || {}).value;\n    }\n  }\n  /** @arg {string|undefined} name @arg {CodeMirrorV} [cm] */\n  defineOption('filetype', undefined, 'string', ['ft'], function(name, cm) {\n    // Option is local. Do nothing for global.\n    if (cm === undefined) {\n      return;\n    }\n    // The 'filetype' option proxies to the CodeMirror 'mode' option.\n    if (name === undefined) {\n      let mode = cm.getOption('mode');\n      return mode == 'null' ? '' : mode;\n    } else {\n      let mode = name == '' ? 'null' : name;\n      cm.setOption('mode', mode);\n    }\n  });\n  defineOption('textwidth', 80, 'number', ['tw'], function(width, cm) {\n    // Option is local. Do nothing for global.\n    if (cm === undefined) {\n      return;\n    }\n    // The 'filetype' option proxies to the CodeMirror 'mode' option.\n    if (width === undefined) {\n      var value = cm.getOption('textwidth');\n      return value;\n    } else {\n      var column = Math.round(width);\n      if (column > 1) {\n        cm.setOption('textwidth', column);\n      }\n    }\n  });\n\n  var createCircularJumpList = function() {\n    var size = 100;\n    var pointer = -1;\n    var head = 0;\n    var tail = 0;\n    \n    var buffer = /**@type {(Marker|undefined)[]} */ (new Array(size));\n    /** @arg {CodeMirror} cm  @arg {Pos} oldCur @arg {Pos} newCur */\n    function add(cm, oldCur, newCur) {\n      var current = pointer % size;\n      var curMark = buffer[current];\n      /** @arg {Pos} cursor */\n      function useNextSlot(cursor) {\n        var next = ++pointer % size;\n        var trashMark = buffer[next];\n        if (trashMark) {\n          trashMark.clear();\n        }\n        buffer[next] = cm.setBookmark(cursor);\n      }\n      if (curMark) {\n        var markPos = curMark.find();\n        // avoid recording redundant cursor position\n        if (markPos && !cursorEqual(markPos, oldCur)) {\n          useNextSlot(oldCur);\n        }\n      } else {\n        useNextSlot(oldCur);\n      }\n      useNextSlot(newCur);\n      head = pointer;\n      tail = pointer - size + 1;\n      if (tail < 0) {\n        tail = 0;\n      }\n    }\n    /** @arg {CodeMirror} cm  @arg {number} offset */\n    function move(cm, offset) {\n      pointer += offset;\n      if (pointer > head) {\n        pointer = head;\n      } else if (pointer < tail) {\n        pointer = tail;\n      }\n      var mark = buffer[(size + pointer) % size];\n      // skip marks that are temporarily removed from text buffer\n      if (mark && !mark.find()) {\n        var inc = offset > 0 ? 1 : -1;\n        var newCur;\n        var oldCur = cm.getCursor();\n        do {\n          pointer += inc;\n          mark = buffer[(size + pointer) % size];\n          // skip marks that are the same as current position\n          if (mark &&\n              (newCur = mark.find()) &&\n              !cursorEqual(oldCur, newCur)) {\n            break;\n          }\n        } while (pointer < head && pointer > tail);\n      }\n      return mark;\n    }\n    /** @arg {CodeMirror} cm @arg {number} offset */\n    function find(cm, offset) {\n      var oldPointer = pointer;\n      var mark = move(cm, offset);\n      pointer = oldPointer;\n      return mark && mark.find();\n    }\n    return {\n      /**@type{Pos|undefined} */\n      cachedCursor: undefined, //used for # and * jumps\n      add: add,\n      find: find,\n      move: move\n    };\n  };\n\n  /** \n   * Returns an object to track the changes associated insert mode.  It\n   * clones the object that is passed in, or creates an empty object one if\n   * none is provided.\n   * @arg {import(\"./types\").InsertModeChanges | undefined} [c]\n   * @returns {import(\"./types\").InsertModeChanges} \n   */\n  var createInsertModeChanges = function(c) {\n    if (c) {\n      // Copy construction\n      return {\n        changes: c.changes,\n        expectCursorActivityForChange: c.expectCursorActivityForChange\n      };\n    }\n    return {\n      // Change list\n      changes: [],\n      // Set to true on change, false on cursorActivity.\n      expectCursorActivityForChange: false\n    };\n  };\n\n  class MacroModeState {\n    constructor() {\n      this.latestRegister = undefined;\n      this.isPlaying = false;\n      this.isRecording = false;\n      /** @type {string[]}*/\n      this.replaySearchQueries = [];\n      this.onRecordingDone = undefined;\n      this.lastInsertModeChanges = createInsertModeChanges();\n    }\n    exitMacroRecordMode() {\n      var macroModeState = vimGlobalState.macroModeState;\n      if (macroModeState.onRecordingDone) {\n        macroModeState.onRecordingDone(); // close dialog\n      }\n      macroModeState.onRecordingDone = undefined;\n      macroModeState.isRecording = false;\n    }\n    /**\n     * @arg {CodeMirror} cm\n     * @arg {string} registerName\n     */\n    enterMacroRecordMode(cm, registerName) {\n      var register = vimGlobalState.registerController.getRegister(registerName);\n      if (register) {\n        register.clear();\n        this.latestRegister = registerName;\n        if (cm.openDialog) {\n          var template = dom('span', {class: 'cm-vim-message'}, 'recording @' + registerName);\n          this.onRecordingDone = cm.openDialog(template, function() {}, {bottom:true});\n        }\n        this.isRecording = true;\n      }\n    }\n  }\n  /**\n   * @arg {CodeMirror} cm\n   * @return {vimState}\n   */\n  function maybeInitVimState(cm) {\n    if (!cm.state.vim) {\n      // Store instance state in the CodeMirror object.\n      cm.state.vim = {\n        inputState: new InputState(),\n        // Vim's input state that triggered the last edit, used to repeat\n        // motions and operators with '.'.\n        lastEditInputState: undefined,\n        // Vim's action command before the last edit, used to repeat actions\n        // with '.' and insert mode repeat.\n        lastEditActionCommand: undefined,\n        // When using jk for navigation, if you move from a longer line to a\n        // shorter line, the cursor may clip to the end of the shorter line.\n        // If j is pressed again and cursor goes to the next line, the\n        // cursor should go back to its horizontal position on the longer\n        // line if it can. This is to keep track of the horizontal position.\n        lastHPos: -1,\n        // Doing the same with screen-position for gj/gk\n        lastHSPos: -1,\n        // The last motion command run. Cleared if a non-motion command gets\n        // executed in between.\n        lastMotion: null,\n        marks: {},\n        insertMode: false,\n        insertModeReturn: false,\n        // Repeat count for changes made in insert mode, triggered by key\n        // sequences like 3,i. Only exists when insertMode is true.\n        insertModeRepeat: undefined,\n        visualMode: false,\n        // If we are in visual line mode. No effect if visualMode is false.\n        visualLine: false,\n        visualBlock: false,\n        lastSelection: /**@type{vimState[\"lastSelection\"]}*/( /**@type{unknown}*/(null)),\n        lastPastedText: undefined,\n        sel: {anchor: new Pos(0, 0), head: new Pos(0, 0)},\n        // Buffer-local/window-local values of vim options.\n        options: {},\n        // Whether the next character should be interpreted literally\n        // Necassary for correct implementation of f<character>, r<character> etc.\n        // in terms of langmaps.\n        expectLiteralNext: false,\n        status: \"\",\n      };\n    }\n    return cm.state.vim;\n  }\n  /**\n   * @type { \n      {\n        macroModeState: MacroModeState;\n        registerController: RegisterController;\n        searchHistoryController: HistoryController;\n        jumpList: ReturnType<createCircularJumpList>;\n        exCommandHistoryController: HistoryController; \n        lastCharacterSearch: {increment: number, forward: boolean, selectedCharacter: string}; \n        query?: any;\n        isReversed?: boolean;\n        lastSubstituteReplacePart: any;\n        searchQuery?: null; \n        searchIsReversed?: boolean; \n      }\n    }\n  */\n  var vimGlobalState;\n  function resetVimGlobalState() {\n    vimGlobalState = {\n      // The current search query.\n      searchQuery: null,\n      // Whether we are searching backwards.\n      searchIsReversed: false,\n      // Replace part of the last substituted pattern\n      lastSubstituteReplacePart: undefined,\n      jumpList: createCircularJumpList(),\n      macroModeState: new MacroModeState(),\n      // Recording latest f, t, F or T motion command.\n      lastCharacterSearch: {increment:0, forward:true, selectedCharacter:''},\n      registerController: new RegisterController({}),\n      // search history buffer\n      searchHistoryController: new HistoryController(),\n      // ex Command history buffer\n      exCommandHistoryController : new HistoryController()\n    };\n    for (var optionName in options) {\n      var option = options[optionName];\n      option.value = option.defaultValue;\n    }\n  }\n\n  class InsertModeKey {\n    /**\n     * Wrapper for special keys pressed in insert mode\n     * @arg {string} keyName\n     * @arg {KeyboardEvent} e\n     * @returns\n     */    \n    constructor(keyName, e) {\n      this.keyName = keyName;\n      this.key = e.key;\n      this.ctrlKey = e.ctrlKey;\n      this.altKey = e.altKey;\n      this.metaKey = e.metaKey;\n      this.shiftKey = e.shiftKey;\n    }\n  }\n\n\n  /** @type {number | undefined|false} */\n  var lastInsertModeKeyTimer;\n  var vimApi = {\n    enterVimMode: enterVimMode,\n    leaveVimMode: leaveVimMode,\n    buildKeyMap: function() {\n      // TODO: Convert keymap into dictionary format for fast lookup.\n    },\n    // Testing hook, though it might be useful to expose the register\n    // controller anyway.\n    getRegisterController: function() {\n      return vimGlobalState.registerController;\n    },\n    // Testing hook.\n    resetVimGlobalState_: resetVimGlobalState,\n\n    // Testing hook.\n    getVimGlobalState_: function() {\n      return vimGlobalState;\n    },\n\n    // Testing hook.\n    maybeInitVimState_: maybeInitVimState,\n\n    suppressErrorLogging: false,\n\n    InsertModeKey: InsertModeKey,\n    /**@type {(lhs: string, rhs: string, ctx: string) => void} */\n    map: function(lhs, rhs, ctx) {\n      // Add user defined key bindings.\n      exCommandDispatcher.map(lhs, rhs, ctx);\n    },\n    /**@type {(lhs: string, ctx: string) => any} */\n    unmap: function(lhs, ctx) {\n      return exCommandDispatcher.unmap(lhs, ctx);\n    },\n    // Non-recursive map function.\n    // NOTE: This will not create mappings to key maps that aren't present\n    // in the default key map. See TODO at bottom of function.\n    /**@type {(lhs: string, rhs: string, ctx: string) => void} */\n    noremap: function(lhs, rhs, ctx) {\n      exCommandDispatcher.map(lhs, rhs, ctx, true);\n    },\n    // Remove all user-defined mappings for the provided context.\n    /**@arg {string} [ctx]} */\n    mapclear: function(ctx) {\n      // Partition the existing keymap into user-defined and true defaults.\n      var actualLength = defaultKeymap.length,\n          origLength = defaultKeymapLength;\n      var userKeymap = defaultKeymap.slice(0, actualLength - origLength);\n      defaultKeymap = defaultKeymap.slice(actualLength - origLength);\n      if (ctx) {\n        // If a specific context is being cleared, we need to keep mappings\n        // from all other contexts.\n        for (var i = userKeymap.length - 1; i >= 0; i--) {\n          var mapping = userKeymap[i];\n          if (ctx !== mapping.context) {\n            if (mapping.context) {\n              this._mapCommand(mapping);\n            } else {\n              // `mapping` applies to all contexts so create keymap copies\n              // for each context except the one being cleared.\n              var contexts = ['normal', 'insert', 'visual'];\n              for (var j in contexts) {\n                if (contexts[j] !== ctx) {\n                  var newMapping = Object.assign({}, mapping);\n                  newMapping.context = contexts[j];\n                  this._mapCommand(newMapping);\n                }\n              }\n            }\n          }\n        }\n      }\n    },\n    langmap: updateLangmap,\n    vimKeyFromEvent: vimKeyFromEvent,\n    // TODO: Expose setOption and getOption as instance methods. Need to decide how to namespace\n    // them, or somehow make them work with the existing CodeMirror setOption/getOption API.\n    setOption: setOption,\n    getOption: getOption,\n    defineOption: defineOption,\n    /**@type {(name: string, prefix: string|undefined, func: ExFn) => void} */\n    defineEx: function(name, prefix, func){\n      if (!prefix) {\n        prefix = name;\n      } else if (name.indexOf(prefix) !== 0) {\n        throw new Error('(Vim.defineEx) \"'+prefix+'\" is not a prefix of \"'+name+'\", command not registered');\n      }\n      exCommands[name]=func;\n      exCommandDispatcher.commandMap_[prefix]={name:name, shortName:prefix, type:'api'};\n    },\n    /**@type {(cm: CodeMirror, key: string, origin: string) => undefined | boolean} */\n    handleKey: function (cm, key, origin) {\n      var command = this.findKey(cm, key, origin);\n      if (typeof command === 'function') {\n        return command();\n      }\n    },\n    multiSelectHandleKey: multiSelectHandleKey,\n\n    /**\n     * This is the outermost function called by CodeMirror, after keys have\n     * been mapped to their Vim equivalents.\n     *\n     * Finds a command based on the key (and cached keys if there is a\n     * multi-key sequence). Returns `undefined` if no key is matched, a noop\n     * function if a partial match is found (multi-key), and a function to\n     * execute the bound command if a a key is matched. The function always\n     * returns true.\n     */\n    /**@type {(cm_: CodeMirror, key: string, origin?: string| undefined) => (() => boolean|undefined) | undefined} */\n    findKey: function(cm_, key, origin) {\n      var vim = maybeInitVimState(cm_);\n      var cm = /**@type {CodeMirrorV}*/(cm_);\n\n      function handleMacroRecording() {\n        var macroModeState = vimGlobalState.macroModeState;\n        if (macroModeState.isRecording) {\n          if (key == 'q') {\n            macroModeState.exitMacroRecordMode();\n            clearInputState(cm);\n            return true;\n          }\n          if (origin != 'mapping') {\n            logKey(macroModeState, key);\n          }\n        }\n      }\n      function handleEsc() {\n        if (key == '<Esc>') {\n          if (vim.visualMode) {\n            // Get back to normal mode.\n            exitVisualMode(cm);\n          } else if (vim.insertMode) {\n            // Get back to normal mode.\n            exitInsertMode(cm);\n          } else {\n            // We're already in normal mode. Let '<Esc>' be handled normally.\n            return;\n          }\n          clearInputState(cm);\n          return true;\n        }\n      }\n\n      function handleKeyInsertMode() {\n        if (handleEsc()) { return true; }\n        vim.inputState.keyBuffer.push(key);\n        var keys = vim.inputState.keyBuffer.join(\"\");\n        var keysAreChars = key.length == 1;\n        var match = commandDispatcher.matchCommand(keys, defaultKeymap, vim.inputState, 'insert');\n        var changeQueue = vim.inputState.changeQueue;\n\n        if (match.type == 'none') { clearInputState(cm); return false; }\n        else if (match.type == 'partial') {\n          if (match.expectLiteralNext) vim.expectLiteralNext = true;\n          if (lastInsertModeKeyTimer) { window.clearTimeout(lastInsertModeKeyTimer); }\n          lastInsertModeKeyTimer = keysAreChars && window.setTimeout(\n            function() { if (vim.insertMode && vim.inputState.keyBuffer.length) { clearInputState(cm); } },\n            getOption('insertModeEscKeysTimeout'));\n          if (keysAreChars) {\n            var selections = cm.listSelections();\n            if (!changeQueue || changeQueue.removed.length != selections.length)\n              changeQueue = vim.inputState.changeQueue = new ChangeQueue;\n            changeQueue.inserted += key;\n            for (var i = 0; i < selections.length; i++) {\n              var from = cursorMin(selections[i].anchor, selections[i].head);\n              var to = cursorMax(selections[i].anchor, selections[i].head);\n              var text = cm.getRange(from, cm.state.overwrite ? offsetCursor(to, 0, 1) : to);\n              changeQueue.removed[i] = (changeQueue.removed[i] || \"\") + text;\n            }\n          }\n          return !keysAreChars;\n        }\n        else if (match.type == 'full') {\n          vim.inputState.keyBuffer.length = 0;\n        }\n        vim.expectLiteralNext = false;\n\n        if (lastInsertModeKeyTimer) { window.clearTimeout(lastInsertModeKeyTimer); }\n        if (match.command && changeQueue) {\n          var selections = cm.listSelections();\n          for (var i = 0; i < selections.length; i++) {\n            var here = selections[i].head;\n            cm.replaceRange(changeQueue.removed[i] || \"\", \n              offsetCursor(here, 0, -changeQueue.inserted.length), here, '+input');\n          }\n          vimGlobalState.macroModeState.lastInsertModeChanges.changes.pop();\n        }\n        if (!match.command) clearInputState(cm);\n        return match.command;\n      }\n\n      function handleKeyNonInsertMode() {\n        if (handleMacroRecording() || handleEsc()) { return true; }\n\n        vim.inputState.keyBuffer.push(key);\n        var keys = vim.inputState.keyBuffer.join(\"\");\n        if (/^[1-9]\\d*$/.test(keys)) { return true; }\n\n        var keysMatcher = /^(\\d*)(.*)$/.exec(keys);\n        if (!keysMatcher) { clearInputState(cm); return false; }\n        var context = vim.visualMode ? 'visual' :\n                                        'normal';\n        var mainKey = keysMatcher[2] || keysMatcher[1];\n        if (vim.inputState.operatorShortcut && vim.inputState.operatorShortcut.slice(-1) == mainKey) {\n          // multikey operators act linewise by repeating only the last character\n          mainKey = vim.inputState.operatorShortcut;\n        }\n        var match = commandDispatcher.matchCommand(mainKey, defaultKeymap, vim.inputState, context);\n        if (match.type == 'none') { clearInputState(cm); return false; }\n        else if (match.type == 'partial') {\n          if (match.expectLiteralNext) vim.expectLiteralNext = true;\n          return true;\n        }\n        else if (match.type == 'clear') { clearInputState(cm); return true; }\n        vim.expectLiteralNext = false;\n\n        vim.inputState.keyBuffer.length = 0;\n        keysMatcher = /^(\\d*)(.*)$/.exec(keys);\n        if (keysMatcher && keysMatcher[1] && keysMatcher[1] != '0') {\n          vim.inputState.pushRepeatDigit(keysMatcher[1]);\n        }\n        return match.command;\n      }\n\n      var command = vim.insertMode\n        ? handleKeyInsertMode()\n        : handleKeyNonInsertMode();\n\n      if (command === false) {\n        return !vim.insertMode && (key.length === 1 || (CM.isMac && /<A-.>/.test(key)))? function() { return true; } : undefined;\n      } else if (command === true) {\n        // TODO: Look into using CodeMirror's multi-key handling.\n        // Return no-op since we are caching the key. Counts as handled, but\n        // don't want act on it just yet.\n        return function() { return true; };\n      } else if (command) {\n        return function() {\n          return cm.operation(function() {\n            // @ts-ignore\n            cm.curOp.isVimOp = true;\n            try {\n              if (typeof command != 'object') return;\n              \n              if (command.type == 'keyToKey') {\n                doKeyToKey(cm, command.toKeys, command);\n              } else {\n                commandDispatcher.processCommand(cm, vim, command);\n              }\n            } catch (e) {\n              // clear VIM state in case it's in a bad state.\n              // @ts-ignore\n              cm.state.vim = undefined;\n              maybeInitVimState(cm);\n              if (!vimApi.suppressErrorLogging) {\n                console['log'](e);\n              }\n              throw e;\n            }\n            return true;\n          });\n        };\n      }\n    },\n    /**@type {(cm: CodeMirrorV, input: string)=>void} */\n    handleEx: function(cm, input) {\n      exCommandDispatcher.processCommand(cm, input);\n    },\n\n    defineMotion: defineMotion,\n    defineAction: defineAction,\n    defineOperator: defineOperator,\n    mapCommand: mapCommand,\n    _mapCommand: _mapCommand,\n\n    defineRegister: defineRegister,\n\n    exitVisualMode: exitVisualMode,\n    exitInsertMode: exitInsertMode\n  };\n\n  var keyToKeyStack = [];\n  var noremap = false;\n  /**@type {undefined | null | import(\"./types\").PromptOptions} */\n  var virtualPrompt;\n  /**\n   * @arg {string} key\n   */\n  function sendKeyToPrompt(key) {\n    if (!virtualPrompt) throw new Error('No prompt to send key to');\n    if (key[0] == \"<\") {\n      var lowerKey = key.toLowerCase().slice(1, -1);\n      var parts = lowerKey.split('-');\n      lowerKey = parts.pop() || '';\n      if (lowerKey == 'lt') key = '<';\n      else if (lowerKey == 'space') key = ' ';\n      else if (lowerKey == 'cr') key = '\\n';\n      else if (vimToCmKeyMap[lowerKey]) {\n        var value = virtualPrompt.value || \"\";\n        var event =  {\n          key: vimToCmKeyMap[lowerKey],\n          target: {\n            value: value,\n            selectionEnd: value.length,\n            selectionStart: value.length\n          }\n        };\n        if (virtualPrompt.onKeyDown) {\n          virtualPrompt.onKeyDown(event, virtualPrompt.value, close);\n        }\n        if (virtualPrompt && virtualPrompt.onKeyUp) {\n          virtualPrompt.onKeyUp(event, virtualPrompt.value, close);\n        }\n        return;\n      }\n    }\n    if (key == '\\n') {\n      var prompt = virtualPrompt;\n      virtualPrompt = null;\n      prompt.onClose && prompt.onClose(prompt.value);\n    } else {\n      virtualPrompt.value = (virtualPrompt.value || '') + key;\n    }\n\n    /** @param {string | undefined} value */\n    function close(value) {\n      if (!virtualPrompt) return;\n      if (typeof value == 'string') { virtualPrompt.value = value; }\n      else { virtualPrompt = null; }\n    }\n  }\n  /**\n   * @arg {CodeMirrorV} cm\n   * @arg {string} keys\n   * @arg {vimKey|import(\"./types\").exCommandDefinition|{noremap?: boolean}} [fromKey]\n   */\n  function doKeyToKey(cm, keys, fromKey) {\n    var noremapBefore = noremap;\n    // prevent infinite recursion.\n    if (fromKey) {\n      if (keyToKeyStack.indexOf(fromKey) != -1) return;\n      keyToKeyStack.push(fromKey);\n      noremap = fromKey.noremap != false;\n    }\n\n    try {\n      var vim = maybeInitVimState(cm);\n      var keyRe = /<(?:[CSMA]-)*\\w+>|./gi;\n\n      var match;\n      // Pull off one command key, which is either a single character\n      // or a special sequence wrapped in '<' and '>', e.g. '<Space>'.\n      while ((match = keyRe.exec(keys))) {\n        var key = match[0];\n        var wasInsert = vim.insertMode;\n        if (virtualPrompt) {\n          sendKeyToPrompt(key);\n          continue;\n        }\n\n        var result = vimApi.handleKey(cm, key, 'mapping');\n\n        if (!result && wasInsert && vim.insertMode) {\n          if (key[0] == \"<\") {\n            var lowerKey = key.toLowerCase().slice(1, -1);\n            var parts = lowerKey.split('-');\n            lowerKey = parts.pop() || '';\n            if (lowerKey == 'lt') key = '<';\n            else if (lowerKey == 'space') key = ' ';\n            else if (lowerKey == 'cr') key = '\\n';\n            else if (vimToCmKeyMap.hasOwnProperty(lowerKey)) {\n              // todo support codemirror keys in insertmode vimToCmKeyMap\n              key = vimToCmKeyMap[lowerKey];\n              sendCmKey(cm, key);\n              continue;\n            } else {\n              key = key[0];\n              keyRe.lastIndex = match.index + 1;\n            }\n          }\n          cm.replaceSelection(key);\n        }\n      }\n    } finally {\n      keyToKeyStack.pop();\n      noremap = keyToKeyStack.length ? noremapBefore : false;\n      if (!keyToKeyStack.length && virtualPrompt) {\n        var promptOptions = virtualPrompt;\n        virtualPrompt = null;\n        showPrompt(cm, promptOptions);\n      }\n    }\n  }\n\n  /**@type{Record<string, string>} */\n  var specialKey = {\n    Return: 'CR', Backspace: 'BS', 'Delete': 'Del', Escape: 'Esc', Insert: 'Ins',\n    ArrowLeft: 'Left', ArrowRight: 'Right', ArrowUp: 'Up', ArrowDown: 'Down',\n    Enter: 'CR', ' ': 'Space'\n  };\n  var ignoredKeys = { Shift: 1, Alt: 1, Command: 1, Control: 1,\n    CapsLock: 1, AltGraph: 1, Dead: 1, Unidentified: 1 };\n\n  var vimToCmKeyMap = {};\n  'Left|Right|Up|Down|End|Home'.split('|').concat(Object.keys(specialKey)).forEach(function(x) {\n    vimToCmKeyMap[(specialKey[x] || '').toLowerCase()]\n        = vimToCmKeyMap[x.toLowerCase()] = x;\n  });\n\n  /**\n   * @param {KeyboardEvent} e\n   * @param {vimState} [vim]\n   */\n  function vimKeyFromEvent(e, vim) {\n    var key = e.key;\n    if (ignoredKeys[key]) return;\n    if (key.length > 1 && key[0] == \"n\") {\n      key = key.replace(\"Numpad\", \"\");\n    }\n    key = specialKey[key] || key;\n\n    var name = '';\n    if (e.ctrlKey) { name += 'C-'; }\n    if (e.altKey) { name += 'A-'; }\n    if (e.metaKey) { name += 'M-'; }\n    // on mac many characters are entered as option- combos\n    // (e.g. on swiss keyboard { is option-8)\n    // so we ignore lonely A- modifier for keypress event on mac\n    if (CM.isMac && name == \"A-\" && key.length == 1) {\n      name = name.slice(2);\n    }\n    if ((name || key.length > 1) && e.shiftKey) { name += 'S-'; }\n\n    if (vim && !vim.expectLiteralNext && key.length == 1) {\n      if (langmap.keymap && key in langmap.keymap) {\n        if (langmap.remapCtrl != false || !name)\n          key = langmap.keymap[key];\n      } else if (key.charCodeAt(0) > 128) {\n        if (!usedKeys[key]) {\n          var code = e.code?.slice(-1) || \"\";\n          if (!e.shiftKey) code = code.toLowerCase();\n          if (code) {\n            key = code;\n            // also restore A- for mac\n            if (!name && e.altKey) name = 'A-';\n          }\n        }\n      }\n    }\n\n    name += key;\n    if (name.length > 1) { name = '<' + name + '>'; }\n    return name;\n  }\n  // langmap support\n  function updateLangmap(langmapString, remapCtrl) {\n    if (langmap.string !== langmapString) {\n      langmap = parseLangmap(langmapString);\n    }\n    langmap.remapCtrl = remapCtrl;\n  }\n  /** \n   *  From :help langmap\n   *  The 'langmap' option is a list of parts, separated with commas.  Each\n   *      part can be in one of two forms:\n   *      1.  A list of pairs.  Each pair is a \"from\" character immediately\n   *          followed by the \"to\" character.  Examples: \"aA\", \"aAbBcC\".\n   *      2.  A list of \"from\" characters, a semi-colon and a list of \"to\"\n   *          characters.  Example: \"abc;ABC\"\n   * @arg {string} langmapString\n   * @returns {{string: string, keymap: Record<string, string>, remapCtrl?: boolean}}\n   */\n  function parseLangmap(langmapString) {\n    let keymap = ({})/**@type {Record<string, string>}*/;\n    if (!langmapString) return { keymap: keymap, string: '' };\n\n    /** @arg {string} list */\n    function getEscaped(list) {\n      return list.split(/\\\\?(.)/).filter(Boolean);\n    }\n    langmapString.split(/((?:[^\\\\,]|\\\\.)+),/).map(part => {\n      if (!part) return;\n      const semicolon = part.split(/((?:[^\\\\;]|\\\\.)+);/);\n      if (semicolon.length == 3) {\n        const from = getEscaped(semicolon[1]);\n        const to = getEscaped(semicolon[2]);\n        if (from.length !== to.length) return; // skip over malformed part\n        for (let i = 0; i < from.length; ++i) keymap[from[i]] = to[i];\n      } else if (semicolon.length == 1) {\n        const pairs = getEscaped(part);\n        if (pairs.length % 2 !== 0) return; // skip over malformed part\n        for (let i = 0; i < pairs.length; i += 2) keymap[pairs[i]] = pairs[i + 1];\n      }\n    });\n\n    return { keymap: keymap, string: langmapString };\n  }\n\n  defineOption('langmap', undefined, 'string', ['lmap'], function(name, cm) {\n    // The 'filetype' option proxies to the CodeMirror 'mode' option.\n    if (name === undefined) {\n      return langmap.string;\n    } else {\n      updateLangmap(name);\n    }\n  });\n\n  // Represents the current input state.\n  /**@implements {InputStateInterface} */\n  class InputState {\n    constructor() {\n      /**@type{InputStateInterface[\"prefixRepeat\"]} */\n      this.prefixRepeat = [];\n      /**@type{InputStateInterface[\"motionRepeat\"]} */\n      this.motionRepeat = [];\n      /**@type{InputStateInterface[\"operator\"]} */\n      this.operator = null;\n      /**@type{InputStateInterface[\"operatorArgs\"]} */\n      this.operatorArgs = null;\n      /**@type{InputStateInterface[\"motion\"]} */\n      this.motion = null;\n      /**@type{InputStateInterface[\"motionArgs\"]} */\n      this.motionArgs = null;\n      /**@type{InputStateInterface[\"keyBuffer\"]} */\n      this.keyBuffer = []; // For matching multi-key commands.\n      /**@type{InputStateInterface[\"registerName\"]} */\n      this.registerName = undefined; // Defaults to the unnamed register.\n      /**@type{InputStateInterface[\"changeQueue\"]} */\n      this.changeQueue = null; // For restoring text used by insert mode keybindings\n    }\n    /** @param {string} n */\n    pushRepeatDigit(n) {\n      if (!this.operator) {\n        this.prefixRepeat = this.prefixRepeat.concat(n);\n      } else {\n        this.motionRepeat = this.motionRepeat.concat(n);\n      }\n    }\n    getRepeat() {\n      var repeat = 0;\n      if (this.prefixRepeat.length > 0 || this.motionRepeat.length > 0) {\n        repeat = 1;\n        if (this.prefixRepeat.length > 0) {\n          repeat *= parseInt(this.prefixRepeat.join(''), 10);\n        }\n        if (this.motionRepeat.length > 0) {\n          repeat *= parseInt(this.motionRepeat.join(''), 10);\n        }\n      }\n      return repeat;\n    }\n  }\n\n  /** @arg {CodeMirrorV} cm  @arg {string} [reason] */\n  function clearInputState(cm, reason) {\n    cm.state.vim.inputState = new InputState();\n    cm.state.vim.expectLiteralNext = false;\n    CM.signal(cm, 'vim-command-done', reason);\n  }\n\n  function ChangeQueue() {\n    this.removed = [];\n    this.inserted = \"\";\n  }\n\n  /**\n   * Register stores information about copy and paste registers.  Besides\n   * text, a register must store whether it is linewise (i.e., when it is\n   * pasted, should it insert itself into a new line, or should the text be\n   * inserted at the cursor position.)\n   */\n  class Register {\n    /** @arg {string} [text] @arg {boolean} [linewise] @arg {boolean } [blockwise] */\n    constructor(text, linewise, blockwise) {\n      this.clear();\n      this.keyBuffer = [text || ''];\n      /** @type {InsertModeChanges[]} */\n      this.insertModeChanges = [];\n      /** @type {string[]}*/\n      this.searchQueries = [];\n      this.linewise = !!linewise;\n      this.blockwise = !!blockwise;\n    }\n    /** @arg {string} [text] @arg {boolean} [linewise] @arg {boolean } [blockwise] */\n    setText(text, linewise, blockwise) {\n      this.keyBuffer = [text || ''];\n      this.linewise = !!linewise;\n      this.blockwise = !!blockwise;\n    }\n    /** @arg {string} text @arg {boolean} [linewise] */\n    pushText(text, linewise) {\n      // if this register has ever been set to linewise, use linewise.\n      if (linewise) {\n        if (!this.linewise) {\n          this.keyBuffer.push('\\n');\n        }\n        this.linewise = true;\n      }\n      this.keyBuffer.push(text);\n    }\n    /** @arg {InsertModeChanges} changes */\n    pushInsertModeChanges(changes) {\n      this.insertModeChanges.push(createInsertModeChanges(changes));\n    }\n    /** @arg {string} query */\n    pushSearchQuery(query) {\n      this.searchQueries.push(query);\n    }\n    clear() {\n      this.keyBuffer = [];\n      this.insertModeChanges = [];\n      this.searchQueries = [];\n      this.linewise = false;\n    }\n    toString() {\n      return this.keyBuffer.join('');\n    }\n  }\n\n  /**\n   * Defines an external register.\n   *\n   * The name should be a single character that will be used to reference the register.\n   * The register should support setText, pushText, clear, and toString(). See Register\n   * for a reference implementation.\n   * @arg {string} name\n   * @arg {Register} register\n   */\n  function defineRegister(name, register) {\n    var registers = vimGlobalState.registerController.registers;\n    if (!name || name.length != 1) {\n      throw Error('Register name must be 1 character');\n    }\n    if (registers[name]) {\n      throw Error('Register already defined ' + name);\n    }\n    registers[name] = register;\n    validRegisters.push(name);\n  }\n\n  /**\n   * vim registers allow you to keep many independent copy and paste buffers.\n   * See http://usevim.com/2012/04/13/registers/ for an introduction.\n   *\n   * RegisterController keeps the state of all the registers.  An initial\n   * state may be passed in.  The unnamed register '\"' will always be\n   * overridden.\n   */\n  class RegisterController {\n    /** @arg {Object<string, Register>} registers */\n    constructor(registers) {\n      this.registers = registers;\n      this.unnamedRegister = registers['\"'] = new Register();\n      registers['.'] = new Register();\n      registers[':'] = new Register();\n      registers['/'] = new Register();\n      registers['+'] = new Register();\n    }\n    /**\n     * @param {string | null | undefined} registerName\n     * @param {string} operator\n     * @param {string} text\n     * @param {boolean} [linewise]\n     * @param {boolean} [blockwise]\n     */\n    pushText(registerName, operator, text, linewise, blockwise) {\n      // The black hole register, \"_, means delete/yank to nowhere.\n      if (registerName === '_') return;\n      if (linewise && text.charAt(text.length - 1) !== '\\n') {\n        text += '\\n';\n      }\n      // Lowercase and uppercase registers refer to the same register.\n      // Uppercase just means append.\n      var register = this.isValidRegister(registerName) ?\n          this.getRegister(registerName) : null;\n      // if no register/an invalid register was specified, things go to the\n      // default registers\n      if (!register || !registerName) {\n        switch (operator) {\n          case 'yank':\n            // The 0 register contains the text from the most recent yank.\n            this.registers['0'] = new Register(text, linewise, blockwise);\n            break;\n          case 'delete':\n          case 'change':\n            if (text.indexOf('\\n') == -1) {\n              // Delete less than 1 line. Update the small delete register.\n              this.registers['-'] = new Register(text, linewise);\n            } else {\n              // Shift down the contents of the numbered registers and put the\n              // deleted text into register 1.\n              this.shiftNumericRegisters_();\n              this.registers['1'] = new Register(text, linewise);\n            }\n            break;\n        }\n        // Make sure the unnamed register is set to what just happened\n        this.unnamedRegister.setText(text, linewise, blockwise);\n        return;\n      }\n\n      // If we've gotten to this point, we've actually specified a register\n      var append = isUpperCase(registerName);\n      if (append) {\n        register.pushText(text, linewise);\n      } else {\n        register.setText(text, linewise, blockwise);\n      }\n      if (registerName === '+') {\n        navigator.clipboard.writeText(text);\n      }\n      // The unnamed register always has the same value as the last used\n      // register.\n      this.unnamedRegister.setText(register.toString(), linewise);\n    }\n    /**\n     * Gets the register named @name.  If one of @name doesn't already exist,\n     * create it.  If @name is invalid, return the unnamedRegister.\n     * @arg {string} [name]\n     */\n    getRegister(name) {\n      if (!this.isValidRegister(name)) {\n        return this.unnamedRegister;\n      }\n      name = name.toLowerCase();\n      if (!this.registers[name]) {\n        this.registers[name] = new Register();\n      }\n      return this.registers[name];\n    }\n    /**@type {{(name: any): name is string}} */\n    isValidRegister(name) {\n      return name && (inArray(name, validRegisters) || latinCharRegex.test(name));\n    }\n    shiftNumericRegisters_() {\n      for (var i = 9; i >= 2; i--) {\n        this.registers[i] = this.getRegister('' + (i - 1));\n      }\n    }\n  }\n  class HistoryController {\n    constructor() {\n      /**@type {string[]} */\n      this.historyBuffer = [];\n      this.iterator = 0;\n      this.initialPrefix = null;\n    }\n    /**\n     * the input argument here acts a user entered prefix for a small time\n     * until we start autocompletion in which case it is the autocompleted.\n     * @arg {string} input\n     * @arg {boolean} up\n     */\n    nextMatch(input, up) {\n      var historyBuffer = this.historyBuffer;\n      var dir = up ? -1 : 1;\n      if (this.initialPrefix === null) this.initialPrefix = input;\n      for (var i = this.iterator + dir; up ? i >= 0 : i < historyBuffer.length; i += dir) {\n        var element = historyBuffer[i];\n        for (var j = 0; j <= element.length; j++) {\n          if (this.initialPrefix == element.substring(0, j)) {\n            this.iterator = i;\n            return element;\n          }\n        }\n      }\n      // should return the user input in case we reach the end of buffer.\n      if (i >= historyBuffer.length) {\n        this.iterator = historyBuffer.length;\n        return this.initialPrefix;\n      }\n      // return the last autocompleted query or exCommand as it is.\n      if (i < 0) return input;\n    }\n    /** @arg {string} input */\n    pushInput(input) {\n      var index = this.historyBuffer.indexOf(input);\n      if (index > -1) this.historyBuffer.splice(index, 1);\n      if (input.length) this.historyBuffer.push(input);\n    }\n    reset() {\n      this.initialPrefix = null;\n      this.iterator = this.historyBuffer.length;\n    }\n  }\n  var commandDispatcher = {\n    /**\n     * @param {string} keys\n     * @param {vimKey[]} keyMap\n     * @param {InputStateInterface} inputState\n     * @param {string} context\n     */\n    matchCommand: function(keys, keyMap, inputState, context) {\n      var matches = commandMatches(keys, keyMap, context, inputState);\n      var bestMatch = matches.full[0];\n      if (!bestMatch) {\n        if (matches.partial.length) {\n          return {\n            type: 'partial',\n            expectLiteralNext: matches.partial.length == 1 && matches.partial[0].keys.slice(-11) == '<character>' // langmap literal logic\n          };\n        }\n        return {type: 'none'};\n      }\n      if (bestMatch.keys.slice(-11) == '<character>' || bestMatch.keys.slice(-10) == '<register>') {\n        var character = lastChar(keys);\n        if (!character || character.length > 1) return {type: 'clear'};\n        inputState.selectedCharacter = character;\n      }\n      return {type: 'full', command: bestMatch};\n    },\n    /**\n     * @arg {CodeMirrorV} cm\n     * @arg {vimState} vim\n     * @arg {vimKey} command\n     */\n    processCommand: function(cm, vim, command) {\n      vim.inputState.repeatOverride = command.repeatOverride;\n      switch (command.type) {\n        case 'motion':\n          this.processMotion(cm, vim, command);\n          break;\n        case 'operator':\n          this.processOperator(cm, vim, command);\n          break;\n        case 'operatorMotion':\n          this.processOperatorMotion(cm, vim, command);\n          break;\n        case 'action':\n          this.processAction(cm, vim, command);\n          break;\n        case 'search':\n          this.processSearch(cm, vim, command);\n          break;\n        case 'ex':\n        case 'keyToEx':\n          this.processEx(cm, vim, command);\n          break;\n      }\n    },\n    /**\n     * @arg {CodeMirrorV} cm\n     * @arg {vimState} vim\n     * @arg {import(\"./types\").motionCommand|import(\"./types\").operatorMotionCommand} command\n     */\n    processMotion: function(cm, vim, command) {\n      vim.inputState.motion = command.motion;\n      vim.inputState.motionArgs = /**@type {MotionArgs}*/(copyArgs(command.motionArgs));\n      this.evalInput(cm, vim);\n    },\n    /**\n     * @arg {CodeMirrorV} cm\n     * @arg {vimState} vim\n     * @arg {import(\"./types\").operatorCommand|import(\"./types\").operatorMotionCommand} command\n     */\n    processOperator: function(cm, vim, command) {\n      var inputState = vim.inputState;\n      if (inputState.operator) {\n        if (inputState.operator == command.operator) {\n          // Typing an operator twice like 'dd' makes the operator operate\n          // linewise\n          inputState.motion = 'expandToLine';\n          inputState.motionArgs = { linewise: true, repeat: 1 };\n          this.evalInput(cm, vim);\n          return;\n        } else {\n          // 2 different operators in a row doesn't make sense.\n          clearInputState(cm);\n        }\n      }\n      inputState.operator = command.operator;\n      inputState.operatorArgs = copyArgs(command.operatorArgs);\n      if (command.keys.length > 1) {\n        inputState.operatorShortcut = command.keys;\n      }\n      if (command.exitVisualBlock) {\n          vim.visualBlock = false;\n          updateCmSelection(cm);\n      }\n      if (vim.visualMode) {\n        // Operating on a selection in visual mode. We don't need a motion.\n        this.evalInput(cm, vim);\n      }\n    },\n    /**\n     * @arg {CodeMirrorV} cm\n     * @arg {vimState} vim\n     * @arg {import(\"./types\").operatorMotionCommand} command\n     */\n    processOperatorMotion: function(cm, vim, command) {\n      var visualMode = vim.visualMode;\n      var operatorMotionArgs = copyArgs(command.operatorMotionArgs);\n      if (operatorMotionArgs) {\n        // Operator motions may have special behavior in visual mode.\n        if (visualMode && operatorMotionArgs.visualLine) {\n          vim.visualLine = true;\n        }\n      }\n      this.processOperator(cm, vim, command);\n      if (!visualMode) {\n        this.processMotion(cm, vim, command);\n      }\n    },\n    /**\n     * @arg {CodeMirrorV} cm\n     * @arg {vimState} vim\n     * @arg {import(\"./types\").actionCommand} command\n     */\n    processAction: function(cm, vim, command) {\n      var inputState = vim.inputState;\n      var repeat = inputState.getRepeat();\n      var repeatIsExplicit = !!repeat;\n      var actionArgs = /**@type {ActionArgs}*/(copyArgs(command.actionArgs) || {repeat: 1});\n      if (inputState.selectedCharacter) {\n        actionArgs.selectedCharacter = inputState.selectedCharacter;\n      }\n      // Actions may or may not have motions and operators. Do these first.\n      if (command.operator) {\n        // @ts-ignore\n        this.processOperator(cm, vim, command);\n      }\n      if (command.motion) {\n        // @ts-ignore\n        this.processMotion(cm, vim, command);\n      }\n      if (command.motion || command.operator) {\n        this.evalInput(cm, vim);\n      }\n      actionArgs.repeat = repeat || 1;\n      actionArgs.repeatIsExplicit = repeatIsExplicit;\n      actionArgs.registerName = inputState.registerName;\n      clearInputState(cm);\n      vim.lastMotion = null;\n      if (command.isEdit) {\n        this.recordLastEdit(vim, inputState, command);\n      }\n      actions[command.action](cm, actionArgs, vim);\n    },\n    /** @arg {CodeMirrorV} cm @arg {vimState} vim @arg {import(\"./types\").searchCommand} command*/\n    processSearch: function(cm, vim, command) {\n      if (!cm.getSearchCursor) {\n        // Search depends on SearchCursor.\n        return;\n      }\n      var forward = command.searchArgs.forward;\n      var wholeWordOnly = command.searchArgs.wholeWordOnly;\n      getSearchState(cm).setReversed(!forward);\n      var promptPrefix = (forward) ? '/' : '?';\n      var originalQuery = getSearchState(cm).getQuery();\n      var originalScrollPos = cm.getScrollInfo();\n      var lastQuery = \"\";\n      /** @arg {string} query  @arg {boolean} ignoreCase  @arg {boolean} smartCase */\n      function handleQuery(query, ignoreCase, smartCase) {\n        vimGlobalState.searchHistoryController.pushInput(query);\n        vimGlobalState.searchHistoryController.reset();\n        try {\n          updateSearchQuery(cm, query, ignoreCase, smartCase);\n        } catch (e) {\n          showConfirm(cm, 'Invalid regex: ' + query);\n          clearInputState(cm);\n          return;\n        }\n        commandDispatcher.processMotion(cm, vim, {\n          keys: '',\n          type: 'motion',\n          motion: 'findNext',\n          motionArgs: { forward: true, toJumplist: command.searchArgs.toJumplist }\n        });\n      }\n      /** @arg {string} query */\n      function onPromptClose(query) {\n        cm.scrollTo(originalScrollPos.left, originalScrollPos.top);\n        handleQuery(query, true /** ignoreCase */, true /** smartCase */);\n        var macroModeState = vimGlobalState.macroModeState;\n        if (macroModeState.isRecording) {\n          logSearchQuery(macroModeState, query);\n        }\n      }\n      function pcreLabel() {\n        return getOption('pcre') ? '(JavaScript regexp: set pcre)' : '(Vim regexp: set nopcre)'\n      }\n      /** \n       * @arg {KeyboardEvent&{target:HTMLInputElement}} e \n       * @arg {any} query \n       * @arg {(arg0: any) => void} close \n       */\n      function onPromptKeyUp(e, query, close) {\n        var keyName = vimKeyFromEvent(e), up, offset;\n        if (keyName == '<Up>' || keyName == '<Down>') {\n          up = keyName == '<Up>' ? true : false;\n          offset = e.target ? e.target.selectionEnd : 0;\n          query = vimGlobalState.searchHistoryController.nextMatch(query, up) || '';\n          close(query);\n          if (offset && e.target) e.target.selectionEnd = e.target.selectionStart = Math.min(offset, e.target.value.length);\n        } else if (keyName && keyName != '<Left>' && keyName != '<Right>') {\n          vimGlobalState.searchHistoryController.reset();\n        }\n        lastQuery = query;\n        onChange();\n      }\n      function onChange() {\n        var parsedQuery;\n        try {\n          parsedQuery = updateSearchQuery(cm, lastQuery,\n              true /** ignoreCase */, true /** smartCase */);\n        } catch (e) {\n          // Swallow bad regexes for incremental search.\n        }\n        if (parsedQuery) {\n          cm.scrollIntoView(findNext(cm, !forward, parsedQuery), 30);\n        } else {\n          clearSearchHighlight(cm);\n          cm.scrollTo(originalScrollPos.left, originalScrollPos.top);\n        }\n      }\n      /** @arg {KeyboardEvent} e  @arg {string} query  @arg {(arg0?: string) => void} close */\n      function onPromptKeyDown(e, query, close) {\n        var keyName = vimKeyFromEvent(e);\n        if (keyName == '<Esc>' || keyName == '<C-c>' || keyName == '<C-[>' ||\n            (keyName == '<BS>' && query == '')) {\n          vimGlobalState.searchHistoryController.pushInput(query);\n          vimGlobalState.searchHistoryController.reset();\n          updateSearchQuery(cm, originalQuery?.source || \"\");\n          clearSearchHighlight(cm);\n          cm.scrollTo(originalScrollPos.left, originalScrollPos.top);\n          CM.e_stop(e);\n          clearInputState(cm);\n          close();\n          cm.focus();\n        } else if (keyName == '<Up>' || keyName == '<Down>') {\n          CM.e_stop(e);\n        } else if (keyName == '<C-u>') {\n          // Ctrl-U clears input.\n          CM.e_stop(e);\n          close('');\n        }\n      }\n      switch (command.searchArgs.querySrc) {\n        case 'prompt':\n          var macroModeState = vimGlobalState.macroModeState;\n          if (macroModeState.isPlaying) {\n            let query = macroModeState.replaySearchQueries.shift();\n            handleQuery(query || '', true /** ignoreCase */, false /** smartCase */);\n          } else {\n            showPrompt(cm, {\n                onClose: onPromptClose,\n                prefix: promptPrefix,\n                desc: dom(\n                  'span',\n                  {\n                    $cursor: 'pointer', \n                    onmousedown: function(/** @type {MouseEvent} */ e) {\n                      e.preventDefault();\n                      setOption('pcre', !getOption('pcre'));\n                      this.textContent = pcreLabel();\n                      onChange();\n                    }\n                  },\n                  pcreLabel()\n                ),  \n                onKeyUp: onPromptKeyUp,\n                onKeyDown: onPromptKeyDown\n            });\n          }\n          break;\n        case 'wordUnderCursor':\n          var word = expandWordUnderCursor(cm, {noSymbol: true});\n          var isKeyword = true;\n          if (!word) {\n            word = expandWordUnderCursor(cm, {noSymbol: false});\n            isKeyword = false;\n          }\n          if (!word) {\n            showConfirm(cm, 'No word under cursor');\n            clearInputState(cm);\n            return;\n          }\n          let query = cm.getLine(word.start.line).substring(word.start.ch,\n              word.end.ch);\n          if (isKeyword && wholeWordOnly) {\n              query = '\\\\b' + query + '\\\\b';\n          } else {\n            query = escapeRegex(query);\n          }\n\n          // cachedCursor is used to save the old position of the cursor\n          // when * or # causes vim to seek for the nearest word and shift\n          // the cursor before entering the motion.\n          vimGlobalState.jumpList.cachedCursor = cm.getCursor();\n          cm.setCursor(word.start);\n\n          handleQuery(query, true /** ignoreCase */, false /** smartCase */);\n          break;\n      }\n    },\n    /**\n     * @arg {CodeMirrorV} cm\n     * @arg {vimState} vim\n     * @arg {import(\"./types\").exCommand | import(\"./types\").keyToExCommand} command\n     */\n    processEx: function(cm, vim, command) {\n      /**@arg {string} input*/\n      function onPromptClose(input) {\n        // Give the prompt some time to close so that if processCommand shows\n        // an error, the elements don't overlap.\n        vimGlobalState.exCommandHistoryController.pushInput(input);\n        vimGlobalState.exCommandHistoryController.reset();\n        exCommandDispatcher.processCommand(cm, input);\n        if (cm.state.vim) clearInputState(cm);\n        clearSearchHighlight(cm);\n      }\n      /**\n       * @arg {KeyboardEvent&{target:HTMLInputElement}} e\n       * @arg {string} input\n       * @arg {(arg0?: string) => void} close\n       */\n      function onPromptKeyDown(e, input, close) {\n        var keyName = vimKeyFromEvent(e), up, offset;\n        if (keyName == '<Esc>' || keyName == '<C-c>' || keyName == '<C-[>' ||\n            (keyName == '<BS>' && input == '')) {\n          vimGlobalState.exCommandHistoryController.pushInput(input);\n          vimGlobalState.exCommandHistoryController.reset();\n          CM.e_stop(e);\n          clearInputState(cm);\n          clearSearchHighlight(cm);\n          close();\n          cm.focus();\n        }\n        if (keyName == '<Up>' || keyName == '<Down>') {\n          CM.e_stop(e);\n          up = keyName == '<Up>' ? true : false;\n          offset = e.target ? e.target.selectionEnd : 0;\n          input = vimGlobalState.exCommandHistoryController.nextMatch(input, up) || '';\n          close(input);\n          if (offset && e.target) e.target.selectionEnd = e.target.selectionStart = Math.min(offset, e.target.value.length);\n        } else if (keyName == '<C-u>') {\n          // Ctrl-U clears input.\n          CM.e_stop(e);\n          close('');\n        } else if (keyName && keyName != '<Left>' && keyName != '<Right>') {\n            vimGlobalState.exCommandHistoryController.reset();\n        }\n      }\n      /**\n       * @arg {KeyboardEvent&{target:HTMLInputElement}} e\n       * @arg {any} query\n       */\n      function onPromptKeyUp(e, query) {\n        var inputStream = new CM.StringStream(query);\n        var params = /**@type{import(\"./types\").exCommandArgs}*/({});\n        try {\n          exCommandDispatcher.parseInput_(cm, inputStream, params);\n          if (params.commandName != \"s\") {\n            clearSearchHighlight(cm);\n            return;\n          }\n          var command = exCommandDispatcher.matchCommand_(params.commandName);\n          if (!command) return;\n          exCommandDispatcher.parseCommandArgs_(inputStream, params, command);\n          if (!params.argString) return;\n          var regex = parseQuery(params.argString.slice(1), true, true);\n          if (regex) highlightSearchMatches(cm, regex);\n        } catch(e) {\n        }\n      }\n      if (command.type == 'keyToEx') {\n        // Handle user defined Ex to Ex mappings\n        exCommandDispatcher.processCommand(cm, command.exArgs.input);\n      } else {\n        /**@type{import(\"./types\").PromptOptions} */\n        var promptOptions = {\n          onClose: onPromptClose,\n          onKeyDown: onPromptKeyDown,\n          onKeyUp: onPromptKeyUp,\n          prefix: ':',\n        };\n        if (vim.visualMode) {\n          promptOptions.value = '\\'<,\\'>';\n          promptOptions.selectValueOnOpen = false;\n        }\n        showPrompt(cm, promptOptions);\n      }\n    },\n    /**@arg {CodeMirrorV} cm   @arg {vimState} vim */\n    evalInput: function(cm, vim) {\n      // If the motion command is set, execute both the operator and motion.\n      // Otherwise return.\n      var inputState = vim.inputState;\n      var motion = inputState.motion;\n      /** @type {MotionArgs}*/\n      var motionArgs = inputState.motionArgs || { repeat: 1};\n      var operator = inputState.operator;\n      /** @type {OperatorArgs}*/\n      var operatorArgs = inputState.operatorArgs || {};\n      var registerName = inputState.registerName;\n      var sel = vim.sel;\n      // TODO: Make sure cm and vim selections are identical outside visual mode.\n      var origHead = copyCursor(vim.visualMode ? clipCursorToContent(cm, sel.head): cm.getCursor('head'));\n      var origAnchor = copyCursor(vim.visualMode ? clipCursorToContent(cm, sel.anchor) : cm.getCursor('anchor'));\n      var oldHead = copyCursor(origHead);\n      var oldAnchor = copyCursor(origAnchor);\n      var newHead, newAnchor;\n      var repeat;\n      if (operator) {\n        this.recordLastEdit(vim, inputState);\n      }\n      if (inputState.repeatOverride !== undefined) {\n        // If repeatOverride is specified, that takes precedence over the\n        // input state's repeat. Used by Ex mode and can be user defined.\n        repeat = inputState.repeatOverride;\n      } else {\n        repeat = inputState.getRepeat();\n      }\n      if (repeat > 0 && motionArgs.explicitRepeat) {\n        motionArgs.repeatIsExplicit = true;\n      } else if (motionArgs.noRepeat ||\n          (!motionArgs.explicitRepeat && repeat === 0)) {\n        repeat = 1;\n        motionArgs.repeatIsExplicit = false;\n      }\n      if (inputState.selectedCharacter) {\n        // If there is a character input, stick it in all of the arg arrays.\n        motionArgs.selectedCharacter = operatorArgs.selectedCharacter =\n            inputState.selectedCharacter;\n      }\n      motionArgs.repeat = repeat;\n      clearInputState(cm);\n      if (motion) {\n        var motionResult = motions[motion](cm, origHead, motionArgs, vim, inputState);\n        vim.lastMotion = motions[motion];\n        if (!motionResult) {\n          return;\n        }\n        if (motionArgs.toJumplist) {\n          var jumpList = vimGlobalState.jumpList;\n          // if the current motion is # or *, use cachedCursor\n          var cachedCursor = jumpList.cachedCursor;\n          if (cachedCursor) {\n            // @ts-ignore\n            recordJumpPosition(cm, cachedCursor, motionResult);\n            delete jumpList.cachedCursor;\n          } else {\n            // @ts-ignore\n            recordJumpPosition(cm, origHead, motionResult);\n          }\n        }\n        if (motionResult instanceof Array) {\n          newAnchor = motionResult[0];\n          newHead = motionResult[1];\n        } else {\n          newHead = motionResult;\n        }\n        // TODO: Handle null returns from motion commands better.\n        if (!newHead) {\n          newHead = copyCursor(origHead);\n        }\n        if (vim.visualMode) {\n          if (!(vim.visualBlock && newHead.ch === Infinity)) {\n            newHead = clipCursorToContent(cm, newHead, oldHead);\n          }\n          if (newAnchor) {\n            newAnchor = clipCursorToContent(cm, newAnchor);\n          }\n          newAnchor = newAnchor || oldAnchor;\n          sel.anchor = newAnchor;\n          sel.head = newHead;\n          updateCmSelection(cm);\n          updateMark(cm, vim, '<',\n              cursorIsBefore(newAnchor, newHead) ? newAnchor\n                  : newHead);\n          updateMark(cm, vim, '>',\n              cursorIsBefore(newAnchor, newHead) ? newHead\n                  : newAnchor);\n        } else if (!operator) {\n          newHead = clipCursorToContent(cm, newHead, oldHead);\n          cm.setCursor(newHead.line, newHead.ch);\n        }\n      }\n      if (operator) {\n        if (operatorArgs.lastSel) {\n          // Replaying a visual mode operation\n          newAnchor = oldAnchor;\n          var lastSel = operatorArgs.lastSel;\n          var lineOffset = Math.abs(lastSel.head.line - lastSel.anchor.line);\n          var chOffset = Math.abs(lastSel.head.ch - lastSel.anchor.ch);\n          if (lastSel.visualLine) {\n            // Linewise Visual mode: The same number of lines.\n            newHead = new Pos(oldAnchor.line + lineOffset, oldAnchor.ch);\n          } else if (lastSel.visualBlock) {\n            // Blockwise Visual mode: The same number of lines and columns.\n            newHead = new Pos(oldAnchor.line + lineOffset, oldAnchor.ch + chOffset);\n          } else if (lastSel.head.line == lastSel.anchor.line) {\n            // Normal Visual mode within one line: The same number of characters.\n            newHead = new Pos(oldAnchor.line, oldAnchor.ch + chOffset);\n          } else {\n            // Normal Visual mode with several lines: The same number of lines, in the\n            // last line the same number of characters as in the last line the last time.\n            newHead = new Pos(oldAnchor.line + lineOffset, oldAnchor.ch);\n          }\n          vim.visualMode = true;\n          vim.visualLine = lastSel.visualLine;\n          vim.visualBlock = lastSel.visualBlock;\n          sel = vim.sel = {\n            anchor: newAnchor,\n            head: newHead\n          };\n          updateCmSelection(cm);\n        } else if (vim.visualMode) {\n          operatorArgs.lastSel = {\n            anchor: copyCursor(sel.anchor),\n            head: copyCursor(sel.head),\n            visualBlock: vim.visualBlock,\n            visualLine: vim.visualLine\n          };\n        }\n        var curStart, curEnd, linewise;\n        /** @type {'block'|'line'|'char'}*/ var mode;\n        var cmSel;\n        if (vim.visualMode) {\n          // Init visual op\n          curStart = cursorMin(sel.head, sel.anchor);\n          curEnd = cursorMax(sel.head, sel.anchor);\n          linewise = vim.visualLine || operatorArgs.linewise;\n          mode = vim.visualBlock ? 'block' :\n                  linewise ? 'line' :\n                  'char';\n          var newPositions = updateSelectionForSurrogateCharacters(cm, curStart, curEnd);\n          cmSel = makeCmSelection(cm, {\n            anchor: newPositions.start,\n            head: newPositions.end\n          }, mode);\n          if (linewise) {\n            var ranges = cmSel.ranges;\n            if (mode == 'block') {\n              // Linewise operators in visual block mode extend to end of line\n              for (var i = 0; i < ranges.length; i++) {\n                ranges[i].head.ch = lineLength(cm, ranges[i].head.line);\n              }\n            } else if (mode == 'line') {\n              ranges[0].head = new Pos(ranges[0].head.line + 1, 0);\n            }\n          }\n        } else {\n          // Init motion op\n          curStart = copyCursor(newAnchor || oldAnchor);\n          curEnd = copyCursor(newHead || oldHead);\n          if (cursorIsBefore(curEnd, curStart)) {\n            var tmp = curStart;\n            curStart = curEnd;\n            curEnd = tmp;\n          }\n          linewise = motionArgs.linewise || operatorArgs.linewise;\n          if (linewise) {\n            // Expand selection to entire line.\n            expandSelectionToLine(cm, curStart, curEnd);\n          } else if (motionArgs.forward) {\n            // Clip to trailing newlines only if the motion goes forward.\n            clipToLine(cm, curStart, curEnd);\n          }\n          mode = 'char';\n          var exclusive = !motionArgs.inclusive || linewise;\n          var newPositions = updateSelectionForSurrogateCharacters(cm, curStart, curEnd);\n          cmSel = makeCmSelection(cm, {\n            anchor: newPositions.start,\n            head: newPositions.end\n          }, mode, exclusive);\n        }\n        cm.setSelections(cmSel.ranges, cmSel.primary);\n        vim.lastMotion = null;\n        operatorArgs.repeat = repeat; // For indent in visual mode.\n        operatorArgs.registerName = registerName;\n        // Keep track of linewise as it affects how paste and change behave.\n        operatorArgs.linewise = linewise;\n        var operatorMoveTo = operators[operator](\n          cm, operatorArgs, cmSel.ranges, oldAnchor, newHead);\n        if (vim.visualMode) {\n          exitVisualMode(cm, operatorMoveTo != null);\n        }\n        if (operatorMoveTo) {\n          cm.setCursor(operatorMoveTo);\n        }\n      }\n    },\n    /**@arg {vimState} vim  @arg {InputStateInterface} inputState, @arg {import(\"./types\").actionCommand} [actionCommand] */\n    recordLastEdit: function(vim, inputState, actionCommand) {\n      var macroModeState = vimGlobalState.macroModeState;\n      if (macroModeState.isPlaying) { return; }\n      vim.lastEditInputState = inputState;\n      vim.lastEditActionCommand = actionCommand;\n      macroModeState.lastInsertModeChanges.changes = [];\n      macroModeState.lastInsertModeChanges.expectCursorActivityForChange = false;\n      macroModeState.lastInsertModeChanges.visualBlock = vim.visualBlock ? vim.sel.head.line - vim.sel.anchor.line : 0;\n    }\n  };\n\n  /**\n   * All of the functions below return Cursor objects.\n   * @type {import(\"./types\").vimMotions}}\n   */\n  var motions = {\n    moveToTopLine: function(cm, _head, motionArgs) {\n      var line = getUserVisibleLines(cm).top + motionArgs.repeat -1;\n      return new Pos(line, findFirstNonWhiteSpaceCharacter(cm.getLine(line)));\n    },\n    moveToMiddleLine: function(cm) {\n      var range = getUserVisibleLines(cm);\n      var line = Math.floor((range.top + range.bottom) * 0.5);\n      return new Pos(line, findFirstNonWhiteSpaceCharacter(cm.getLine(line)));\n    },\n    moveToBottomLine: function(cm, _head, motionArgs) {\n      var line = getUserVisibleLines(cm).bottom - motionArgs.repeat +1;\n      return new Pos(line, findFirstNonWhiteSpaceCharacter(cm.getLine(line)));\n    },\n    expandToLine: function(_cm, head, motionArgs) {\n      // Expands forward to end of line, and then to next line if repeat is\n      // >1. Does not handle backward motion!\n      var cur = head;\n      return new Pos(cur.line + motionArgs.repeat - 1, Infinity);\n    },\n    findNext: function(cm, _head, motionArgs) {\n      var state = getSearchState(cm);\n      var query = state.getQuery();\n      if (!query) {\n        return;\n      }\n      var prev = !motionArgs.forward;\n      // If search is initiated with ? instead of /, negate direction.\n      prev = (state.isReversed()) ? !prev : prev;\n      highlightSearchMatches(cm, query);\n      var result = findNext(cm, prev/** prev */, query, motionArgs.repeat);\n      if (!result) {\n        showConfirm(cm, 'No match found ' + query +\n          (getOption('pcre') ? ' (set nopcre to use Vim regexps)' : ''));\n      }\n      return result; \n    },\n    /**\n     * Find and select the next occurrence of the search query. If the cursor is currently\n     * within a match, then find and select the current match. Otherwise, find the next occurrence in the\n     * appropriate direction.\n     *\n     * This differs from `findNext` in the following ways:\n     *\n     * 1. Instead of only returning the \"from\", this returns a \"from\", \"to\" range.\n     * 2. If the cursor is currently inside a search match, this selects the current match\n     *    instead of the next match.\n     * 3. If there is no associated operator, this will turn on visual mode.\n     */\n    findAndSelectNextInclusive: function(cm, _head, motionArgs, vim, prevInputState) {\n      var state = getSearchState(cm);\n      var query = state.getQuery();\n\n      if (!query) {\n        return;\n      }\n\n      var prev = !motionArgs.forward;\n      prev = (state.isReversed()) ? !prev : prev;\n\n      // next: [from, to] | null\n      var next = findNextFromAndToInclusive(cm, prev, query, motionArgs.repeat, vim);\n\n      // No matches.\n      if (!next) {\n        return;\n      }\n\n      // If there's an operator that will be executed, return the selection.\n      if (prevInputState.operator) {\n        return next;\n      }\n\n      // At this point, we know that there is no accompanying operator -- let's\n      // deal with visual mode in order to select an appropriate match.\n\n      var from = next[0];\n      // For whatever reason, when we use the \"to\" as returned by searchcursor.js directly,\n      // the resulting selection is extended by 1 char. Let's shrink it so that only the\n      // match is selected.\n      var to = new Pos(next[1].line, next[1].ch - 1);\n\n      if (vim.visualMode) {\n        // If we were in visualLine or visualBlock mode, get out of it.\n        if (vim.visualLine || vim.visualBlock) {\n          vim.visualLine = false;\n          vim.visualBlock = false;\n          CM.signal(cm, \"vim-mode-change\", {mode: \"visual\", subMode: \"\"});\n        }\n\n        // If we're currently in visual mode, we should extend the selection to include\n        // the search result.\n        var anchor = vim.sel.anchor;\n        if (anchor) {\n          if (state.isReversed()) {\n            if (motionArgs.forward) {\n              return [anchor, from];\n            }\n\n            return [anchor, to];\n          } else {\n            if (motionArgs.forward) {\n              return [anchor, to];\n            }\n\n            return [anchor, from];\n          }\n        }\n      } else {\n        // Let's turn visual mode on.\n        vim.visualMode = true;\n        vim.visualLine = false;\n        vim.visualBlock = false;\n        CM.signal(cm, \"vim-mode-change\", {mode: \"visual\", subMode: \"\"});\n      }\n\n      return prev ? [to, from] : [from, to];\n    },\n    goToMark: function(cm, _head, motionArgs, vim) {\n      var pos = getMarkPos(cm, vim, motionArgs.selectedCharacter || \"\");\n      if (pos) {\n        return motionArgs.linewise ? { line: pos.line, ch: findFirstNonWhiteSpaceCharacter(cm.getLine(pos.line)) } : pos;\n      }\n      return null;\n    },\n    moveToOtherHighlightedEnd: function(cm, _head, motionArgs, vim) {\n      var sel = vim.sel;\n      if (vim.visualBlock && motionArgs.sameLine) {\n        return [\n          clipCursorToContent(cm, new Pos(sel.anchor.line, sel.head.ch)),\n          clipCursorToContent(cm, new Pos(sel.head.line, sel.anchor.ch))\n        ];\n      } else {\n        return ([sel.head, sel.anchor]);\n      }\n    },\n    jumpToMark: function(cm, head, motionArgs, vim) {\n      var best = head;\n      for (var i = 0; i < motionArgs.repeat; i++) {\n        var cursor = best;\n        for (var key in vim.marks) {\n          if (!isLowerCase(key)) {\n            continue;\n          }\n          var mark = vim.marks[key].find();\n          var isWrongDirection = (motionArgs.forward) ?\n            // @ts-ignore\n            cursorIsBefore(mark, cursor) : cursorIsBefore(cursor, mark);\n\n          if (isWrongDirection) {\n            continue;\n          }\n          // @ts-ignore\n          if (motionArgs.linewise && (mark.line == cursor.line)) {\n            continue;\n          }\n\n          var equal = cursorEqual(cursor, best);\n          var between = (motionArgs.forward) ?\n            // @ts-ignore\n            cursorIsBetween(cursor, mark, best) :\n            // @ts-ignore\n            cursorIsBetween(best, mark, cursor);\n\n          if (equal || between) {\n            // @ts-ignore\n            best = mark;\n          }\n        }\n      }\n\n      if (motionArgs.linewise) {\n        // Vim places the cursor on the first non-whitespace character of\n        // the line if there is one, else it places the cursor at the end\n        // of the line, regardless of whether a mark was found.\n        best = new Pos(best.line, findFirstNonWhiteSpaceCharacter(cm.getLine(best.line)));\n      }\n      return best;\n    },\n    moveByCharacters: function(_cm, head, motionArgs) {\n      var cur = head;\n      var repeat = motionArgs.repeat;\n      var ch = motionArgs.forward ? cur.ch + repeat : cur.ch - repeat;\n      return new Pos(cur.line, ch);\n    },\n    moveByLines: function(cm, head, motionArgs, vim) {\n      var cur = head;\n      var endCh = cur.ch;\n      // Depending what our last motion was, we may want to do different\n      // things. If our last motion was moving vertically, we want to\n      // preserve the HPos from our last horizontal move.  If our last motion\n      // was going to the end of a line, moving vertically we should go to\n      // the end of the line, etc.\n      switch (vim.lastMotion) {\n        case this.moveByLines:\n        case this.moveByDisplayLines:\n        case this.moveByScroll:\n        case this.moveToColumn:\n        case this.moveToEol:\n          endCh = vim.lastHPos;\n          break;\n        default:\n          vim.lastHPos = endCh;\n      }\n      var repeat = motionArgs.repeat+(motionArgs.repeatOffset||0);\n      var line = motionArgs.forward ? cur.line + repeat : cur.line - repeat;\n      var first = cm.firstLine();\n      var last = cm.lastLine();\n      var posV = cm.findPosV(cur, (motionArgs.forward ? repeat : -repeat), 'line', vim.lastHSPos);\n      var hasMarkedText = motionArgs.forward ? posV.line > line : posV.line < line;\n      if (hasMarkedText) {\n        line = posV.line;\n        endCh = posV.ch;\n      }\n      // Vim go to line begin or line end when cursor at first/last line and\n      // move to previous/next line is triggered.\n      if (line < first && cur.line == first){\n        return this.moveToStartOfLine(cm, head, motionArgs, vim);\n      } else if (line > last && cur.line == last){\n          return moveToEol(cm, head, motionArgs, vim, true);\n      }\n      if (motionArgs.toFirstChar){\n        endCh=findFirstNonWhiteSpaceCharacter(cm.getLine(line));\n        vim.lastHPos = endCh;\n      }\n      vim.lastHSPos = cm.charCoords(new Pos(line, endCh),'div').left;\n      return new Pos(line, endCh);\n    },\n    moveByDisplayLines: function(cm, head, motionArgs, vim) {\n      var cur = head;\n      switch (vim.lastMotion) {\n        case this.moveByDisplayLines:\n        case this.moveByScroll:\n        case this.moveByLines:\n        case this.moveToColumn:\n        case this.moveToEol:\n          break;\n        default:\n          vim.lastHSPos = cm.charCoords(cur,'div').left;\n      }\n      var repeat = motionArgs.repeat;\n      var res=cm.findPosV(cur,(motionArgs.forward ? repeat : -repeat),'line',vim.lastHSPos);\n      if (res.hitSide) {\n        if (motionArgs.forward) {\n          var lastCharCoords = cm.charCoords(res, 'div');\n          var goalCoords = { top: lastCharCoords.top + 8, left: vim.lastHSPos };\n          res = cm.coordsChar(goalCoords, 'div');\n        } else {\n          var resCoords = cm.charCoords(new Pos(cm.firstLine(), 0), 'div');\n          resCoords.left = vim.lastHSPos;\n          res = cm.coordsChar(resCoords, 'div');\n        }\n      }\n      vim.lastHPos = res.ch;\n      return res;\n    },\n    moveByPage: function(cm, head, motionArgs) {\n      // CodeMirror only exposes functions that move the cursor page down, so\n      // doing this bad hack to move the cursor and move it back. evalInput\n      // will move the cursor to where it should be in the end.\n      var curStart = head;\n      var repeat = motionArgs.repeat;\n      return cm.findPosV(curStart, (motionArgs.forward ? repeat : -repeat), 'page');\n    },\n    moveByParagraph: function(cm, head, motionArgs) {\n      var dir = motionArgs.forward ? 1 : -1;\n      return findParagraph(cm, head, motionArgs.repeat, dir).start;\n    },\n    moveBySentence: function(cm, head, motionArgs) {\n      var dir = motionArgs.forward ? 1 : -1;\n      return findSentence(cm, head, motionArgs.repeat, dir);\n    },\n    moveByScroll: function(cm, head, motionArgs, vim) {\n      var scrollbox = cm.getScrollInfo();\n      var curEnd = null;\n      var repeat = motionArgs.repeat;\n      if (!repeat) {\n        repeat = scrollbox.clientHeight / (2 * cm.defaultTextHeight());\n      }\n      var orig = cm.charCoords(head, 'local');\n      motionArgs.repeat = repeat;\n      curEnd = motions.moveByDisplayLines(cm, head, motionArgs, vim);\n      if (!curEnd) {\n        return null;\n      }\n      var dest = cm.charCoords(curEnd, 'local');\n      cm.scrollTo(null, scrollbox.top + dest.top - orig.top);\n      return curEnd;\n    },\n    moveByWords: function(cm, head, motionArgs) {\n      return moveToWord(cm, head, motionArgs.repeat, !!motionArgs.forward,\n          !!motionArgs.wordEnd, !!motionArgs.bigWord);\n    },\n    moveTillCharacter: function(cm, head, motionArgs) {\n      var repeat = motionArgs.repeat;\n      var curEnd = moveToCharacter(cm, repeat, motionArgs.forward,\n          motionArgs.selectedCharacter, head);\n      var increment = motionArgs.forward ? -1 : 1;\n      recordLastCharacterSearch(increment, motionArgs);\n      if (!curEnd) return null;\n      curEnd.ch += increment;\n      return curEnd;\n    },\n    moveToCharacter: function(cm, head, motionArgs) {\n      var repeat = motionArgs.repeat;\n      recordLastCharacterSearch(0, motionArgs);\n      return moveToCharacter(cm, repeat, motionArgs.forward,\n          motionArgs.selectedCharacter, head) || head;\n    },\n    moveToSymbol: function(cm, head, motionArgs) {\n      var repeat = motionArgs.repeat;\n      return motionArgs.selectedCharacter\n       && findSymbol(cm, repeat, motionArgs.forward,\n          motionArgs.selectedCharacter) || head;\n    },\n    moveToColumn: function(cm, head, motionArgs, vim) {\n      var repeat = motionArgs.repeat;\n      // repeat is equivalent to which column we want to move to!\n      vim.lastHPos = repeat - 1;\n      vim.lastHSPos = cm.charCoords(head,'div').left;\n      return moveToColumn(cm, repeat);\n    },\n    moveToEol: function(cm, head, motionArgs, vim) {\n      return moveToEol(cm, head, motionArgs, vim, false);\n    },\n    moveToFirstNonWhiteSpaceCharacter: function(cm, head) {\n      // Go to the start of the line where the text begins, or the end for\n      // whitespace-only lines\n      var cursor = head;\n      return new Pos(cursor.line,\n                  findFirstNonWhiteSpaceCharacter(cm.getLine(cursor.line)));\n    },\n    moveToMatchedSymbol: function(cm, head) {\n      var cursor = head;\n      var line = cursor.line;\n      var ch = cursor.ch;\n      var lineText = cm.getLine(line);\n      var symbol;\n      for (; ch < lineText.length; ch++) {\n        symbol = lineText.charAt(ch);\n        if (symbol && isMatchableSymbol(symbol)) {\n          var style = cm.getTokenTypeAt(new Pos(line, ch + 1));\n          if (style !== \"string\" && style !== \"comment\") {\n            break;\n          }\n        }\n      }\n      if (ch < lineText.length) {\n        // Only include angle brackets in analysis if they are being matched.\n        var re = (symbol === '<' || symbol === '>') ? /[(){}[\\]<>]/ : /[(){}[\\]]/;\n        var matched = cm.findMatchingBracket(new Pos(line, ch), {bracketRegex: re});\n        return matched.to;\n      } else {\n        return cursor;\n      }\n    },\n    moveToStartOfLine: function(_cm, head) {\n      return new Pos(head.line, 0);\n    },\n    moveToLineOrEdgeOfDocument: function(cm, _head, motionArgs) {\n      var lineNum = motionArgs.forward ? cm.lastLine() : cm.firstLine();\n      if (motionArgs.repeatIsExplicit) {\n        lineNum = motionArgs.repeat - cm.getOption('firstLineNumber');\n      }\n      return new Pos(lineNum,\n                  findFirstNonWhiteSpaceCharacter(cm.getLine(lineNum)));\n    },\n    moveToStartOfDisplayLine: function(cm) {\n      cm.execCommand(\"goLineLeft\");\n      return cm.getCursor();\n    },\n    moveToEndOfDisplayLine: function(cm) {\n      cm.execCommand(\"goLineRight\");\n      var head = cm.getCursor();\n      if (head.sticky == \"before\") head.ch--;\n      return head;\n    },\n    textObjectManipulation: function(cm, head, motionArgs, vim) {\n      // TODO: lots of possible exceptions that can be thrown here. Try da(\n      //     outside of a () block.\n      /** @type{Object<string, string>} */\n      var mirroredPairs = {'(': ')', ')': '(',\n                            '{': '}', '}': '{',\n                            '[': ']', ']': '[',\n                            '<': '>', '>': '<'};\n      /** @type{Object<string, boolean>} */\n      var selfPaired = {'\\'': true, '\"': true, '`': true};\n\n      var character = motionArgs.selectedCharacter || \"\";\n      // 'b' refers to  '()' block.\n      // 'B' refers to  '{}' block.\n      if (character == 'b') {\n        character = '(';\n      } else if (character == 'B') {\n        character = '{';\n      }\n\n      // Inclusive is the difference between a and i\n      // TODO: Instead of using the additional text object map to perform text\n      //     object operations, merge the map into the defaultKeyMap and use\n      //     motionArgs to define behavior. Define separate entries for 'aw',\n      //     'iw', 'a[', 'i[', etc.\n      var inclusive = !motionArgs.textObjectInner;\n\n      var tmp, move;\n      if (mirroredPairs[character]) {\n        move = true;\n        tmp = selectCompanionObject(cm, head, character, inclusive);\n        if (!tmp) {\n          var sc = cm.getSearchCursor(new RegExp(\"\\\\\" + character, \"g\"), head);\n          if (sc.find()) {\n            // @ts-ignore\n            tmp = selectCompanionObject(cm, sc.from(), character, inclusive);\n          }\n        }\n      } else if (selfPaired[character]) {\n        move = true;\n        tmp = findBeginningAndEnd(cm, head, character, inclusive);\n      } else if (character === 'W' || character === 'w') {\n        var repeat = motionArgs.repeat || 1;\n        while (repeat-- > 0) {\n          var repeated = expandWordUnderCursor(cm, {\n            inclusive,\n            innerWord: !inclusive,\n            bigWord: character === 'W',\n            noSymbol: character === 'W',\n            multiline: true\n          }, tmp && tmp.end);\n          if (repeated) {\n            if (!tmp) tmp = repeated;\n            tmp.end = repeated.end;\n          }\n        }\n      } else if (character === 'p') {\n        tmp = findParagraph(cm, head, motionArgs.repeat, 0, inclusive);\n        motionArgs.linewise = true;\n        if (vim.visualMode) {\n          if (!vim.visualLine) { vim.visualLine = true; }\n        } else {\n          var operatorArgs = vim.inputState.operatorArgs;\n          if (operatorArgs) { operatorArgs.linewise = true; }\n          tmp.end.line--;\n        }\n      } else if (character === 't') {\n        tmp = expandTagUnderCursor(cm, head, inclusive);\n      } else if (character === 's') {\n        // account for cursor on end of sentence symbol\n        var content = cm.getLine(head.line);\n        if (head.ch > 0 && isEndOfSentenceSymbol(content[head.ch])) {\n          head.ch -= 1;\n        }\n        var end = getSentence(cm, head, motionArgs.repeat, 1, inclusive);\n        var start = getSentence(cm, head, motionArgs.repeat, -1, inclusive);\n        // closer vim behaviour, 'a' only takes the space after the sentence if there is one before and after\n        if (isWhiteSpaceString(cm.getLine(start.line)[start.ch])\n            && isWhiteSpaceString(cm.getLine(end.line)[end.ch -1])) {\n          start = {line: start.line, ch: start.ch + 1};\n        }\n        tmp = {start: start, end: end};\n      }\n\n      if (!tmp) {\n        // No valid text object, don't move.\n        return null;\n      }\n\n      if (!cm.state.vim.visualMode) {\n        return [tmp.start, tmp.end];\n      } else {\n        return expandSelection(cm, tmp.start, tmp.end, move);\n      }\n    },\n\n    repeatLastCharacterSearch: function(cm, head, motionArgs) {\n      var lastSearch = vimGlobalState.lastCharacterSearch;\n      var repeat = motionArgs.repeat;\n      var forward = motionArgs.forward === lastSearch.forward;\n      var increment = (lastSearch.increment ? 1 : 0) * (forward ? -1 : 1);\n      cm.moveH(-increment, 'char');\n      motionArgs.inclusive = forward ? true : false;\n      var curEnd = moveToCharacter(cm, repeat, forward, lastSearch.selectedCharacter);\n      if (!curEnd) {\n        cm.moveH(increment, 'char');\n        return head;\n      }\n      curEnd.ch += increment;\n      return curEnd;\n    }\n  };\n\n  /** @arg {string} name  @arg {import(\"./types\").MotionFn} fn */\n  function defineMotion(name, fn) {\n    motions[name] = fn;\n  }\n\n  /** @arg {string} val @arg {number} times */\n  function fillArray(val, times) {\n    var arr = [];\n    for (var i = 0; i < times; i++) {\n      arr.push(val);\n    }\n    return arr;\n  }\n  /**\n   * An operator acts on a text selection. It receives the list of selections\n   * as input. The corresponding CodeMirror selection is guaranteed to\n   * match the input selection.\n   */\n  /** @type {import(\"./types\").vimOperators} */\n  var operators = {\n    change: function(cm, args, ranges) {\n      var finalHead, text;\n      var vim = cm.state.vim;\n      var anchor = ranges[0].anchor,\n          head = ranges[0].head;\n      if (!vim.visualMode) {\n        text = cm.getRange(anchor, head);\n        var lastState = vim.lastEditInputState;\n        if (lastState?.motion == \"moveByWords\" && !isWhiteSpaceString(text)) {\n          // Exclude trailing whitespace if the range is not all whitespace.\n          var match = (/\\s+$/).exec(text);\n          if (match && lastState.motionArgs && lastState.motionArgs.forward) {\n            head = offsetCursor(head, 0, - match[0].length);\n            text = text.slice(0, - match[0].length);\n          }\n        }\n        if (args.linewise) {\n          anchor = new Pos(anchor.line, findFirstNonWhiteSpaceCharacter(cm.getLine(anchor.line)));\n          if (head.line > anchor.line) {\n            head = new Pos(head.line - 1, Number.MAX_VALUE);\n          }\n        }\n        cm.replaceRange('', anchor, head);\n        finalHead = anchor;\n      } else if (args.fullLine) {\n          head.ch = Number.MAX_VALUE;\n          head.line--;\n          cm.setSelection(anchor, head);\n          text = cm.getSelection();\n          cm.replaceSelection(\"\");\n          finalHead = anchor;\n      } else {\n        text = cm.getSelection();\n        var replacement = fillArray('', ranges.length);\n        cm.replaceSelections(replacement);\n        finalHead = cursorMin(ranges[0].head, ranges[0].anchor);\n      }\n      vimGlobalState.registerController.pushText(\n          args.registerName, 'change', text,\n          args.linewise, ranges.length > 1);\n      actions.enterInsertMode(cm, {head: finalHead}, cm.state.vim);\n    },\n    delete: function(cm, args, ranges) {\n      var finalHead, text;\n      var vim = cm.state.vim;\n      if (!vim.visualBlock) {\n        var anchor = ranges[0].anchor,\n            head = ranges[0].head;\n        if (args.linewise &&\n            head.line != cm.firstLine() &&\n            anchor.line == cm.lastLine() &&\n            anchor.line == head.line - 1) {\n          // Special case for dd on last line (and first line).\n          if (anchor.line == cm.firstLine()) {\n            anchor.ch = 0;\n          } else {\n            anchor = new Pos(anchor.line - 1, lineLength(cm, anchor.line - 1));\n          }\n        }\n        text = cm.getRange(anchor, head);\n        cm.replaceRange('', anchor, head);\n        finalHead = anchor;\n        if (args.linewise) {\n          finalHead = motions.moveToFirstNonWhiteSpaceCharacter(cm, anchor);\n        }\n      } else {\n        text = cm.getSelection();\n        var replacement = fillArray('', ranges.length);\n        cm.replaceSelections(replacement);\n        finalHead = cursorMin(ranges[0].head, ranges[0].anchor);\n      }\n      vimGlobalState.registerController.pushText(\n          args.registerName, 'delete', text,\n          args.linewise, vim.visualBlock);\n      return clipCursorToContent(cm, finalHead);\n    },\n    indent: function(cm, args, ranges) {\n      var vim = cm.state.vim;\n      // In visual mode, n> shifts the selection right n times, instead of\n      // shifting n lines right once.\n      var repeat = vim.visualMode ? args.repeat || 1 : 1;\n      if (vim.visualBlock) {\n        var tabSize = cm.getOption('tabSize');\n        var indent = cm.getOption('indentWithTabs') ? '\\t' : ' '.repeat(tabSize);\n        var cursor;\n        for (var i = ranges.length - 1; i >= 0; i--) {\n          cursor = cursorMin(ranges[i].anchor, ranges[i].head);\n          if (args.indentRight) {\n            cm.replaceRange(indent.repeat(repeat), cursor, cursor);\n          } else {\n            var text = cm.getLine(cursor.line);\n            var end = 0;\n            for (var j = 0; j < repeat; j++) {\n              var ch = text[cursor.ch + end];\n              if (ch == '\\t') {\n                end++;\n              } else if (ch == ' ') {\n                end++;\n                for (var k = 1; k < indent.length; k++) {\n                  ch = text[cursor.ch + end];\n                  if (ch !== ' ') break;\n                  end++;\n                }\n              } else {\n                break\n              }\n            }\n            cm.replaceRange('', cursor, offsetCursor(cursor, 0, end));\n          }\n        }\n        return cursor;\n      } else if (cm.indentMore) {\n        for (var j = 0; j < repeat; j++) {\n          if (args.indentRight) cm.indentMore();\n          else cm.indentLess();\n        }\n      } else {\n        var startLine = ranges[0].anchor.line;\n        var endLine = vim.visualBlock ?\n          ranges[ranges.length - 1].anchor.line :\n          ranges[0].head.line;\n        if (args.linewise) {\n          // The only way to delete a newline is to delete until the start of\n          // the next line, so in linewise mode evalInput will include the next\n          // line. We don't want this in indent, so we go back a line.\n          endLine--;\n        }\n        for (var i = startLine; i <= endLine; i++) {\n          for (var j = 0; j < repeat; j++) {\n            cm.indentLine(i, args.indentRight);\n          }\n        }\n      }\n      return motions.moveToFirstNonWhiteSpaceCharacter(cm, ranges[0].anchor);\n    },\n    indentAuto: function(cm, _args, ranges) {\n      cm.execCommand(\"indentAuto\");\n      return motions.moveToFirstNonWhiteSpaceCharacter(cm, ranges[0].anchor);\n    },\n    hardWrap: function(cm, operatorArgs, ranges, oldAnchor) {\n      if (!cm.hardWrap) return;\n      var from = ranges[0].anchor.line;\n      var to = ranges[0].head.line;\n      if (operatorArgs.linewise) to--;\n      var endRow = cm.hardWrap({from: from, to: to});\n      if (endRow > from && operatorArgs.linewise) endRow--;\n      return operatorArgs.keepCursor ? oldAnchor : new Pos(endRow, 0);\n    },\n    changeCase: function(cm, args, ranges, oldAnchor, newHead) {\n      var selections = cm.getSelections();\n      var swapped = [];\n      var toLower = args.toLower;\n      for (var j = 0; j < selections.length; j++) {\n        var toSwap = selections[j];\n        var text = '';\n        if (toLower === true) {\n          text = toSwap.toLowerCase();\n        } else if (toLower === false) {\n          text = toSwap.toUpperCase();\n        } else {\n          for (var i = 0; i < toSwap.length; i++) {\n            var character = toSwap.charAt(i);\n            text += isUpperCase(character) ? character.toLowerCase() :\n                character.toUpperCase();\n          }\n        }\n        swapped.push(text);\n      }\n      cm.replaceSelections(swapped);\n      if (args.shouldMoveCursor){\n        return newHead;\n      } else if (!cm.state.vim.visualMode && args.linewise && ranges[0].anchor.line + 1 == ranges[0].head.line) {\n        return motions.moveToFirstNonWhiteSpaceCharacter(cm, oldAnchor);\n      } else if (args.linewise){\n        return oldAnchor;\n      } else {\n        return cursorMin(ranges[0].anchor, ranges[0].head);\n      }\n    },\n    yank: function(cm, args, ranges, oldAnchor) {\n      var vim = cm.state.vim;\n      var text = cm.getSelection();\n      var endPos = vim.visualMode\n        ? cursorMin(vim.sel.anchor, vim.sel.head, ranges[0].head, ranges[0].anchor)\n        : oldAnchor;\n      vimGlobalState.registerController.pushText(\n          args.registerName, 'yank',\n          text, args.linewise, vim.visualBlock);\n      return endPos;\n    },\n    rot13: function(cm, args, ranges, oldAnchor, newHead) {\n      var selections = cm.getSelections();\n      var swapped = [];\n      for (var j = 0; j < selections.length; j++) {\n        const replacement = selections[j]\n          .split('')\n          .map(x => {\n            const code = x.charCodeAt(0);\n            if (code >= 65 && code <= 90) { // Uppercase\n              return String.fromCharCode(65 + ((code - 65 + 13) % 26))\n            } else if (code >= 97 && code <= 122) { // Lowercase\n              return String.fromCharCode(97 + ((code - 97 + 13) % 26))\n            } else { // Not a letter\n              return x;\n            }\n          })\n          .join('');\n        swapped.push(replacement);\n      }\n      cm.replaceSelections(swapped);\n      if (args.shouldMoveCursor){\n        return newHead;\n      } else if (!cm.state.vim.visualMode && args.linewise && ranges[0].anchor.line + 1 == ranges[0].head.line) {\n        return motions.moveToFirstNonWhiteSpaceCharacter(cm, oldAnchor);\n      } else if (args.linewise){\n        return oldAnchor;\n      } else {\n        return cursorMin(ranges[0].anchor, ranges[0].head);\n      }\n    },\n  };\n\n  /** @arg {string} name  @arg {import(\"./types\").OperatorFn} fn */\n  function defineOperator(name, fn) {\n    operators[name] = fn;\n  }\n\n  /** @type {import(\"./types\").vimActions} */\n  var actions = {\n    jumpListWalk: function(cm, actionArgs, vim) {\n      if (vim.visualMode) {\n        return;\n      }\n      var repeat = actionArgs.repeat || 1;\n      var forward = actionArgs.forward;\n      var jumpList = vimGlobalState.jumpList;\n\n      var mark = jumpList.move(cm, forward ? repeat : -repeat);\n      var markPos = mark ? mark.find() : undefined;\n      markPos = markPos ? markPos : cm.getCursor();\n      cm.setCursor(markPos);\n    },\n    scroll: function(cm, actionArgs, vim) {\n      if (vim.visualMode) {\n        return;\n      }\n      var repeat = actionArgs.repeat || 1;\n      var lineHeight = cm.defaultTextHeight();\n      var top = cm.getScrollInfo().top;\n      var delta = lineHeight * repeat;\n      var newPos = actionArgs.forward ? top + delta : top - delta;\n      var cursor = copyCursor(cm.getCursor());\n      var cursorCoords = cm.charCoords(cursor, 'local');\n      if (actionArgs.forward) {\n        if (newPos > cursorCoords.top) {\n            cursor.line += (newPos - cursorCoords.top) / lineHeight;\n            cursor.line = Math.ceil(cursor.line);\n            cm.setCursor(cursor);\n            cursorCoords = cm.charCoords(cursor, 'local');\n            cm.scrollTo(null, cursorCoords.top);\n        } else {\n            // Cursor stays within bounds.  Just reposition the scroll window.\n            cm.scrollTo(null, newPos);\n        }\n      } else {\n        var newBottom = newPos + cm.getScrollInfo().clientHeight;\n        if (newBottom < cursorCoords.bottom) {\n            cursor.line -= (cursorCoords.bottom - newBottom) / lineHeight;\n            cursor.line = Math.floor(cursor.line);\n            cm.setCursor(cursor);\n            cursorCoords = cm.charCoords(cursor, 'local');\n            cm.scrollTo(\n                null, cursorCoords.bottom - cm.getScrollInfo().clientHeight);\n        } else {\n            // Cursor stays within bounds.  Just reposition the scroll window.\n            cm.scrollTo(null, newPos);\n        }\n      }\n    },\n    scrollToCursor: function(cm, actionArgs) {\n      var lineNum = cm.getCursor().line;\n      var charCoords = cm.charCoords(new Pos(lineNum, 0), 'local');\n      var height = cm.getScrollInfo().clientHeight;\n      var y = charCoords.top;\n      switch (actionArgs.position) {\n        case 'center': y = charCoords.bottom - height / 2;\n          break;\n        case 'bottom':\n          var lineLastCharPos = new Pos(lineNum, cm.getLine(lineNum).length - 1);\n          var lineLastCharCoords = cm.charCoords(lineLastCharPos, 'local');\n          var lineHeight = lineLastCharCoords.bottom - y;\n          y = y - height + lineHeight;\n          break;\n      }\n      cm.scrollTo(null, y);\n    },\n    replayMacro: function(cm, actionArgs, vim) {\n      var registerName = actionArgs.selectedCharacter || \"\";\n      var repeat = actionArgs.repeat || 1;\n      var macroModeState = vimGlobalState.macroModeState;\n      if (registerName == '@') {\n        registerName = macroModeState.latestRegister || \"\";\n      } else {\n        macroModeState.latestRegister = registerName;\n      }\n      while(repeat--){\n        executeMacroRegister(cm, vim, macroModeState, registerName);\n      }\n    },\n    enterMacroRecordMode: function(cm, actionArgs) {\n      var macroModeState = vimGlobalState.macroModeState;\n      var registerName = actionArgs.selectedCharacter;\n      if (vimGlobalState.registerController.isValidRegister(registerName)) {\n        macroModeState.enterMacroRecordMode(cm, registerName);\n      }\n    },\n    toggleOverwrite: function(cm) {\n      if (!cm.state.overwrite) {\n        cm.toggleOverwrite(true);\n        cm.setOption('keyMap', 'vim-replace');\n        CM.signal(cm, \"vim-mode-change\", {mode: \"replace\"});\n      } else {\n        cm.toggleOverwrite(false);\n        cm.setOption('keyMap', 'vim-insert');\n        CM.signal(cm, \"vim-mode-change\", {mode: \"insert\"});\n      }\n    },\n    enterInsertMode: function(cm, actionArgs, vim) {\n      if (cm.getOption('readOnly')) { return; }\n      vim.insertMode = true;\n      vim.insertModeRepeat = actionArgs && actionArgs.repeat || 1;\n      var insertAt = (actionArgs) ? actionArgs.insertAt : null;\n      var sel = vim.sel;\n      var head = actionArgs.head || cm.getCursor('head');\n      var height = cm.listSelections().length;\n      if (insertAt == 'eol') {\n        head = new Pos(head.line, lineLength(cm, head.line));\n      } else if (insertAt == 'bol') {\n        head = new Pos(head.line, 0);\n      } else if (insertAt == 'charAfter') {\n        var newPosition = updateSelectionForSurrogateCharacters(cm, head, offsetCursor(head, 0, 1));\n        head = newPosition.end;\n      } else if (insertAt == 'firstNonBlank') {\n        var newPosition = updateSelectionForSurrogateCharacters(cm, head, motions.moveToFirstNonWhiteSpaceCharacter(cm, head));\n        head = newPosition.end;\n      } else if (insertAt == 'startOfSelectedArea') {\n        if (!vim.visualMode)\n            return;\n        if (!vim.visualBlock) {\n          if (sel.head.line < sel.anchor.line) {\n            head = sel.head;\n          } else {\n            head = new Pos(sel.anchor.line, 0);\n          }\n        } else {\n          head = new Pos(\n              Math.min(sel.head.line, sel.anchor.line),\n              Math.min(sel.head.ch, sel.anchor.ch));\n          height = Math.abs(sel.head.line - sel.anchor.line) + 1;\n        }\n      } else if (insertAt == 'endOfSelectedArea') {\n          if (!vim.visualMode)\n            return;\n        if (!vim.visualBlock) {\n          if (sel.head.line >= sel.anchor.line) {\n            head = offsetCursor(sel.head, 0, 1);\n          } else {\n            head = new Pos(sel.anchor.line, 0);\n          }\n        } else {\n          head = new Pos(\n              Math.min(sel.head.line, sel.anchor.line),\n              Math.max(sel.head.ch, sel.anchor.ch) + 1);\n          height = Math.abs(sel.head.line - sel.anchor.line) + 1;\n        }\n      } else if (insertAt == 'inplace') {\n        if (vim.visualMode){\n          return;\n        }\n      } else if (insertAt == 'lastEdit') {\n        head = getLastEditPos(cm) || head;\n      }\n      cm.setOption('disableInput', false);\n      if (actionArgs && actionArgs.replace) {\n        // Handle Replace-mode as a special case of insert mode.\n        cm.toggleOverwrite(true);\n        cm.setOption('keyMap', 'vim-replace');\n        CM.signal(cm, \"vim-mode-change\", {mode: \"replace\"});\n      } else {\n        cm.toggleOverwrite(false);\n        cm.setOption('keyMap', 'vim-insert');\n        CM.signal(cm, \"vim-mode-change\", {mode: \"insert\"});\n      }\n      if (!vimGlobalState.macroModeState.isPlaying) {\n        // Only record if not replaying.\n        cm.on('change', onChange);\n        if (vim.insertEnd) vim.insertEnd.clear();\n        vim.insertEnd = cm.setBookmark(head, {insertLeft: true});\n        CM.on(cm.getInputField(), 'keydown', onKeyEventTargetKeyDown);\n      }\n      if (vim.visualMode) {\n        exitVisualMode(cm);\n      }\n      selectForInsert(cm, head, height);\n    },\n    toggleVisualMode: function(cm, actionArgs, vim) {\n      var repeat = actionArgs.repeat;\n      var anchor = cm.getCursor();\n      var head;\n      // TODO: The repeat should actually select number of characters/lines\n      //     equal to the repeat times the size of the previous visual\n      //     operation.\n      if (!vim.visualMode) {\n        // Entering visual mode\n        vim.visualMode = true;\n        vim.visualLine = !!actionArgs.linewise;\n        vim.visualBlock = !!actionArgs.blockwise;\n        head = clipCursorToContent(\n            cm, new Pos(anchor.line, anchor.ch + repeat - 1));\n        var newPosition = updateSelectionForSurrogateCharacters(cm, anchor, head);\n        vim.sel = {\n          anchor: newPosition.start,\n          head: newPosition.end\n        };\n        CM.signal(cm, \"vim-mode-change\", {mode: \"visual\", subMode: vim.visualLine ? \"linewise\" : vim.visualBlock ? \"blockwise\" : \"\"});\n        updateCmSelection(cm);\n        updateMark(cm, vim, '<', cursorMin(anchor, head));\n        updateMark(cm, vim, '>', cursorMax(anchor, head));\n      } else if (vim.visualLine != !!actionArgs.linewise ||\n          vim.visualBlock != !!actionArgs.blockwise) {\n        // Toggling between modes\n        vim.visualLine = !!actionArgs.linewise;\n        vim.visualBlock = !!actionArgs.blockwise;\n        CM.signal(cm, \"vim-mode-change\", {mode: \"visual\", subMode: vim.visualLine ? \"linewise\" : vim.visualBlock ? \"blockwise\" : \"\"});\n        updateCmSelection(cm);\n      } else {\n        exitVisualMode(cm);\n      }\n    },\n    reselectLastSelection: function(cm, _actionArgs, vim) {\n      var lastSelection = vim.lastSelection;\n      if (vim.visualMode) {\n        updateLastSelection(cm, vim);\n      }\n      if (lastSelection) {\n        var anchor = lastSelection.anchorMark.find();\n        var head = lastSelection.headMark.find();\n        if (!anchor || !head) {\n          // If the marks have been destroyed due to edits, do nothing.\n          return;\n        }\n        vim.sel = {\n          anchor: anchor,\n          head: head\n        };\n        vim.visualMode = true;\n        vim.visualLine = lastSelection.visualLine;\n        vim.visualBlock = lastSelection.visualBlock;\n        updateCmSelection(cm);\n        updateMark(cm, vim, '<', cursorMin(anchor, head));\n        updateMark(cm, vim, '>', cursorMax(anchor, head));\n        CM.signal(cm, 'vim-mode-change', {\n          mode: 'visual',\n          subMode: vim.visualLine ? 'linewise' :\n                    vim.visualBlock ? 'blockwise' : ''});\n      }\n    },\n    joinLines: function(cm, actionArgs, vim) {\n      var curStart, curEnd;\n      if (vim.visualMode) {\n        curStart = cm.getCursor('anchor');\n        curEnd = cm.getCursor('head');\n        if (cursorIsBefore(curEnd, curStart)) {\n          var tmp = curEnd;\n          curEnd = curStart;\n          curStart = tmp;\n        }\n        curEnd.ch = lineLength(cm, curEnd.line) - 1;\n      } else {\n        // Repeat is the number of lines to join. Minimum 2 lines.\n        var repeat = Math.max(actionArgs.repeat, 2);\n        curStart = cm.getCursor();\n        curEnd = clipCursorToContent(cm, new Pos(curStart.line + repeat - 1,\n                                              Infinity));\n      }\n      var finalCh = 0;\n      for (var i = curStart.line; i < curEnd.line; i++) {\n        finalCh = lineLength(cm, curStart.line);\n        var text = '';\n        var nextStartCh = 0;\n        if (!actionArgs.keepSpaces) {\n          var nextLine = cm.getLine(curStart.line + 1);\n          nextStartCh = nextLine.search(/\\S/);\n          if (nextStartCh == -1) {\n            nextStartCh = nextLine.length;\n          } else {\n            text = \" \";\n          }\n        }\n        cm.replaceRange(text, \n          new Pos(curStart.line, finalCh),\n          new Pos(curStart.line + 1, nextStartCh));\n      }\n      var curFinalPos = clipCursorToContent(cm, new Pos(curStart.line, finalCh));\n      if (vim.visualMode) {\n        exitVisualMode(cm, false);\n      }\n      cm.setCursor(curFinalPos);\n    },\n    newLineAndEnterInsertMode: function(cm, actionArgs, vim) {\n      vim.insertMode = true;\n      var insertAt = copyCursor(cm.getCursor());\n      if (insertAt.line === cm.firstLine() && !actionArgs.after) {\n        // Special case for inserting newline before start of document.\n        cm.replaceRange('\\n', new Pos(cm.firstLine(), 0));\n        cm.setCursor(cm.firstLine(), 0);\n      } else {\n        insertAt.line = (actionArgs.after) ? insertAt.line :\n            insertAt.line - 1;\n        insertAt.ch = lineLength(cm, insertAt.line);\n        cm.setCursor(insertAt);\n        var newlineFn = CM.commands.newlineAndIndentContinueComment ||\n            CM.commands.newlineAndIndent;\n        newlineFn(cm);\n      }\n      this.enterInsertMode(cm, { repeat: actionArgs.repeat }, vim);\n    },\n    paste: function(cm, actionArgs, vim) {\n      var register = vimGlobalState.registerController.getRegister(\n          actionArgs.registerName);\n      if (actionArgs.registerName === '+') {\n        navigator.clipboard.readText().then((value) => {\n          this.continuePaste(cm, actionArgs, vim, value, register);\n        });\n      } else {\n        var text = register.toString();\n        this.continuePaste(cm, actionArgs, vim, text, register);\n      }\n    },\n    continuePaste: function(cm, actionArgs, vim, text, register) {\n      var cur = copyCursor(cm.getCursor());\n      if (!text) {\n        return;\n      }\n      if (actionArgs.matchIndent) {\n        var tabSize = cm.getOption(\"tabSize\");\n        // length that considers tabs and tabSize\n        var whitespaceLength = function(/** @type {string} */ str) {\n          var tabs = (str.split(\"\\t\").length - 1);\n          var spaces = (str.split(\" \").length - 1);\n          return tabs * tabSize + spaces * 1;\n        };\n        var currentLine = cm.getLine(cm.getCursor().line);\n        // @ts-ignore\n        var indent = whitespaceLength(currentLine.match(/^\\s*/)[0]);\n        // chomp last newline b/c don't want it to match /^\\s*/gm\n        var chompedText = text.replace(/\\n$/, '');\n        var wasChomped = text !== chompedText;\n        // @ts-ignore\n        var firstIndent = whitespaceLength(text.match(/^\\s*/)[0]);\n        var text = chompedText.replace(/^\\s*/gm, function(wspace) {\n          var newIndent = indent + (whitespaceLength(wspace) - firstIndent);\n          if (newIndent < 0) {\n            return \"\";\n          }\n          else if (cm.getOption(\"indentWithTabs\")) {\n            var quotient = Math.floor(newIndent / tabSize);\n            return Array(quotient + 1).join('\\t');\n          }\n          else {\n            return Array(newIndent + 1).join(' ');\n          }\n        });\n        text += wasChomped ? \"\\n\" : \"\";\n      }\n      if (actionArgs.repeat > 1) {\n        text = Array(actionArgs.repeat + 1).join(text);\n      }\n      var linewise = register.linewise;\n      var blockwise = register.blockwise;\n      var textLines = blockwise ? text.split('\\n') : undefined;\n      if (textLines) {\n        if (linewise) {\n          textLines.pop();\n        }\n        for (var i = 0; i < textLines.length; i++) {\n          textLines[i] = (textLines[i] == '') ? ' ' : textLines[i];\n        }\n        cur.ch += actionArgs.after ? 1 : 0;\n        cur.ch = Math.min(lineLength(cm, cur.line), cur.ch);\n      } else if (linewise) {\n        if (vim.visualMode) {\n          text = vim.visualLine ? text.slice(0, -1) : '\\n' + text.slice(0, text.length - 1) + '\\n';\n        } else if (actionArgs.after) {\n          // Move the newline at the end to the start instead, and paste just\n          // before the newline character of the line we are on right now.\n          text = '\\n' + text.slice(0, text.length - 1);\n          cur.ch = lineLength(cm, cur.line);\n        } else {\n          cur.ch = 0;\n        }\n      } else {\n        cur.ch += actionArgs.after ? 1 : 0;\n      }\n      var curPosFinal;\n      if (vim.visualMode) {\n        //  save the pasted text for reselection if the need arises\n        vim.lastPastedText = text;\n        var lastSelectionCurEnd;\n        var selectedArea = getSelectedAreaRange(cm);\n        var selectionStart = selectedArea[0];\n        var selectionEnd = selectedArea[1];\n        var selectedText = cm.getSelection();\n        var selections = cm.listSelections();\n        var emptyStrings = new Array(selections.length).join('1').split('1');\n        // save the curEnd marker before it get cleared due to cm.replaceRange.\n        if (vim.lastSelection) {\n          lastSelectionCurEnd = vim.lastSelection.headMark.find();\n        }\n        // push the previously selected text to unnamed register\n        vimGlobalState.registerController.unnamedRegister.setText(selectedText);\n        if (blockwise) {\n          // first delete the selected text\n          cm.replaceSelections(emptyStrings);\n          // Set new selections as per the block length of the yanked text\n          selectionEnd = new Pos(selectionStart.line + text.length-1, selectionStart.ch);\n          cm.setCursor(selectionStart);\n          selectBlock(cm, selectionEnd);\n          // @ts-ignore\n          cm.replaceSelections(text);\n          curPosFinal = selectionStart;\n        } else if (vim.visualBlock) {\n          cm.replaceSelections(emptyStrings);\n          cm.setCursor(selectionStart);\n          cm.replaceRange(text, selectionStart, selectionStart);\n          curPosFinal = selectionStart;\n        } else {\n          cm.replaceRange(text, selectionStart, selectionEnd);\n          curPosFinal = cm.posFromIndex(cm.indexFromPos(selectionStart) + text.length - 1);\n        }\n        // restore the curEnd marker\n        if(lastSelectionCurEnd) {\n          vim.lastSelection.headMark = cm.setBookmark(lastSelectionCurEnd);\n        }\n        if (linewise) {\n          curPosFinal.ch=0;\n        }\n      } else {\n        if (blockwise && textLines) {\n          cm.setCursor(cur);\n          for (var i = 0; i < textLines.length; i++) {\n            var line = cur.line+i;\n            if (line > cm.lastLine()) {\n              cm.replaceRange('\\n',  new Pos(line, 0));\n            }\n            var lastCh = lineLength(cm, line);\n            if (lastCh < cur.ch) {\n              extendLineToColumn(cm, line, cur.ch);\n            }\n          }\n          cm.setCursor(cur);\n          selectBlock(cm, new Pos(cur.line + textLines.length-1, cur.ch));\n          cm.replaceSelections(textLines);\n          curPosFinal = cur;\n        } else {\n          cm.replaceRange(text, cur);\n          // Now fine tune the cursor to where we want it.\n          if (linewise) {\n            var line = actionArgs.after ? cur.line + 1 : cur.line;\n            curPosFinal = new Pos(line, findFirstNonWhiteSpaceCharacter(cm.getLine(line)));\n          } else {\n            curPosFinal = copyCursor(cur);\n            if (!/\\n/.test(text)) {\n              curPosFinal.ch += text.length - (actionArgs.after ? 1 : 0);\n            }\n          }\n        }\n      }\n      if (vim.visualMode) {\n        exitVisualMode(cm, false);\n      }\n      cm.setCursor(curPosFinal);\n    },\n    undo: function(cm, actionArgs) {\n      cm.operation(function() {\n        repeatFn(cm, CM.commands.undo, actionArgs.repeat)();\n        cm.setCursor(clipCursorToContent(cm, cm.getCursor('start')));\n      });\n    },\n    redo: function(cm, actionArgs) {\n      repeatFn(cm, CM.commands.redo, actionArgs.repeat)();\n    },\n    setRegister: function(_cm, actionArgs, vim) {\n      vim.inputState.registerName = actionArgs.selectedCharacter;\n    },\n    insertRegister: function(cm, actionArgs, vim) {\n      var registerName = actionArgs.selectedCharacter;\n      var register = vimGlobalState.registerController.getRegister(registerName);\n      var text = register && register.toString();\n      if (text) {\n        cm.replaceSelection(text);\n      }\n    },\n    oneNormalCommand: function(cm, actionArgs, vim) {\n      exitInsertMode(cm, true);\n      vim.insertModeReturn = true;\n      CM.on(cm, 'vim-command-done', function handler() {\n        if (vim.visualMode) return;\n        if (vim.insertModeReturn) {\n          vim.insertModeReturn = false;\n          if (!vim.insertMode) {\n            actions.enterInsertMode(cm, {}, vim);\n          }\n        }\n        CM.off(cm, 'vim-command-done', handler);\n      });\n    },\n    setMark: function(cm, actionArgs, vim) {\n      var markName = actionArgs.selectedCharacter;\n      if (markName) updateMark(cm, vim, markName, cm.getCursor());\n    },\n    replace: function(cm, actionArgs, vim) {\n      var replaceWith = actionArgs.selectedCharacter || \"\";\n      var curStart = cm.getCursor();\n      var replaceTo;\n      var curEnd;\n      var selections = cm.listSelections();\n      if (vim.visualMode) {\n        curStart = cm.getCursor('start');\n        curEnd = cm.getCursor('end');\n      } else {\n        var line = cm.getLine(curStart.line);\n        replaceTo = curStart.ch + actionArgs.repeat;\n        if (replaceTo > line.length) {\n          replaceTo=line.length;\n        }\n        curEnd = new Pos(curStart.line, replaceTo);\n      }\n\n      var newPositions = updateSelectionForSurrogateCharacters(cm, curStart, curEnd);\n      curStart = newPositions.start;\n      curEnd = newPositions.end;\n      if (replaceWith=='\\n') {\n        if (!vim.visualMode) cm.replaceRange('', curStart, curEnd);\n        // special case, where vim help says to replace by just one line-break\n        (CM.commands.newlineAndIndentContinueComment || CM.commands.newlineAndIndent)(cm);\n      } else {\n        var replaceWithStr = cm.getRange(curStart, curEnd);\n        // replace all surrogate characters with selected character\n        replaceWithStr = replaceWithStr.replace(/[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g, replaceWith);\n        //replace all characters in range by selected, but keep linebreaks\n        replaceWithStr = replaceWithStr.replace(/[^\\n]/g, replaceWith);\n        if (vim.visualBlock) {\n          // Tabs are split in visua block before replacing\n          var spaces = new Array(cm.getOption(\"tabSize\")+1).join(' ');\n          replaceWithStr = cm.getSelection();\n          replaceWithStr = replaceWithStr.replace(/[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g, replaceWith);\n          var replaceWithStrings = replaceWithStr.replace(/\\t/g, spaces).replace(/[^\\n]/g, replaceWith).split('\\n');\n          cm.replaceSelections(replaceWithStrings);\n        } else {\n          cm.replaceRange(replaceWithStr, curStart, curEnd);\n        }\n        if (vim.visualMode) {\n          curStart = cursorIsBefore(selections[0].anchor, selections[0].head) ?\n                        selections[0].anchor : selections[0].head;\n          cm.setCursor(curStart);\n          exitVisualMode(cm, false);\n        } else {\n          cm.setCursor(offsetCursor(curEnd, 0, -1));\n        }\n      }\n    },\n    incrementNumberToken: function(cm, actionArgs) {\n      var cur = cm.getCursor();\n      var lineStr = cm.getLine(cur.line);\n      var re = /(-?)(?:(0x)([\\da-f]+)|(0b|0|)(\\d+))/gi;\n      var match;\n      var start;\n      var end;\n      var numberStr;\n      while ((match = re.exec(lineStr)) !== null) {\n        start = match.index;\n        end = start + match[0].length;\n        if (cur.ch < end)break;\n      }\n      // @ts-ignore\n      if (!actionArgs.backtrack && (end <= cur.ch))return;\n      if (match) {\n        var baseStr = match[2] || match[4];\n        var digits = match[3] || match[5];\n        var increment = actionArgs.increase ? 1 : -1;\n        var base = {'0b': 2, '0': 8, '': 10, '0x': 16}[baseStr.toLowerCase()];\n        var number = parseInt(match[1] + digits, base) + (increment * actionArgs.repeat);\n        numberStr = number.toString(base);\n        var zeroPadding = baseStr ? new Array(digits.length - numberStr.length + 1 + match[1].length).join('0') : '';\n        if (numberStr.charAt(0) === '-') {\n          numberStr = '-' + baseStr + zeroPadding + numberStr.substr(1);\n        } else {\n          numberStr = baseStr + zeroPadding + numberStr;\n        }\n        // @ts-ignore\n        var from = new Pos(cur.line, start);\n        // @ts-ignore\n        var to = new Pos(cur.line, end);\n        cm.replaceRange(numberStr, from, to);\n      } else {\n        return;\n      }\n      // @ts-ignore\n      cm.setCursor(new Pos(cur.line, start + numberStr.length - 1));\n    },\n    repeatLastEdit: function(cm, actionArgs, vim) {\n      var lastEditInputState = vim.lastEditInputState;\n      if (!lastEditInputState) { return; }\n      var repeat = actionArgs.repeat;\n      if (repeat && actionArgs.repeatIsExplicit) {\n        lastEditInputState.repeatOverride = repeat;\n      } else {\n        repeat = lastEditInputState.repeatOverride || repeat;\n      }\n      repeatLastEdit(cm, vim, repeat, false /** repeatForInsert */);\n    },\n    indent: function(cm, actionArgs) {\n      cm.indentLine(cm.getCursor().line, actionArgs.indentRight);\n    },\n    exitInsertMode: function(cm, actionArgs) {\n      exitInsertMode(cm);\n    }\n  };\n\n  /** @arg {string } name  @arg {import(\"./types\").ActionFn} fn */\n  function defineAction(name, fn) {\n    actions[name] = fn;\n  }\n\n  /*\n   * Below are miscellaneous utility functions used by vim.js\n   */\n\n  /**\n   * Clips cursor to ensure that line is within the buffer's range\n   * and is not inside surrogate pair\n   * If includeLineBreak is true, then allow cur.ch == lineLength.\n   * @arg {CodeMirrorV} cm \n   * @arg {Pos} cur \n   * @arg {Pos} [oldCur]\n   * @return {Pos}\n   */\n  function clipCursorToContent(cm, cur, oldCur) {\n    var vim = cm.state.vim;\n    var includeLineBreak = vim.insertMode || vim.visualMode;\n    var line = Math.min(Math.max(cm.firstLine(), cur.line), cm.lastLine() );\n    var text = cm.getLine(line);\n    var maxCh = text.length - 1 + Number(!!includeLineBreak);\n    var ch = Math.min(Math.max(0, cur.ch), maxCh);\n    // prevent cursor from entering surrogate pair\n    var charCode = text.charCodeAt(ch);\n    if (0xDC00 <= charCode && charCode <= 0xDFFF) {\n      var direction = 1;\n      if (oldCur && oldCur.line == line && oldCur.ch > ch) {\n        direction = -1;\n      }\n      ch +=direction;\n      if (ch > maxCh) ch -=2;\n    }\n    return new Pos(line, ch);\n  }\n  /**@type <T>(args: T)=>T */\n  function copyArgs(args) {\n    var ret = /**@type{typeof args}*/({});\n    for (var prop in args) {\n      if (Object.prototype.hasOwnProperty.call(args, prop)) {\n        ret[prop] = args[prop];\n      }\n    }\n    return  /**@type{typeof args}*/(ret);\n  }\n  /**\n   * @param {Pos} cur\n   * @param {number|Pos} offsetLine\n   * @param {number} offsetCh\n   */\n  function offsetCursor(cur, offsetLine, offsetCh) {\n    if (typeof offsetLine === 'object') {\n      offsetCh = offsetLine.ch;\n      offsetLine = offsetLine.line;\n    }\n    return new Pos(cur.line + offsetLine, cur.ch + offsetCh);\n  }\n  /**\n   * @param {string} keys\n   * @param {vimKey[]} keyMap\n   * @param {string} context\n   * @param {InputStateInterface} inputState\n   */\n  function commandMatches(keys, keyMap, context, inputState) {\n    // Partial matches are not applied. They inform the key handler\n    // that the current key sequence is a subsequence of a valid key\n    // sequence, so that the key buffer is not cleared.\n    if (inputState.operator) context = \"operatorPending\";\n    var match, partial = [], full = [];\n    // if currently expanded key comes from a noremap, searcg only in default keys\n    var startIndex = noremap ? keyMap.length - defaultKeymapLength : 0;\n    for (var i = startIndex; i < keyMap.length; i++) {\n      var command = keyMap[i];\n      if (context == 'insert' && command.context != 'insert' ||\n          (command.context && command.context != context) ||\n          inputState.operator && command.type == 'action' ||\n          !(match = commandMatch(keys, command.keys))) { continue; }\n      if (match == 'partial') { partial.push(command); }\n      if (match == 'full') { full.push(command); }\n    }\n    return {\n      partial: partial,\n      full: full\n    };\n  }\n  /** @arg {string} pressed  @arg {string} mapped  @return {'full'|'partial'|false}*/\n  function commandMatch(pressed, mapped) {\n    const isLastCharacter = mapped.slice(-11) == '<character>';\n    const isLastRegister = mapped.slice(-10) == '<register>';\n    if (isLastCharacter || isLastRegister) {\n      // Last character matches anything.\n      var prefixLen = mapped.length - (isLastCharacter ? 11 : 10);\n      var pressedPrefix = pressed.slice(0, prefixLen);\n      var mappedPrefix = mapped.slice(0, prefixLen);\n      return pressedPrefix == mappedPrefix && pressed.length > prefixLen ? 'full' :\n              mappedPrefix.indexOf(pressedPrefix) == 0 ? 'partial' : false;\n    } else {\n      return pressed == mapped ? 'full' :\n              mapped.indexOf(pressed) == 0 ? 'partial' : false;\n    }\n  }\n  /** @arg {string} keys */\n  function lastChar(keys) {\n    var match = /^.*(<[^>]+>)$/.exec(keys);\n    var selectedCharacter = match ? match[1] : keys.slice(-1);\n    if (selectedCharacter.length > 1){\n      switch(selectedCharacter){\n        case '<CR>':\n        case '<S-CR>':\n          selectedCharacter='\\n';\n          break;\n        case '<Space>':\n        case '<S-Space>':\n          selectedCharacter=' ';\n          break;\n        default:\n          selectedCharacter='';\n          break;\n      }\n    }\n    return selectedCharacter;\n  }\n  /** @arg {CodeMirror} cm   @arg {{ (cm: CodeMirror): void }} fn   @arg {number} repeat */\n  function repeatFn(cm, fn, repeat) {\n    return function() {\n      for (var i = 0; i < repeat; i++) {\n        fn(cm);\n      }\n    };\n  }\n  /** @arg {Pos} cur   @return {Pos}*/\n  function copyCursor(cur) {\n    return new Pos(cur.line, cur.ch);\n  }\n  /** @arg {Pos} cur1 @arg {Pos} cur2  @return {boolean} */\n  function cursorEqual(cur1, cur2) {\n    return cur1.ch == cur2.ch && cur1.line == cur2.line;\n  }\n  /** @arg {Pos} cur1  @arg {Pos} cur2 @return {boolean}*/\n  function cursorIsBefore(cur1, cur2) {\n    if (cur1.line < cur2.line) {\n      return true;\n    }\n    if (cur1.line == cur2.line && cur1.ch < cur2.ch) {\n      return true;\n    }\n    return false;\n  }\n  /** @arg {Pos} cur1 @arg {Pos} cur2  @return {Pos}*/\n  function cursorMin(cur1, cur2) {\n    if (arguments.length > 2) {\n      // @ts-ignore\n      cur2 = cursorMin.apply(undefined, Array.prototype.slice.call(arguments, 1));\n    }\n    return cursorIsBefore(cur1, cur2) ? cur1 : cur2;\n  }\n  /** @arg {Pos} cur1  @arg {Pos} cur2  @return {Pos} */\n  function cursorMax(cur1, cur2) {\n    if (arguments.length > 2) {\n      // @ts-ignore\n      cur2 = cursorMax.apply(undefined, Array.prototype.slice.call(arguments, 1));\n    }\n    return cursorIsBefore(cur1, cur2) ? cur2 : cur1;\n  }\n  /** @arg {Pos} cur1   @arg {Pos} cur2  @arg {Pos} cur3  @return {boolean}*/ \n  function cursorIsBetween(cur1, cur2, cur3) {\n    // returns true if cur2 is between cur1 and cur3.\n    var cur1before2 = cursorIsBefore(cur1, cur2);\n    var cur2before3 = cursorIsBefore(cur2, cur3);\n    return cur1before2 && cur2before3;\n  }\n  /** @arg {CodeMirror} cm  @arg {number} lineNum */\n  function lineLength(cm, lineNum) {\n    return cm.getLine(lineNum).length;\n  }\n  /** @arg {string} s */\n  function trim(s) {\n    if (s.trim) {\n      return s.trim();\n    }\n    return s.replace(/^\\s+|\\s+$/g, '');\n  }\n  /** @arg {string} s */\n  function escapeRegex(s) {\n    return s.replace(/([.?*+$\\[\\]\\/\\\\(){}|\\-])/g, '\\\\$1');\n  }\n  /** @arg {CodeMirror} cm  @arg {number} lineNum  @arg {number} column */\n  function extendLineToColumn(cm, lineNum, column) {\n    var endCh = lineLength(cm, lineNum);\n    var spaces = new Array(column-endCh+1).join(' ');\n    cm.setCursor(new Pos(lineNum, endCh));\n    cm.replaceRange(spaces, cm.getCursor());\n  }\n  // This functions selects a rectangular block\n  // of text with selectionEnd as any of its corner\n  // Height of block:\n  // Difference in selectionEnd.line and first/last selection.line\n  // Width of the block:\n  // Distance between selectionEnd.ch and any(first considered here) selection.ch\n  /** @arg {CodeMirror} cm  @arg {Pos} selectionEnd */\n  function selectBlock(cm, selectionEnd) {\n    var selections = [], ranges = cm.listSelections();\n    var head = copyCursor(cm.clipPos(selectionEnd));\n    var isClipped = !cursorEqual(selectionEnd, head);\n    var curHead = cm.getCursor('head');\n    var primIndex = getIndex(ranges, curHead);\n    var wasClipped = cursorEqual(ranges[primIndex].head, ranges[primIndex].anchor);\n    var max = ranges.length - 1;\n    var index = max - primIndex > primIndex ? max : 0;\n    var base = ranges[index].anchor;\n\n    var firstLine = Math.min(base.line, head.line);\n    var lastLine = Math.max(base.line, head.line);\n    var baseCh = base.ch, headCh = head.ch;\n\n    var dir = ranges[index].head.ch - baseCh;\n    var newDir = headCh - baseCh;\n    if (dir > 0 && newDir <= 0) {\n      baseCh++;\n      if (!isClipped) { headCh--; }\n    } else if (dir < 0 && newDir >= 0) {\n      baseCh--;\n      if (!wasClipped) { headCh++; }\n    } else if (dir < 0 && newDir == -1) {\n      baseCh--;\n      headCh++;\n    }\n    for (var line = firstLine; line <= lastLine; line++) {\n      var range = {anchor: new Pos(line, baseCh), head: new Pos(line, headCh)};\n      selections.push(range);\n    }\n    cm.setSelections(selections);\n    selectionEnd.ch = headCh;\n    base.ch = baseCh;\n    return base;\n  }\n  /** @arg {CodeMirror} cm  @arg {any} head  @arg {number} height */\n  function selectForInsert(cm, head, height) {\n    var sel = [];\n    for (var i = 0; i < height; i++) {\n      var lineHead = offsetCursor(head, i, 0);\n      sel.push({anchor: lineHead, head: lineHead});\n    }\n    cm.setSelections(sel, 0);\n  }\n  // getIndex returns the index of the cursor in the selections.\n  /** @arg {vimState[\"sel\"][]} ranges  @arg {Pos} cursor  @arg {string | undefined} [end] */\n  function getIndex(ranges, cursor, end) {\n    for (var i = 0; i < ranges.length; i++) {\n      var atAnchor = cursorEqual(ranges[i].anchor, cursor);\n      var atHead = cursorEqual(ranges[i].head, cursor);\n      if (atAnchor || atHead) {\n        return i;\n      }\n    }\n    return -1;\n  }\n  /** @arg {CodeMirror} cm  @arg {vimState} vim  @return {[Pos,Pos]}*/\n  function getSelectedAreaRange(cm, vim) {\n    var selections = cm.listSelections();\n    var start =  selections[0];\n    var end = selections[selections.length-1];\n    var selectionStart = cursorIsBefore(start.anchor, start.head) ? start.anchor : start.head;\n    var selectionEnd = cursorIsBefore(end.anchor, end.head) ? end.head : end.anchor;\n    return [selectionStart, selectionEnd];\n  }\n  // Updates the previous selection with the current selection's values. This\n  // should only be called in visual mode.\n  /** @arg {CodeMirror} cm @arg {vimState} vim */\n  function updateLastSelection(cm, vim) {\n    var anchor = vim.sel.anchor;\n    var head = vim.sel.head;\n    // To accommodate the effect of lastPastedText in the last selection\n    if (vim.lastPastedText) {\n      head = cm.posFromIndex(cm.indexFromPos(anchor) + vim.lastPastedText.length);\n      vim.lastPastedText = undefined;\n    }\n    vim.lastSelection = {'anchorMark': cm.setBookmark(anchor),\n                          'headMark': cm.setBookmark(head),\n                          'anchor': copyCursor(anchor),\n                          'head': copyCursor(head),\n                          'visualMode': vim.visualMode,\n                          'visualLine': vim.visualLine,\n                          'visualBlock': vim.visualBlock};\n  }\n  /** @arg {CodeMirrorV} cm @arg {Pos} start @arg {Pos} end @arg {Boolean} [move] @returns {[Pos, Pos]} */\n  function expandSelection(cm, start, end, move) {\n    var sel = cm.state.vim.sel;\n    var head = move ? start: sel.head;\n    var anchor = move ? start: sel.anchor;\n    var tmp;\n    if (cursorIsBefore(end, start)) {\n      tmp = end;\n      end = start;\n      start = tmp;\n    }\n    if (cursorIsBefore(head, anchor)) {\n      head = cursorMin(start, head);\n      anchor = cursorMax(anchor, end);\n    } else {\n      anchor = cursorMin(start, anchor);\n      head = cursorMax(head, end);\n      head = offsetCursor(head, 0, -1);\n      if (head.ch == -1 && head.line != cm.firstLine()) {\n        head = new Pos(head.line - 1, lineLength(cm, head.line - 1));\n      }\n    }\n    return [anchor, head];\n  }\n  /**\n   * Updates the CodeMirror selection to match the provided vim selection.\n   * If no arguments are given, it uses the current vim selection state.\n   * @arg {CodeMirrorV} cm \n   * @arg {vimState[\"sel\"]} [sel] \n   * @arg {\"char\"|\"line\"|\"block\" | undefined} [mode]\n   */\n  function updateCmSelection(cm, sel, mode) {\n    var vim = cm.state.vim;\n    sel = sel || vim.sel;\n    if (!mode) {\n      mode = vim.visualLine ? 'line' : vim.visualBlock ? 'block' : 'char';\n    }\n    var cmSel = makeCmSelection(cm, sel, mode);\n    cm.setSelections(cmSel.ranges, cmSel.primary);\n  }\n  /**\n   * @arg {CodeMirror} cm \n   * @arg {import(\"./types\").CM5RangeInterface} sel\n   * @arg {\"char\"|\"line\"|\"block\"} mode \n   * @arg {boolean|undefined} [exclusive] \n   */\n  function makeCmSelection(cm, sel, mode, exclusive) {\n    var head = copyCursor(sel.head);\n    var anchor = copyCursor(sel.anchor);\n    if (mode == 'char') {\n      var headOffset = !exclusive && !cursorIsBefore(sel.head, sel.anchor) ? 1 : 0;\n      var anchorOffset = cursorIsBefore(sel.head, sel.anchor) ? 1 : 0;\n      head = offsetCursor(sel.head, 0, headOffset);\n      anchor = offsetCursor(sel.anchor, 0, anchorOffset);\n      return {\n        ranges: [{anchor: anchor, head: head}],\n        primary: 0\n      };\n    } else if (mode == 'line') {\n      if (!cursorIsBefore(sel.head, sel.anchor)) {\n        anchor.ch = 0;\n\n        var lastLine = cm.lastLine();\n        if (head.line > lastLine) {\n          head.line = lastLine;\n        }\n        head.ch = lineLength(cm, head.line);\n      } else {\n        head.ch = 0;\n        anchor.ch = lineLength(cm, anchor.line);\n      }\n      return {\n        ranges: [{anchor: anchor, head: head}],\n        primary: 0\n      };\n    } else if (mode == 'block') {\n      var top = Math.min(anchor.line, head.line),\n          fromCh = anchor.ch,\n          bottom = Math.max(anchor.line, head.line),\n          toCh = head.ch;\n      if (fromCh < toCh) { toCh += 1; }\n      else { fromCh += 1; }      var height = bottom - top + 1;\n      var primary = head.line == top ? 0 : height - 1;\n      var ranges = [];\n      for (var i = 0; i < height; i++) {\n        ranges.push({\n          anchor: new Pos(top + i, fromCh),\n          head: new Pos(top + i, toCh)\n        });\n      }\n      return {\n        ranges: ranges,\n        primary: primary\n      };\n    }\n    throw \"never happens\";\n  }\n  /** @arg {CodeMirror} cm */\n  function getHead(cm) {\n    var cur = cm.getCursor('head');\n    if (cm.getSelection().length == 1) {\n      // Small corner case when only 1 character is selected. The \"real\"\n      // head is the left of head and anchor.\n      cur = cursorMin(cur, cm.getCursor('anchor'));\n    }\n    return cur;\n  }\n\n  /**\n   * If moveHead is set to false, the CodeMirror selection will not be\n   * touched. The caller assumes the responsibility of putting the cursor\n   * in the right place.\n   * @arg {CodeMirrorV} cm \n   * @arg {boolean} [moveHead]\n   */\n  function exitVisualMode(cm, moveHead) {\n    var vim = cm.state.vim;\n    if (moveHead !== false) {\n      cm.setCursor(clipCursorToContent(cm, vim.sel.head));\n    }\n    updateLastSelection(cm, vim);\n    vim.visualMode = false;\n    vim.visualLine = false;\n    vim.visualBlock = false;\n    if (!vim.insertMode) CM.signal(cm, \"vim-mode-change\", {mode: \"normal\"});\n  }\n\n  /** \n   * Remove any trailing newlines from the selection. For\n   * example, with the caret at the start of the last word on the line,\n   * 'dw' should word, but not the newline, while 'w' should advance the\n   * caret to the first character of the next line.\n   * @arg {CodeMirror} cm\n   * @arg {Pos} curStart\n   * @arg {Pos} curEnd\n   */\n  function clipToLine(cm, curStart, curEnd) {\n    var selection = cm.getRange(curStart, curEnd);\n    // Only clip if the selection ends with trailing newline + whitespace\n    if (/\\n\\s*$/.test(selection)) {\n      var lines = selection.split('\\n');\n      // We know this is all whitespace.\n      lines.pop();\n\n      // Cases:\n      // 1. Last word is an empty line - do not clip the trailing '\\n'\n      // 2. Last word is not an empty line - clip the trailing '\\n'\n      // Find the line containing the last word, and clip all whitespace up\n      // to it.\n      for (var line = lines.pop(); lines.length > 0 && line && isWhiteSpaceString(line); line = lines.pop()) {\n        curEnd.line--;\n        curEnd.ch = 0;\n      }\n      // If the last word is not an empty line, clip an additional newline\n      if (line) {\n        curEnd.line--;\n        curEnd.ch = lineLength(cm, curEnd.line);\n      } else {\n        curEnd.ch = 0;\n      }\n    }\n  }\n\n  // Expand the selection to line ends.\n  /** @arg {CodeMirror} _cm  @arg {Pos} curStart  @arg {Pos} curEnd */\n  function expandSelectionToLine(_cm, curStart, curEnd) {\n    curStart.ch = 0;\n    curEnd.ch = 0;\n    curEnd.line++;\n  }\n\n  /** @arg {string} [text] */\n  function findFirstNonWhiteSpaceCharacter(text) {\n    if (!text) {\n      return 0;\n    }\n    var firstNonWS = text.search(/\\S/);\n    return firstNonWS == -1 ? text.length : firstNonWS;\n  }\n\n  /** \n   * @arg {CodeMirror} cm \n   * @arg {{inclusive?: boolean, innerWord?: boolean, bigWord?: boolean, noSymbol?: boolean, multiline?: boolean}} options\n   * @arg {Pos} [cursor]\n   **/\n  function expandWordUnderCursor(cm, {inclusive, innerWord, bigWord, noSymbol, multiline}, cursor) {\n    var cur = cursor || getHead(cm);\n    var line = cm.getLine(cur.line);\n    var endLine = line;\n    var startLineNumber = cur.line;\n    var endLineNumber = startLineNumber;\n    var idx = cur.ch;\n\n    var wordOnNextLine;\n    // Seek to first word or non-whitespace character, depending on if\n    // noSymbol is true.\n    var test = noSymbol ? wordCharTest[0] : bigWordCharTest [0];\n    if (innerWord && /\\s/.test(line.charAt(idx))) {\n      test = function(/** @type {string} */ ch) { return /\\s/.test(ch); };\n    } else {\n      while (!test(line.charAt(idx))) {\n        idx++;\n        if (idx >= line.length) {\n          if (!multiline) return null;\n          idx--;\n          wordOnNextLine = findWord(cm, cur, true, bigWord, true);\n          break\n        }\n      }\n\n      if (bigWord) {\n        test = bigWordCharTest[0];\n      } else {\n        test = wordCharTest[0];\n        if (!test(line.charAt(idx))) {\n          test = wordCharTest[1];\n        }\n      }\n    }\n\n    var end = idx, start = idx;\n    while (test(line.charAt(start)) && start >= 0) { start--; }\n    start++;\n    if (wordOnNextLine) {\n      end = wordOnNextLine.to;\n      endLineNumber = wordOnNextLine.line;\n      endLine = cm.getLine(endLineNumber);\n      if (!endLine && end == 0) end++;\n    } else {\n      while (test(line.charAt(end)) && end < line.length) { end++; }\n    }\n\n    if (inclusive) {\n      // If present, include all whitespace after word.\n      // Otherwise, include all whitespace before word, except indentation.\n      var wordEnd = end;\n      var startsWithSpace = cur.ch <= start && /\\s/.test(line.charAt(cur.ch));\n      if (!startsWithSpace) {\n        while (/\\s/.test(endLine.charAt(end)) && end < endLine.length) { end++; }\n      }\n      if (wordEnd == end || startsWithSpace) {\n        var wordStart = start;\n        while (/\\s/.test(line.charAt(start - 1)) && start > 0) { start--; }\n        if (!start && !startsWithSpace) { start = wordStart; }\n      }\n    }\n\n    return { start: new Pos(startLineNumber, start), end: new Pos(endLineNumber, end) };\n  }\n\n  /**\n   * Depends on the following:\n   *\n   * - editor mode should be htmlmixedmode / xml\n   * - mode/xml/xml.js should be loaded\n   * - addon/fold/xml-fold.js should be loaded\n   *\n   * If any of the above requirements are not true, this function noops.\n   *\n   * This is _NOT_ a 100% accurate implementation of vim tag text objects.\n   * The following caveats apply (based off cursory testing, I'm sure there\n   * are other discrepancies):\n   *\n   * - Does not work inside comments:\n   *   ```\n   *   <!-- <div>broken</div> -->\n   *   ```\n   * - Does not work when tags have different cases:\n   *   ```\n   *   <div>broken</DIV>\n   *   ```\n   * - Does not work when cursor is inside a broken tag:\n   *   ```\n   *   <div><brok><en></div>\n   *   ```\n   * @arg {CodeMirror} cm \n   * @arg {Pos} head \n   * @arg {boolean} [inclusive]\n   */\n  function expandTagUnderCursor(cm, head, inclusive) {\n    var cur = head;\n    if (!CM.findMatchingTag || !CM.findEnclosingTag) {\n      return { start: cur, end: cur };\n    }\n\n    var tags = CM.findMatchingTag(cm, head) || CM.findEnclosingTag(cm, head);\n    if (!tags || !tags.open || !tags.close) {\n      return { start: cur, end: cur };\n    }\n\n    if (inclusive) {\n      return { start: tags.open.from, end: tags.close.to };\n    }\n    return { start: tags.open.to, end: tags.close.from };\n  }\n\n  /** @arg {CodeMirror} cm @arg {Pos} oldCur @arg {Pos} newCur */\n  function recordJumpPosition(cm, oldCur, newCur) {\n    if (!cursorEqual(oldCur, newCur)) {\n      vimGlobalState.jumpList.add(cm, oldCur, newCur);\n    }\n  }\n\n  /** @arg {number} increment  @arg {{ forward?: any; selectedCharacter?: any; }} args */\n  function recordLastCharacterSearch(increment, args) {\n      vimGlobalState.lastCharacterSearch.increment = increment;\n      vimGlobalState.lastCharacterSearch.forward = args.forward;\n      vimGlobalState.lastCharacterSearch.selectedCharacter = args.selectedCharacter;\n  }\n\n  /**@type{Record<string, keyof findSymbolModes>} */\n  var symbolToMode = {\n      '(': 'bracket', ')': 'bracket', '{': 'bracket', '}': 'bracket',\n      '[': 'section', ']': 'section',\n      '*': 'comment', '/': 'comment',\n      'm': 'method', 'M': 'method',\n      '#': 'preprocess'\n  };\n\n  /** \n    @typedef { {\n    lineText: string,\n    nextCh: string,\n    lastCh: string|null,\n    index: number,\n    symb: string,\n    reverseSymb: any,\n    forward?: boolean,\n    depth: number,\n    curMoveThrough: boolean\n  } } findSymbolState */\n  /** \n   * @type {Record<string, { \n   *  isComplete(state: findSymbolState): boolean,\n   *  init?(state: findSymbolState): void \n   * }>} */\n  var findSymbolModes = {\n    bracket: {\n      isComplete: function(state) {\n        if (state.nextCh === state.symb) {\n          state.depth++;\n          if (state.depth >= 1)return true;\n        } else if (state.nextCh === state.reverseSymb) {\n          state.depth--;\n        }\n        return false;\n      }\n    },\n    section: {\n      init: function(state) {\n        state.curMoveThrough = true;\n        state.symb = (state.forward ? ']' : '[') === state.symb ? '{' : '}';\n      },\n      isComplete: function(state) {\n        return state.index === 0 && state.nextCh === state.symb;\n      }\n    },\n    comment: {\n      isComplete: function(state) {\n        var found = state.lastCh === '*' && state.nextCh === '/';\n        state.lastCh = state.nextCh;\n        return found;\n      }\n    },\n    // TODO: The original Vim implementation only operates on level 1 and 2.\n    // The current implementation doesn't check for code block level and\n    // therefore it operates on any levels.\n    method: {\n      init: function(state) {\n        state.symb = (state.symb === 'm' ? '{' : '}');\n        state.reverseSymb = state.symb === '{' ? '}' : '{';\n      },\n      isComplete: function(state) {\n        if (state.nextCh === state.symb)return true;\n        return false;\n      }\n    },\n    preprocess: {\n      init: function(state) {\n        state.index = 0;\n      },\n      isComplete: function(state) {\n        if (state.nextCh === '#') {\n          var token = state.lineText.match(/^#(\\w+)/)?.[1];\n          if (token === 'endif') {\n            if (state.forward && state.depth === 0) {\n              return true;\n            }\n            state.depth++;\n          } else if (token === 'if') {\n            if (!state.forward && state.depth === 0) {\n              return true;\n            }\n            state.depth--;\n          }\n          if (token === 'else' && state.depth === 0)return true;\n        }\n        return false;\n      }\n    }      \n  };\n  /** @arg {CodeMirrorV} cm  @arg {number} repeat  @arg {boolean|undefined} forward  @arg {string} symb */\n  function findSymbol(cm, repeat, forward, symb) {\n    var cur = copyCursor(cm.getCursor());\n    var increment = forward ? 1 : -1;\n    var endLine = forward ? cm.lineCount() : -1;\n    var curCh = cur.ch;\n    var line = cur.line;\n    var lineText = cm.getLine(line);\n    var state = {\n      lineText: lineText,\n      nextCh: lineText.charAt(curCh),\n      lastCh: null,\n      index: curCh,\n      symb: symb,\n      reverseSymb: (forward ?  { ')': '(', '}': '{' } : { '(': ')', '{': '}' })[symb],\n      forward: forward,\n      depth: 0,\n      curMoveThrough: false\n    };\n    var mode = symbolToMode[symb];\n    if (!mode)return cur;\n    var init = findSymbolModes[mode].init;\n    var isComplete = findSymbolModes[mode].isComplete;\n    if (init) { init(state); }\n    while (line !== endLine && repeat) {\n      state.index += increment;\n      state.nextCh = state.lineText.charAt(state.index);\n      if (!state.nextCh) {\n        line += increment;\n        state.lineText = cm.getLine(line) || '';\n        if (increment > 0) {\n          state.index = 0;\n        } else {\n          var lineLen = state.lineText.length;\n          state.index = (lineLen > 0) ? (lineLen-1) : 0;\n        }\n        state.nextCh = state.lineText.charAt(state.index);\n      }\n      if (isComplete(state)) {\n        cur.line = line;\n        cur.ch = state.index;\n        repeat--;\n      }\n    }\n    if (state.nextCh || state.curMoveThrough) {\n      return new Pos(line, state.index);\n    }\n    return cur;\n  }\n\n  /**\n   * Returns the boundaries of the next word. If the cursor in the middle of\n   * the word, then returns the boundaries of the current word, starting at\n   * the cursor. If the cursor is at the start/end of a word, and we are going\n   * forward/backward, respectively, find the boundaries of the next word.\n   *\n   * @arg {CodeMirror} cm CodeMirror object.\n   * @arg {Pos} cur The cursor position.\n   * @arg {boolean} forward True to search forward. False to search\n   *     backward.\n   * @arg {boolean|undefined} bigWord True if punctuation count as part of the word.\n   *     False if only [a-zA-Z0-9] characters count as part of the word.\n   * @arg {boolean|undefined} emptyLineIsWord True if empty lines should be treated\n   *     as words.\n   * @return {{from:number, to:number, line: number}|null} The boundaries of\n   *     the word, or null if there are no more words.\n   */\n  function findWord(cm, cur, forward, bigWord, emptyLineIsWord) {\n    var lineNum = cur.line;\n    var pos = cur.ch;\n    var line = cm.getLine(lineNum);\n    var dir = forward ? 1 : -1;\n    var charTests = bigWord ? bigWordCharTest: wordCharTest;\n\n    if (emptyLineIsWord && line == '') {\n      lineNum += dir;\n      line = cm.getLine(lineNum);\n      if (!isLine(cm, lineNum)) {\n        return null;\n      }\n      pos = (forward) ? 0 : line.length;\n    }\n\n    while (true) {\n      if (emptyLineIsWord && line == '') {\n        return { from: 0, to: 0, line: lineNum };\n      }\n      var stop = (dir > 0) ? line.length : -1;\n      var wordStart = stop, wordEnd = stop;\n      // Find bounds of next word.\n      while (pos != stop) {\n        var foundWord = false;\n        for (var i = 0; i < charTests.length && !foundWord; ++i) {\n          if (charTests[i](line.charAt(pos))) {\n            wordStart = pos;\n            // Advance to end of word.\n            while (pos != stop && charTests[i](line.charAt(pos))) {\n              pos += dir;\n            }\n            wordEnd = pos;\n            foundWord = wordStart != wordEnd;\n            if (wordStart == cur.ch && lineNum == cur.line &&\n                wordEnd == wordStart + dir) {\n              // We started at the end of a word. Find the next one.\n              continue;\n            } else {\n              return {\n                from: Math.min(wordStart, wordEnd + 1),\n                to: Math.max(wordStart, wordEnd),\n                line: lineNum };\n            }\n          }\n        }\n        if (!foundWord) {\n          pos += dir;\n        }\n      }\n      // Advance to next/prev line.\n      lineNum += dir;\n      if (!isLine(cm, lineNum)) {\n        return null;\n      }\n      line = cm.getLine(lineNum);\n      pos = (dir > 0) ? 0 : line.length;\n    }\n  }\n\n  /**\n   * @arg {CodeMirror} cm CodeMirror object.\n   * @arg {Pos} cur The position to start from.\n   * @arg {number} repeat Number of words to move past.\n   * @arg {boolean} forward True to search forward. False to search\n   *     backward.\n   * @arg {boolean} wordEnd True to move to end of word. False to move to\n   *     beginning of word.\n   * @arg {boolean} bigWord True if punctuation count as part of the word.\n   *     False if only alphabet characters count as part of the word.\n   * @return {Pos|undefined} The position the cursor should move to.\n   */\n  function moveToWord(cm, cur, repeat, forward, wordEnd, bigWord) {\n    var curStart = copyCursor(cur);\n    var words = [];\n    if (forward && !wordEnd || !forward && wordEnd) {\n      repeat++;\n    }\n    // For 'e', empty lines are not considered words, go figure.\n    var emptyLineIsWord = !(forward && wordEnd);\n    for (var i = 0; i < repeat; i++) {\n      var word = findWord(cm, cur, forward, bigWord, emptyLineIsWord);\n      if (!word) {\n        var eodCh = lineLength(cm, cm.lastLine());\n        words.push(forward\n            ? {line: cm.lastLine(), from: eodCh, to: eodCh}\n            : {line: 0, from: 0, to: 0});\n        break;\n      }\n      words.push(word);\n      cur = new Pos(word.line, forward ? (word.to - 1) : word.from);\n    }\n    var shortCircuit = words.length != repeat;\n    var firstWord = words[0];\n    var lastWord = words.pop();\n    if (forward && !wordEnd) {\n      // w\n      if (!shortCircuit && (firstWord.from != curStart.ch || firstWord.line != curStart.line)) {\n        // We did not start in the middle of a word. Discard the extra word at the end.\n        lastWord = words.pop();\n      }\n      return lastWord && new Pos(lastWord.line, lastWord.from);\n    } else if (forward && wordEnd) {\n      return lastWord && new Pos(lastWord.line, lastWord.to - 1);\n    } else if (!forward && wordEnd) {\n      // ge\n      if (!shortCircuit && (firstWord.to != curStart.ch || firstWord.line != curStart.line)) {\n        // We did not start in the middle of a word. Discard the extra word at the end.\n        lastWord = words.pop();\n      }\n      return lastWord && new Pos(lastWord.line, lastWord.to);\n    } else {\n      // b\n      return lastWord && new Pos(lastWord.line, lastWord.from);\n    }\n  }\n\n  /**\n   * @arg {CodeMirror} cm \n   * @arg {Pos} head \n   * @arg {MotionArgs} motionArgs \n   * @arg {vimState} vim \n   * @arg {boolean} keepHPos */\n  function moveToEol(cm, head, motionArgs, vim, keepHPos) {\n    var cur = head;\n    var retval= new Pos(cur.line + motionArgs.repeat - 1, Infinity);\n    var end=cm.clipPos(retval);\n    end.ch--;\n    if (!keepHPos) {\n      vim.lastHPos = Infinity;\n      vim.lastHSPos = cm.charCoords(end,'div').left;\n    }\n    return retval;\n  }\n\n  /** \n   * @arg {CodeMirror} cm \n   * @arg {number} repeat \n   * @arg {boolean} [forward]\n   * @arg {string} [character]\n   * @arg {Pos} [head]\n   */\n  function moveToCharacter(cm, repeat, forward, character, head) {\n    if (!character) return;\n    var cur = head || cm.getCursor();\n    var start = cur.ch;\n    var idx;\n    for (var i = 0; i < repeat; i ++) {\n      var line = cm.getLine(cur.line);\n      idx = charIdxInLine(start, line, character, forward);\n      if (idx == -1) {\n        return undefined;\n      }\n      start = idx;\n    }\n    if (idx != undefined)\n      return new Pos(cm.getCursor().line, idx);\n  }\n\n  /** @arg {CodeMirrorV} cm @arg {number} repeat */\n  function moveToColumn(cm, repeat) {\n    // repeat is always >= 1, so repeat - 1 always corresponds\n    // to the column we want to go to.\n    var line = cm.getCursor().line;\n    return clipCursorToContent(cm, new Pos(line, repeat - 1));\n  }\n\n  /**\n   * @arg {CodeMirror} cm \n   * @arg {vimState} vim \n   * @arg {string} markName \n   * @arg {Pos} pos */\n  function updateMark(cm, vim, markName, pos) {\n    if (!inArray(markName, validMarks) && !latinCharRegex.test(markName)) {\n      return;\n    }\n    if (vim.marks[markName]) {\n      vim.marks[markName].clear();\n    }\n    vim.marks[markName] = cm.setBookmark(pos);\n  }\n\n  /**\n   * @arg {number} start \n   * @arg {string | any[]} line \n   * @arg {any} character \n   * @arg {boolean} [forward] \n   * @arg {boolean} [includeChar] */\n  function charIdxInLine(start, line, character, forward, includeChar) {\n    // Search for char in line.\n    // motion_options: {forward, includeChar}\n    // If includeChar = true, include it too.\n    // If forward = true, search forward, else search backwards.\n    // If char is not found on this line, do nothing\n    var idx;\n    if (forward) {\n      idx = line.indexOf(character, start + 1);\n    } else {\n      idx = line.lastIndexOf(character, start - 1);\n    }\n    return idx;\n  }\n\n  /** @arg {CodeMirrorV} cm \n   * @arg {Pos} head \n   * @arg {number} repeat \n   * @arg {number} dir \n   * @arg {boolean} [inclusive] */\n  function findParagraph(cm, head, repeat, dir, inclusive) {\n    var line = head.line;\n    var min = cm.firstLine();\n    var max = cm.lastLine();\n    var start, end, i = line;\n    /** @arg {number} i */\n    function isEmpty(i) { return !cm.getLine(i); }\n    /** @arg {number} i @arg {number} dir @arg {boolean} [any] */\n    function isBoundary(i, dir, any) {\n      if (any) { return isEmpty(i) != isEmpty(i + dir); }\n      return !isEmpty(i) && isEmpty(i + dir);\n    }\n    if (dir) {\n      while (min <= i && i <= max && repeat > 0) {\n        if (isBoundary(i, dir)) { repeat--; }\n        i += dir;\n      }\n      return {start: new Pos(i, 0), end: head};\n    }\n\n    var vim = cm.state.vim;\n    if (vim.visualLine && isBoundary(line, 1, true)) {\n      var anchor = vim.sel.anchor;\n      if (isBoundary(anchor.line, -1, true)) {\n        if (!inclusive || anchor.line != line) {\n          line += 1;\n        }\n      }\n    }\n    var startState = isEmpty(line);\n    for (i = line; i <= max && repeat; i++) {\n      if (isBoundary(i, 1, true)) {\n        if (!inclusive || isEmpty(i) != startState) {\n          repeat--;\n        }\n      }\n    }\n    end = new Pos(i, 0);\n    // select boundary before paragraph for the last one\n    if (i > max && !startState) { startState = true; }\n    else { inclusive = false; }\n    for (i = line; i > min; i--) {\n      if (!inclusive || isEmpty(i) == startState || i == line) {\n        if (isBoundary(i, -1, true)) { break; }\n      }\n    }\n    start = new Pos(i, 0);\n    return { start: start, end: end };\n  }\n\n  /**\n   * Based on {@link findSentence}. The internal functions have the same names,\n   * but their behaviour is different. findSentence() crosses line breaks and \n   * is used for jumping to sentence beginnings before or after the current cursor position, \n   * whereas getSentence() is for getting the beginning or end of the sentence \n   * at the current cursor position, either including (a) or excluding (i) whitespace.\n   * @arg {CodeMirror} cm\n   * @arg {Pos} cur\n   * @arg {number} repeat\n   * @arg {1|-1} dir\n   * @arg {boolean} inclusive\n   */\n  function getSentence(cm, cur, repeat, dir, inclusive /*includes whitespace*/) {\n\n    /**\n      Takes an index object\n      @arg {{\n        line: string|null,\n        ln:  number,\n        pos: number,\n        dir: -1|1\n      }} curr\n      and modifies the pos member to represent the\n      next valid position or sets the line to null if there are\n      no more valid positions.\n      */\n    function nextChar(curr) {\n      if (curr.line === null) return;\n      if (curr.pos + curr.dir < 0 || curr.pos + curr.dir >= curr.line.length) {\n        curr.line = null;\n      }\n      else {\n        curr.pos += curr.dir;\n      }\n    }\n    /**\n     * Performs one iteration of traversal in forward direction\n     * Returns an index object of the sentence end\n     * @arg {CodeMirror} cm\n     * @arg {number} ln\n     * @arg {number} pos\n     * @arg {1|-1} dir\n     */\n    function forward(cm, ln, pos, dir) {\n      var line = cm.getLine(ln);\n\n      var curr = {\n        line: line,\n        ln: ln,\n        pos: pos,\n        dir: dir,\n      };\n\n      if (curr.line === \"\") {\n        return { ln: curr.ln, pos: curr.pos };\n      }\n\n      var lastSentencePos = curr.pos;\n\n      // Move one step to skip character we start on\n      nextChar(curr);\n\n      while (curr.line !== null) {\n        lastSentencePos = curr.pos;\n        if (isEndOfSentenceSymbol(curr.line[curr.pos])) {\n          if (!inclusive) {\n            return { ln: curr.ln, pos: curr.pos + 1 };\n          } \n          else {\n            nextChar(curr);\n            while (curr.line !== null ) {\n              if (isWhiteSpaceString(curr.line[curr.pos])) {\n                lastSentencePos = curr.pos;\n                nextChar(curr);\n              } \n              else {\n                break;\n              }\n            }\n            return { ln: curr.ln, pos: lastSentencePos + 1 };\n          }\n        }\n        nextChar(curr);\n      }\n      return { ln: curr.ln, pos: lastSentencePos + 1 };\n    }\n\n    /** \n     * Performs one iteration of traversal in reverse direction\n     * Returns an index object of the sentence start\n     * @arg {CodeMirror} cm  \n     * @arg {number} ln  \n     * @arg {number} pos  \n     * @arg {1|-1} dir\n     */\n    function reverse(cm, ln, pos, dir) {\n      var line = cm.getLine(ln);\n\n      var curr = {\n        line: line,\n        ln: ln,\n        pos: pos,\n        dir: dir,\n      };\n\n      if (curr.line === \"\") {\n        return { ln: curr.ln, pos: curr.pos };\n      }\n\n      var lastSentencePos = curr.pos;\n\n      // Move one step to skip character we start on\n      nextChar(curr);\n\n      while (curr.line !== null) {\n        if (!isWhiteSpaceString(curr.line[curr.pos]) && !isEndOfSentenceSymbol(curr.line[curr.pos])) {\n          lastSentencePos = curr.pos;\n        }\n\n        else if (isEndOfSentenceSymbol(curr.line[curr.pos]) ) {\n          if (!inclusive) {\n            return { ln: curr.ln, pos: lastSentencePos };\n          } \n          else {\n            if (isWhiteSpaceString(curr.line[curr.pos + 1])) {\n              return { ln: curr.ln, pos: curr.pos + 1 };\n            } \n            else {\n              return { ln: curr.ln, pos: lastSentencePos };\n            }\n          }\n        }\n\n        nextChar(curr);\n      }\n      curr.line = line;\n      if (inclusive && isWhiteSpaceString(curr.line[curr.pos])) {\n        return { ln: curr.ln, pos: curr.pos };\n      } \n      else {\n        return { ln: curr.ln, pos: lastSentencePos };\n      }\n\n    }\n\n    var curr_index = {\n      ln: cur.line,\n      pos: cur.ch,\n    };\n\n    while (repeat > 0) {\n      if (dir < 0) {\n        curr_index = reverse(cm, curr_index.ln, curr_index.pos, dir);\n      }\n      else {\n        curr_index = forward(cm, curr_index.ln, curr_index.pos, dir);\n      }\n      repeat--;\n    }\n\n    return new Pos(curr_index.ln, curr_index.pos);\n  }\n  /**\n   * @arg {CodeMirror} cm\n   * @arg {Pos} cur\n   * @arg {number} repeat\n   * @arg {number} dir\n   */\n  function findSentence(cm, cur, repeat, dir) {\n\n      /**\n       * @arg {CodeMirror} cm\n        Takes an index object\n        @arg { {\n          line: string|null,\n          ln: number, // line number\n          pos: number, // index in line,\n          dir: number // direction of traversal (-1 or 1)\n        }} idx\n        and modifies the line, ln, and pos members to represent the\n        next valid position or sets them to null if there are\n        no more valid positions.\n      */\n    function nextChar(cm, idx) {\n      if (idx.line === null) return;\n      if (idx.pos + idx.dir < 0 || idx.pos + idx.dir >= idx.line.length) {\n        idx.ln += idx.dir;\n        if (!isLine(cm, idx.ln)) {\n          idx.line = null;\n          return;\n        }\n        idx.line = cm.getLine(idx.ln);\n        idx.pos = (idx.dir > 0) ? 0 : idx.line.length - 1;\n      }\n      else {\n        idx.pos += idx.dir;\n      }\n    }\n\n    /*\n      Performs one iteration of traversal in forward direction\n      Returns an index object of the new location\n      */\n    /** @arg {CodeMirror} cm @arg {number} ln  @arg {number} pos  @arg {number} dir */\n    function forward(cm, ln, pos, dir) {\n      var line = cm.getLine(ln);\n      var stop = (line === \"\");\n\n      var curr = {\n        line: line,\n        ln: ln,\n        pos: pos,\n        dir: dir,\n      };\n\n      var last_valid = {\n        ln: curr.ln,\n        pos: curr.pos,\n      };\n\n      var skip_empty_lines = (curr.line === \"\");\n\n      // Move one step to skip character we start on\n      nextChar(cm, curr);\n\n      while (curr.line !== null) {\n        last_valid.ln = curr.ln;\n        last_valid.pos = curr.pos;\n\n        if (curr.line === \"\" && !skip_empty_lines) {\n          return { ln: curr.ln, pos: curr.pos, };\n        }\n        else if (stop && curr.line !== \"\" && !isWhiteSpaceString(curr.line[curr.pos])) {\n          return { ln: curr.ln, pos: curr.pos, };\n        }\n        else if (isEndOfSentenceSymbol(curr.line[curr.pos])\n          && !stop\n          && (curr.pos === curr.line.length - 1\n            || isWhiteSpaceString(curr.line[curr.pos + 1]))) {\n          stop = true;\n        }\n\n        nextChar(cm, curr);\n      }\n\n      /*\n        Set the position to the last non whitespace character on the last\n        valid line in the case that we reach the end of the document.\n      */\n      var line = cm.getLine(last_valid.ln);\n      last_valid.pos = 0;\n      for(var i = line.length - 1; i >= 0; --i) {\n        if (!isWhiteSpaceString(line[i])) {\n          last_valid.pos = i;\n          break;\n        }\n      }\n\n      return last_valid;\n\n    }\n\n    /**\n     * Performs one iteration of traversal in reverse direction\n     * Returns an index object of the new location\n     * @arg {CodeMirror} cm  @arg {number} ln  @arg {number} pos  @arg {number} dir\n     */\n    function reverse(cm, ln, pos, dir) {\n      var line = cm.getLine(ln);\n\n      var curr = {\n        line: line,\n        ln: ln,\n        pos: pos,\n        dir: dir,\n      };\n\n      var last_valid_ln = curr.ln;\n      /**@type{number|null}*/var last_valid_pos = null;\n\n      var skip_empty_lines = (curr.line === \"\");\n\n      // Move one step to skip character we start on\n      nextChar(cm, curr);\n\n      while (curr.line !== null) {\n\n        if (curr.line === \"\" && !skip_empty_lines) {\n          if (last_valid_pos !== null) {\n            return { ln: last_valid_ln, pos: last_valid_pos };\n          }\n          else {\n            return { ln: curr.ln, pos: curr.pos };\n          }\n        }\n        else if (isEndOfSentenceSymbol(curr.line[curr.pos])\n            && last_valid_pos !== null\n            && !(curr.ln === last_valid_ln && curr.pos + 1 === last_valid_pos)) {\n          return { ln: last_valid_ln, pos: last_valid_pos  };\n        }\n        else if (curr.line !== \"\" && !isWhiteSpaceString(curr.line[curr.pos])) {\n          skip_empty_lines = false;\n          last_valid_ln = curr.ln;\n          last_valid_pos = curr.pos;\n        }\n\n        nextChar(cm, curr);\n      }\n\n      /*\n        Set the position to the first non whitespace character on the last\n        valid line in the case that we reach the beginning of the document.\n      */\n      var line = cm.getLine(last_valid_ln);\n      last_valid_pos = 0;\n      for(var i = 0; i < line.length; ++i) {\n        if (!isWhiteSpaceString(line[i])) {\n          last_valid_pos = i;\n          break;\n        }\n      }\n      return { ln: last_valid_ln, pos: last_valid_pos };\n    }\n\n    var curr_index = {\n      ln: cur.line,\n      pos: cur.ch,\n    };\n\n    while (repeat > 0) {\n      if (dir < 0) {\n        curr_index = reverse(cm, curr_index.ln, curr_index.pos, dir);\n      }\n      else {\n        curr_index = forward(cm, curr_index.ln, curr_index.pos, dir);\n      }\n      repeat--;\n    }\n\n    return new Pos(curr_index.ln, curr_index.pos);\n  }\n\n  // TODO: perhaps this finagling of start and end positions belongs\n  // in codemirror/replaceRange?\n  /** @arg {CodeMirror} cm  @arg {Pos} head @arg {string | number} symb @arg {boolean} inclusive */\n  function selectCompanionObject(cm, head, symb, inclusive) {\n    var cur = head;\n\n    var bracketRegexp = ({\n      '(': /[()]/, ')': /[()]/,\n      '[': /[[\\]]/, ']': /[[\\]]/,\n      '{': /[{}]/, '}': /[{}]/,\n      '<': /[<>]/, '>': /[<>]/})[symb];\n    var openSym = ({\n      '(': '(', ')': '(',\n      '[': '[', ']': '[',\n      '{': '{', '}': '{',\n      '<': '<', '>': '<'})[symb];\n    var curChar = cm.getLine(cur.line).charAt(cur.ch);\n    // Due to the behavior of scanForBracket, we need to add an offset if the\n    // cursor is on a matching open bracket.\n    var offset = curChar === openSym ? 1 : 0;\n\n    var startBracket = cm.scanForBracket(new Pos(cur.line, cur.ch + offset), -1, undefined, {'bracketRegex': bracketRegexp});\n    var endBracket = cm.scanForBracket(new Pos(cur.line, cur.ch + offset), 1, undefined, {'bracketRegex': bracketRegexp});\n\n    if (!startBracket || !endBracket) return null;\n\n    var start = startBracket.pos; \n    var end = endBracket.pos;\n\n    if ((start.line == end.line && start.ch > end.ch)\n        || (start.line > end.line)) {\n      var tmp = start;\n      start = end;\n      end = tmp;\n    }\n\n    if (inclusive) {\n      end.ch += 1;\n    } else {\n      start.ch += 1;\n    }\n\n    return { start: start, end: end };\n  }\n\n  // Takes in a symbol and a cursor and tries to simulate text objects that\n  // have identical opening and closing symbols\n  // TODO support across multiple lines\n  /** @arg {CodeMirror} cm  @arg {Pos} head  @arg {string} symb @arg {boolean} inclusive */\n  function findBeginningAndEnd(cm, head, symb, inclusive) {\n    var cur = copyCursor(head);\n    var line = cm.getLine(cur.line);\n    var chars = line.split('');\n    var start, end, i, len;\n    var firstIndex = chars.indexOf(symb);\n\n    // the decision tree is to always look backwards for the beginning first,\n    // but if the cursor is in front of the first instance of the symb,\n    // then move the cursor forward\n    if (cur.ch < firstIndex) {\n      cur.ch = firstIndex;\n    }\n    // otherwise if the cursor is currently on the closing symbol\n    else if (firstIndex < cur.ch && chars[cur.ch] == symb) {\n      var stringAfter = /string/.test(cm.getTokenTypeAt(offsetCursor(head, 0, 1)));\n      var stringBefore = /string/.test(cm.getTokenTypeAt(head));\n      var isStringStart = stringAfter && !stringBefore;\n      if (!isStringStart) {\n        end = cur.ch; // assign end to the current cursor\n        --cur.ch; // make sure to look backwards\n      }\n    }\n\n    // if we're currently on the symbol, we've got a start\n    if (chars[cur.ch] == symb && !end) {\n      start = cur.ch + 1; // assign start to ahead of the cursor\n    } else {\n      // go backwards to find the start\n      for (i = cur.ch; i > -1 && !start; i--) {\n        if (chars[i] == symb) {\n          start = i + 1;\n        }\n      }\n    }\n\n    // look forwards for the end symbol\n    if (start && !end) {\n      for (i = start, len = chars.length; i < len && !end; i++) {\n        if (chars[i] == symb) {\n          end = i;\n        }\n      }\n    }\n\n    // nothing found\n    if (!start || !end) {\n      return { start: cur, end: cur };\n    }\n\n    // include the symbols\n    if (inclusive) {\n      --start; ++end;\n    }\n\n    return {\n      start: new Pos(cur.line, start),\n      end: new Pos(cur.line, end)\n    };\n  }\n\n  // Search functions\n  defineOption('pcre', true, 'boolean');\n  \n  /**@type {SearchStateInterface} */\n  class SearchState {\n    constructor() {\n      /**@type{number|undefined} */\n      this.highlightTimeout;\n    }\n    getQuery() {\n      return vimGlobalState.query;\n    };\n    setQuery(query) {\n      vimGlobalState.query = query;\n    };\n    getOverlay() {\n      return this.searchOverlay;\n    };\n    setOverlay(overlay) {\n      this.searchOverlay = overlay;\n    };\n    isReversed() {\n      return vimGlobalState.isReversed;\n    };\n    setReversed(reversed) {\n      vimGlobalState.isReversed = reversed;\n    };\n    getScrollbarAnnotate() {\n      return this.annotate;\n    };\n    setScrollbarAnnotate(annotate) {\n      this.annotate = annotate;\n    };\n  }  /** @arg {CodeMirrorV} cm @returns {SearchStateInterface} */\n  function getSearchState(cm) {\n    var vim = cm.state.vim;\n    return vim.searchState_ || (vim.searchState_ = new SearchState());\n  }\n  /** @arg {string} argString */\n  function splitBySlash(argString) {\n    return splitBySeparator(argString, '/');\n  }\n\n  /** @arg {string} argString */\n  function findUnescapedSlashes(argString) {\n    return findUnescapedSeparators(argString, '/');\n  }\n\n  /** @arg {string} argString  @arg {string} separator */\n  function splitBySeparator(argString, separator) {\n    var slashes = findUnescapedSeparators(argString, separator) || [];\n    if (!slashes.length) return [];\n    var tokens = [];\n    // in case of strings like foo/bar\n    if (slashes[0] !== 0) return;\n    for (var i = 0; i < slashes.length; i++) {\n      if (typeof slashes[i] == 'number')\n        tokens.push(argString.substring(slashes[i] + 1, slashes[i+1]));\n    }\n    return tokens;\n  }\n\n  /** @arg {string} str  @arg {string} separator */\n  function findUnescapedSeparators(str, separator) {\n    if (!separator)\n      separator = '/';\n\n    var escapeNextChar = false;\n    var slashes = [];\n    for (var i = 0; i < str.length; i++) {\n      var c = str.charAt(i);\n      if (!escapeNextChar && c == separator) {\n        slashes.push(i);\n      }\n      escapeNextChar = !escapeNextChar && (c == '\\\\');\n    }\n    return slashes;\n  }\n\n  // Translates a search string from ex (vim) syntax into javascript form.\n  /** @arg {string} str */\n  function translateRegex(str) {\n    // When these match, add a '\\' if unescaped or remove one if escaped.\n    var modes = {\n      V: '|(){+?*.[$^', // verynomagic\n      M: '|(){+?*.[', // nomagic\n      m: '|(){+?', // magic\n      v: '<>', // verymagic\n    };\n    var escapes = {\n      '>': '(?<=[\\\\w])(?=[^\\\\w]|$)',\n      '<': '(?<=[^\\\\w]|^)(?=[\\\\w])',\n    };\n    var specials = modes.m;\n    var regex = str.replace(/\\\\.|[\\[|(){+*?.$^<>]/g, function(match) {\n      if (match[0] === '\\\\') {\n        var nextChar = match[1];\n        if (nextChar === '}' || specials.indexOf(nextChar) != -1) {\n          return nextChar;\n        }\n        if (nextChar in modes) {\n           specials = modes[nextChar];\n           return '';\n        }\n        if (nextChar in escapes) {\n          return escapes[nextChar];\n        }\n        return match;\n      } else {\n        if (specials.indexOf(match) != -1) {\n          return escapes[match] || '\\\\' + match; \n        }\n        return match;\n      }\n    });\n\n    var i = regex.indexOf('\\\\zs');\n    if (i != -1) {\n      regex = '(?<=' + regex.slice(0, i) + ')' + regex.slice(i + 3);\n    }\n    i = regex.indexOf('\\\\ze');\n    if (i != -1) {\n      regex = regex.slice(0, i) +  '(?=' + regex.slice(i + 3) + ')';\n    }\n\n    return regex;\n  }\n\n  // Translates the replace part of a search and replace from ex (vim) syntax into\n  // javascript form.  Similar to translateRegex, but additionally fixes back references\n  // (translates '\\[0..9]' to '$[0..9]') and follows different rules for escaping '$'.\n  /** @type{Object<string, string>} */\n  var charUnescapes = {'\\\\n': '\\n', '\\\\r': '\\r', '\\\\t': '\\t'};\n  /** @arg {string} str */\n  function translateRegexReplace(str) {\n    var escapeNextChar = false;\n    var out = [];\n    for (var i = -1; i < str.length; i++) {\n      var c = str.charAt(i) || '';\n      var n = str.charAt(i+1) || '';\n      if (charUnescapes[c + n]) {\n        out.push(charUnescapes[c+n]);\n        i++;\n      } else if (escapeNextChar) {\n        // At any point in the loop, escapeNextChar is true if the previous\n        // character was a '\\' and was not escaped.\n        out.push(c);\n        escapeNextChar = false;\n      } else {\n        if (c === '\\\\') {\n          escapeNextChar = true;\n          if ((isNumber(n) || n === '$')) {\n            out.push('$');\n          } else if (n !== '/' && n !== '\\\\') {\n            out.push('\\\\');\n          }\n        } else {\n          if (c === '$') {\n            out.push('$');\n          }\n          out.push(c);\n          if (n === '/') {\n            out.push('\\\\');\n          }\n        }\n      }\n    }\n    return out.join('');\n  }\n\n  // Unescape \\ and / in the replace part, for PCRE mode.\n  /** @type{Record<string, string>} */\n  var unescapes = {'\\\\/': '/', '\\\\\\\\': '\\\\', '\\\\n': '\\n', '\\\\r': '\\r', '\\\\t': '\\t', '\\\\&':'&'};\n  /** @arg {string} str */\n  function unescapeRegexReplace(str) {\n    var stream = new CM.StringStream(str);\n    var output = [];\n    while (!stream.eol()) {\n      // Search for \\.\n      while (stream.peek() && stream.peek() != '\\\\') {\n        output.push(stream.next());\n      }\n      var matched = false;\n      for (var matcher in unescapes) {\n        if (stream.match(matcher, true)) {\n          matched = true;\n          output.push(unescapes[matcher]);\n          break;\n        }\n      }\n      if (!matched) {\n        // Don't change anything\n        output.push(stream.next());\n      }\n    }\n    return output.join('');\n  }\n\n  /**\n   * Extract the regular expression from the query and return a Regexp object.\n   * Returns null if the query is blank.\n   * If ignoreCase is passed in, the Regexp object will have the 'i' flag set.\n   * If smartCase is passed in, and the query contains upper case letters,\n   *   then ignoreCase is overridden, and the 'i' flag will not be set.\n   * If the query contains the /i in the flag part of the regular expression,\n   *   then both ignoreCase and smartCase are ignored, and 'i' will be passed\n   *   through to the Regex object.\n   * @arg {string} query\n   * @arg {boolean} ignoreCase\n   * @arg {boolean} smartCase\n   */\n  function parseQuery(query, ignoreCase, smartCase) {\n    // First update the last search register\n    var lastSearchRegister = vimGlobalState.registerController.getRegister('/');\n    lastSearchRegister.setText(query);\n    // First try to extract regex + flags from the input. If no flags found,\n    // extract just the regex. IE does not accept flags directly defined in\n    // the regex string in the form /regex/flags\n    var slashes = findUnescapedSlashes(query);\n    var regexPart;\n    var forceIgnoreCase;\n    if (!slashes.length) {\n      // Query looks like 'regexp'\n      regexPart = query;\n    } else {\n      // Query looks like 'regexp/...'\n      regexPart = query.substring(0, slashes[0]);\n      var flagsPart = query.substring(slashes[0]);\n      forceIgnoreCase = (flagsPart.indexOf('i') != -1);\n    }\n    if (!regexPart) {\n      return null;\n    }\n    if (!getOption('pcre')) {\n      regexPart = translateRegex(regexPart);\n    }\n    if (smartCase) {\n      ignoreCase = (/^[^A-Z]*$/).test(regexPart);\n    }\n    var regexp = new RegExp(regexPart,\n        (ignoreCase || forceIgnoreCase) ? 'im' : 'm');\n    return regexp;\n  }\n\n  /**\n   * dom - Document Object Manipulator\n   * Usage:\n   *   dom('<tag>'|<node>[, ...{<attributes>|<$styles>}|<child-node>|'<text>'])\n   * Examples:\n   *   dom('div', {id:'xyz'}, dom('p', 'CM rocks!', {$color:'red'}))\n   *   dom(document.head, dom('script', 'alert(\"hello!\")'))\n   * Not supported:\n   *   dom('p', ['arrays are objects'], Error('objects specify attributes'))\n   * @arg {string | HTMLElement } n\n   */\n  function dom(n) {\n    if (typeof n === 'string') n = document.createElement(n);\n    for (var i = 1; i < arguments.length; i++) {\n      var a = arguments[i];\n      if (!a) continue;\n      if (typeof a !== 'object') a = document.createTextNode(a);\n      if (a.nodeType) n.appendChild(a);\n      else for (var key in a) {\n        if (!Object.prototype.hasOwnProperty.call(a, key)) continue;\n        if (key[0] === '$') n.style[key.slice(1)] = a[key];\n        else if (typeof a[key] == \"function\") n[key] = a[key];\n        else n.setAttribute(key, a[key]);\n      }\n    }\n    return n;\n  }\n\n  /** @arg {CodeMirror} cm  @arg {any} template  @arg {boolean} [long]*/\n  function showConfirm(cm, template, long) {\n    var pre = dom('div', {$color: 'red', $whiteSpace: 'pre', class: 'cm-vim-message'}, template);\n    if (cm.openNotification) {\n      if (long) {\n        pre = dom('div', {}, pre, dom('div', {}, 'Press ENTER or type command to continue'));\n        if (cm.state.closeVimNotification) {\n          cm.state.closeVimNotification();\n        }\n        cm.state.closeVimNotification = cm.openNotification(pre, {bottom: true, duration: 0});\n      } else {\n        cm.openNotification(pre, {bottom: true, duration: 15000});\n      }\n    } else {\n      alert(pre.innerText);\n    }\n  }\n  /** @arg {string|HTMLElement} prefix  @arg {string|HTMLElement} [desc] */\n  function makePrompt(prefix, desc) {\n    return dom('div', {$display: 'flex', $flex: 1},\n              dom('span', {$fontFamily: 'monospace', $whiteSpace: 'pre', $flex: 1, $display: 'flex'},\n                prefix,\n                dom('input', {type: 'text', autocorrect: 'off',\n                              autocapitalize: 'off', spellcheck: 'false', $flex: 1})),\n              desc && dom('span', {$color: '#888'}, desc));\n  }\n  /**\n   * @arg {CodeMirror} cm \n   * @arg {import(\"./types\").PromptOptions} options \n   */\n  function showPrompt(cm, options) {\n    if (keyToKeyStack.length) {\n      if (!options.value) options.value = '';\n      virtualPrompt = options;\n      return;\n    }\n    var template = makePrompt(options.prefix, options.desc);\n    if (cm.openDialog) {\n      cm.openDialog(template, options.onClose, {\n        onKeyDown: options.onKeyDown, onKeyUp: options.onKeyUp,\n        bottom: true, selectValueOnOpen: false, value: options.value\n      });\n    }\n    else {\n      var shortText = '';\n      if (typeof options.prefix != \"string\" && options.prefix) shortText += options.prefix.textContent;\n      if (options.desc) shortText += \" \" + options.desc;\n      options.onClose?.(prompt(shortText, ''));\n    }\n  }\n\n  /** @arg {RegExp|unknown} r1  @arg {RegExp|unknown} r2 */\n  function regexEqual(r1, r2) {\n    if (r1 instanceof RegExp && r2 instanceof RegExp) {\n      return r1.flags == r2.flags && r1.source == r2.source;\n    }\n    return false;\n  }\n  // Returns true if the query is valid.\n  /**\n   * @arg {CodeMirrorV} cm \n   * @arg {string } rawQuery \n   * @arg {boolean | undefined} [ignoreCase] \n   * @arg {boolean | undefined} [smartCase]\n  */\n  function updateSearchQuery(cm, rawQuery, ignoreCase, smartCase) {\n    if (!rawQuery) {\n      return;\n    }\n    var state = getSearchState(cm);\n    var query = parseQuery(rawQuery, !!ignoreCase, !!smartCase);\n    if (!query) {\n      return;\n    }\n    highlightSearchMatches(cm, query);\n    if (regexEqual(query, state.getQuery())) {\n      return query;\n    }\n    state.setQuery(query);\n    return query;\n  }\n  /** @arg {RegExp} query */\n  function searchOverlay(query) {\n    if (query.source.charAt(0) == '^') {\n      var matchSol = true;\n    }\n    return {\n      token: function(stream) {\n        if (matchSol && !stream.sol()) {\n          stream.skipToEnd();\n          return;\n        }\n        var match = stream.match(query, false);\n        if (match) {\n          if (match[0].length == 0) {\n            // Matched empty string, skip to next.\n            stream.next();\n            return 'searching';\n          }\n          if (!stream.sol()) {\n            // Backtrack 1 to match \\b\n            stream.backUp(1);\n            if (!query.exec(stream.next() + match[0])) {\n              stream.next();\n              return null;\n            }\n          }\n          stream.match(query);\n          return 'searching';\n        }\n        while (!stream.eol()) {\n          stream.next();\n          if (stream.match(query, false)) break;\n        }\n      },\n      query: query\n    };\n  }\n  var highlightTimeout = 0;\n  /** @arg {CodeMirrorV} cm  @arg {RegExp} query */\n  function highlightSearchMatches(cm, query) {\n    clearTimeout(highlightTimeout);\n    var searchState = getSearchState(cm);\n    searchState.highlightTimeout = highlightTimeout;\n    highlightTimeout = setTimeout(function() {\n      if (!cm.state.vim) return;\n      var searchState = getSearchState(cm);\n      searchState.highlightTimeout = undefined;\n      var overlay = searchState.getOverlay();\n      if (!overlay || query != overlay.query) {\n        if (overlay) {\n          cm.removeOverlay(overlay);\n        }\n        overlay = searchOverlay(query);\n        cm.addOverlay(overlay);\n        if (cm.showMatchesOnScrollbar) {\n          if (searchState.getScrollbarAnnotate()) {\n            searchState.getScrollbarAnnotate().clear();\n          }\n          searchState.setScrollbarAnnotate(cm.showMatchesOnScrollbar(query));\n        }\n        searchState.setOverlay(overlay);\n      }\n    }, 50);\n  }\n  /** @arg {CodeMirror} cm @arg {boolean} prev @arg {RegExp} query @arg {number | undefined} [repeat] */\n  function findNext(cm, prev, query, repeat) {\n    return cm.operation(function() {\n      if (repeat === undefined) { repeat = 1; }\n      var pos = cm.getCursor();\n      var cursor = cm.getSearchCursor(query, pos);\n      for (var i = 0; i < repeat; i++) {\n        var found = cursor.find(prev);\n        // @ts-ignore\n        if (i == 0 && found && cursorEqual(cursor.from(), pos)) {\n          var lastEndPos = prev ? cursor.from() : cursor.to();\n          found = cursor.find(prev);\n          // @ts-ignore\n          if (found && !found[0] && cursorEqual(cursor.from(), lastEndPos)) {\n            // @ts-ignore\n            if (cm.getLine(lastEndPos.line).length == lastEndPos.ch)\n              found = cursor.find(prev);\n          }\n        }\n        if (!found) {\n          // SearchCursor may have returned null because it hit EOF, wrap\n          // around and try again.\n          cursor = cm.getSearchCursor(query,\n              // @ts-ignore\n              (prev) ? new Pos(cm.lastLine()) : new Pos(cm.firstLine(), 0) );\n          if (!cursor.find(prev)) {\n            return;\n          }\n        }\n      }\n      return cursor.from();\n    });\n  }\n  /**\n   * Pretty much the same as `findNext`, except for the following differences:\n   *\n   * 1. Before starting the search, move to the previous search. This way if our cursor is\n   * already inside a match, we should return the current match.\n   * 2. Rather than only returning the cursor's from, we return the cursor's from and to as a tuple.\n   * @arg {CodeMirror} cm\n   * @arg {boolean} prev\n   * @arg {RegExp} query\n   * @arg {number | undefined} repeat\n   * @arg {vimState} vim\n   * @returns {[Pos, Pos] | undefined}\n   */\n  function findNextFromAndToInclusive(cm, prev, query, repeat, vim) {\n    return cm.operation(function() {\n      if (repeat === undefined) { repeat = 1; }\n      var pos = cm.getCursor();\n      var cursor = cm.getSearchCursor(query, pos);\n\n      // Go back one result to ensure that if the cursor is currently a match, we keep it.\n      var found = cursor.find(!prev);\n\n      // If we haven't moved, go back one more (similar to if i==0 logic in findNext).\n      // @ts-ignore\n      if (!vim.visualMode && found && cursorEqual(cursor.from(), pos)) {\n        cursor.find(!prev);\n      }\n\n      for (var i = 0; i < repeat; i++) {\n        found = cursor.find(prev);\n        if (!found) {\n          // SearchCursor may have returned null because it hit EOF, wrap\n          // around and try again.\n          cursor = cm.getSearchCursor(query,\n              // @ts-ignore\n              (prev) ? new Pos(cm.lastLine()) : new Pos(cm.firstLine(), 0) );\n          if (!cursor.find(prev)) {\n            return;\n          }\n        }\n      }\n      var from = cursor.from();\n      var to = cursor.to();\n      return from && to && [from, to];\n    });\n  }\n  /** @arg {CodeMirrorV} cm */\n  function clearSearchHighlight(cm) {\n    var state = getSearchState(cm);\n    if (state.highlightTimeout) {\n      clearTimeout(state.highlightTimeout);\n      state.highlightTimeout = undefined;\n    }\n    cm.removeOverlay(getSearchState(cm).getOverlay());\n    state.setOverlay(null);\n    if (state.getScrollbarAnnotate()) {\n      state.getScrollbarAnnotate().clear();\n      state.setScrollbarAnnotate(null);\n    }\n  }\n  /**\n   * Check if pos is in the specified range, INCLUSIVE.\n   * Range can be specified with 1 or 2 arguments.\n   * If the first range argument is an array, treat it as an array of line\n   * numbers. Match pos against any of the lines.\n   * If the first range argument is a number,\n   *   if there is only 1 range argument, check if pos has the same line\n   *       number\n   *   if there are 2 range arguments, then check if pos is in between the two\n   *       range arguments.\n   * @arg {number|Pos} pos\n   * @arg {number|number[]} start\n   * @arg {number} end\n   */\n  function isInRange(pos, start, end) {\n    if (typeof pos != 'number') {\n      // Assume it is a cursor position. Get the line number.\n      pos = pos.line;\n    }\n    if (start instanceof Array) {\n      return inArray(pos, start);\n    } else {\n      if (typeof end == 'number') {\n        return (pos >= start && pos <= end);\n      } else {\n        return pos == start;\n      }\n    }\n  }\n  /** @arg {CodeMirror} cm */\n  function getUserVisibleLines(cm) {\n    var scrollInfo = cm.getScrollInfo();\n    var occludeToleranceTop = 6;\n    var occludeToleranceBottom = 10;\n    var from = cm.coordsChar({left:0, top: occludeToleranceTop + scrollInfo.top}, 'local');\n    var bottomY = scrollInfo.clientHeight - occludeToleranceBottom + scrollInfo.top;\n    var to = cm.coordsChar({left:0, top: bottomY}, 'local');\n    return {top: from.line, bottom: to.line};\n  }\n\n  /** @arg {CodeMirror} cm @arg {vimState} vim  @arg {string} markName */\n  function getMarkPos(cm, vim, markName) {\n    if (markName == '\\'' || markName == '`') {\n      return vimGlobalState.jumpList.find(cm, -1) || new Pos(0, 0);\n    } else if (markName == '.') {\n      return getLastEditPos(cm);\n    }\n\n    var mark = vim.marks[markName];\n    return mark && mark.find();\n  }\n\n  /** @arg {CodeMirror} cm */\n  function getLastEditPos(cm) {\n    if (cm.getLastEditEnd) {\n      return cm.getLastEditEnd();\n    }\n    // for old cm\n    var done = /**@type{any}*/(cm).doc.history.done;\n    for (var i = done.length; i--;) {\n      if (done[i].changes) {\n        return copyCursor(done[i].changes[0].to);\n      }\n    }\n  }\n\n  class ExCommandDispatcher {\n    constructor() {\n      /**@type {Record<string, import(\"./types\").exCommandDefinition>} */\n      this.commandMap_;\n      this.buildCommandMap_();\n    }\n    /**\n     * @arg {CodeMirrorV} cm\n     * @arg {string} input\n     * @arg {{ callback: () => void; } | undefined} [opt_params]\n     */\n    processCommand(cm, input, opt_params) {\n      var that = this;\n      cm.operation(function () {\n        if (cm.curOp) cm.curOp.isVimOp = true;\n        that._processCommand(cm, input, opt_params);\n      });\n    }\n    /**\n     * @arg {CodeMirrorV} cm\n     * @arg {string} input\n     * @arg {{ callback?: () => void; input?: string, line?: string, commandName?: string  } } [opt_params]\n     */\n    _processCommand(cm, input, opt_params) {\n      var vim = cm.state.vim;\n      var commandHistoryRegister = vimGlobalState.registerController.getRegister(':');\n      var previousCommand = commandHistoryRegister.toString();\n      var inputStream = new CM.StringStream(input);\n      // update \": with the latest command whether valid or invalid\n      commandHistoryRegister.setText(input);\n      var params = opt_params || {};\n      params.input = input;\n      try {\n        this.parseInput_(cm, inputStream, params);\n      } catch(e) {\n        showConfirm(cm, e + \"\");\n        throw e;\n      }\n\n      if (vim.visualMode) {\n        exitVisualMode(cm);\n      }\n\n      var command;\n      var commandName;\n      if (!params.commandName) {\n        // If only a line range is defined, move to the line.\n        if (params.line !== undefined) {\n          commandName = 'move';\n        }\n      } else {\n        command = this.matchCommand_(params.commandName);\n        if (command) {\n          commandName = command.name;\n          if (command.excludeFromCommandHistory) {\n            commandHistoryRegister.setText(previousCommand);\n          }\n          this.parseCommandArgs_(inputStream, params, command);\n          if (command.type == 'exToKey') {\n            // Handle Ex to Key mapping.\n            doKeyToKey(cm, command.toKeys || '', command);\n            return;\n          } else if (command.type == 'exToEx') {\n            // Handle Ex to Ex mapping.\n            this.processCommand(cm, command.toInput || '');\n            return;\n          }\n        }\n      }\n      if (!commandName) {\n        showConfirm(cm, 'Not an editor command \":' + input + '\"');\n        return;\n      }\n      try {\n        exCommands[commandName](cm, params);\n        // Possibly asynchronous commands (e.g. substitute, which might have a\n        // user confirmation), are responsible for calling the callback when\n        // done. All others have it taken care of for them here.\n        if ((!command || !command.possiblyAsync) && params.callback) {\n          params.callback();\n        }\n      } catch(e) {\n        showConfirm(cm, e + \"\");\n        throw e;\n      }\n    }\n    /**\n     * @param {CodeMirrorV} cm\n     * @param {import(\"@codemirror/language\").StringStream} inputStream\n     * @param {{ callback?: (() => void) | undefined; input?: string | undefined; line?: any; commandName?: any; lineEnd?: any; selectionLine?: any; selectionLineEnd?: any; }} result\n     */\n    parseInput_(cm, inputStream, result) {\n      inputStream.eatWhile(':');\n      // Parse range.\n      if (inputStream.eat('%')) {\n        result.line = cm.firstLine();\n        result.lineEnd = cm.lastLine();\n      } else {\n        result.line = this.parseLineSpec_(cm, inputStream);\n        if (result.line !== undefined && inputStream.eat(',')) {\n          result.lineEnd = this.parseLineSpec_(cm, inputStream);\n        }\n      }\n\n      if (result.line == undefined) {\n        if (cm.state.vim.visualMode) {\n          result.selectionLine = getMarkPos(cm, cm.state.vim, '<')?.line;\n          result.selectionLineEnd = getMarkPos(cm, cm.state.vim, '>')?.line;\n        } else {\n          result.selectionLine = cm.getCursor().line;\n        }\n      } else {\n        result.selectionLine = result.line;\n        result.selectionLineEnd = result.lineEnd;\n      }\n\n      // Parse command name.\n      var commandMatch = inputStream.match(/^(\\w+|!!|@@|[!#&*<=>@~])/);\n      if (commandMatch) {\n        result.commandName = commandMatch[1];\n      } else {\n        result.commandName = (inputStream.match(/.*/) || [\"\"])[0];\n      }\n\n      return result;\n    }\n    /**\n     * @param {CodeMirrorV} cm\n     * @param {import(\"@codemirror/language\").StringStream} inputStream\n     */\n    parseLineSpec_(cm, inputStream) {\n      var numberMatch = inputStream.match(/^(\\d+)/);\n      if (numberMatch) {\n        // Absolute line number plus offset (N+M or N-M) is probably a typo,\n        // not something the user actually wanted. (NB: vim does allow this.)\n        return parseInt(numberMatch[1], 10) - 1;\n      }\n      switch (inputStream.next()) {\n        case '.':\n          return this.parseLineSpecOffset_(inputStream, cm.getCursor().line);\n        case '$':\n          return this.parseLineSpecOffset_(inputStream, cm.lastLine());\n        case '\\'':\n          var markName = inputStream.next() || \"\";\n          var markPos = getMarkPos(cm, cm.state.vim, markName);\n          if (!markPos) throw new Error('Mark not set');\n          return this.parseLineSpecOffset_(inputStream, markPos.line);\n        case '-':\n        case '+':\n          inputStream.backUp(1);\n          // Offset is relative to current line if not otherwise specified.\n          return this.parseLineSpecOffset_(inputStream, cm.getCursor().line);\n        default:\n          inputStream.backUp(1);\n          return undefined;\n      }\n    }\n    /**\n     * @param {string | import(\"@codemirror/language\").StringStream} inputStream\n     * @param {number} line\n     */\n    parseLineSpecOffset_(inputStream, line) {\n      var offsetMatch = inputStream.match(/^([+-])?(\\d+)/);\n      if (offsetMatch) {\n        var offset = parseInt(offsetMatch[2], 10);\n        if (offsetMatch[1] == \"-\") {\n          line -= offset;\n        } else {\n          line += offset;\n        }\n      }\n      return line;\n    }\n    /**\n     * @param {import(\"@codemirror/language\").StringStream} inputStream\n     * @param {import(\"./types\").exCommandArgs} params\n     * @param {import(\"./types\").exCommandDefinition} command\n     */\n    parseCommandArgs_(inputStream, params, command) {\n      if (inputStream.eol()) {\n        return;\n      }\n      params.argString = inputStream.match(/.*/)?.[0];\n      // Parse command-line arguments\n      var delim = command.argDelimiter || /\\s+/;\n      var args = trim(params.argString || \"\").split(delim);\n      if (args.length && args[0]) {\n        params.args = args;\n      }\n    }\n    /**\n     * @arg {string} commandName\n     */\n    matchCommand_(commandName) {\n      // Return the command in the command map that matches the shortest\n      // prefix of the passed in command name. The match is guaranteed to be\n      // unambiguous if the defaultExCommandMap's shortNames are set up\n      // correctly. (see @code{defaultExCommandMap}).\n      for (var i = commandName.length; i > 0; i--) {\n        var prefix = commandName.substring(0, i);\n        if (this.commandMap_[prefix]) {\n          var command = this.commandMap_[prefix];\n          if (command.name.indexOf(commandName) === 0) {\n            return command;\n          }\n        }\n      }\n    }\n    buildCommandMap_() {\n      this.commandMap_ = {};\n      for (var i = 0; i < defaultExCommandMap.length; i++) {\n        var command = defaultExCommandMap[i];\n        var key = command.shortName || command.name;\n        this.commandMap_[key] = command;\n      }\n    }\n    /**@type {(lhs: string, rhs: string, ctx: string|void, noremap?: boolean) => void} */\n    map(lhs, rhs, ctx, noremap) {\n      if (lhs != ':' && lhs.charAt(0) == ':') {\n        if (ctx) { throw Error('Mode not supported for ex mappings'); }\n        var commandName = lhs.substring(1);\n        if (rhs != ':' && rhs.charAt(0) == ':') {\n          // Ex to Ex mapping\n          this.commandMap_[commandName] = {\n            name: commandName,\n            type: 'exToEx',\n            toInput: rhs.substring(1),\n            user: true\n          };\n        } else {\n          // Ex to key mapping\n          this.commandMap_[commandName] = {\n            name: commandName,\n            type: 'exToKey',\n            toKeys: rhs,\n            user: true\n          };\n        }\n      } else {\n        // Key to key or ex mapping\n        /**@type {vimKey} */\n        var mapping = {\n          keys: lhs,\n          type: 'keyToKey',\n          toKeys: rhs,\n          noremap: !!noremap\n        };\n        if (ctx) { mapping.context = ctx; }\n        _mapCommand(mapping);\n      }\n    }\n    /**@type {(lhs: string, ctx: string) => boolean|void} */\n    unmap(lhs, ctx) {\n      if (lhs != ':' && lhs.charAt(0) == ':') {\n        // Ex to Ex or Ex to key mapping\n        if (ctx) { throw Error('Mode not supported for ex mappings'); }\n        var commandName = lhs.substring(1);\n        if (this.commandMap_[commandName] && this.commandMap_[commandName].user) {\n          delete this.commandMap_[commandName];\n          return true;\n        }\n      } else {\n        // Key to Ex or key to key mapping\n        var keys = lhs;\n        for (var i = 0; i < defaultKeymap.length; i++) {\n          if (keys == defaultKeymap[i].keys\n              && defaultKeymap[i].context === ctx) {\n            defaultKeymap.splice(i, 1);\n            removeUsedKeys(keys);\n            return true;\n          }\n        }\n      }\n    }\n  }\n\n  /** @typedef { import(\"./types\").ExParams} ExParams */\n  var exCommands = {\n    /** @arg {CodeMirrorV} cm @arg {ExParams} params*/\n    colorscheme: function(cm, params) {\n      if (!params.args || params.args.length < 1) {\n        showConfirm(cm, cm.getOption('theme'));\n        return;\n      }\n      cm.setOption('theme', params.args[0]);\n    },\n    /** @arg {CodeMirrorV} cm @arg {ExParams} params @arg {'insert'|'normal'|string} [ctx] @arg {boolean} [defaultOnly]*/\n    map: function(cm, params, ctx, defaultOnly) {\n      var mapArgs = params.args;\n      if (!mapArgs || mapArgs.length < 2) {\n        if (cm) {\n          showConfirm(cm, 'Invalid mapping: ' + params.input);\n        }\n        return;\n      }\n      exCommandDispatcher.map(mapArgs[0], mapArgs[1], ctx, defaultOnly);\n    },\n    /** @arg {CodeMirrorV} cm @arg {ExParams} params*/\n    imap: function(cm, params) { this.map(cm, params, 'insert'); },\n    /** @arg {CodeMirrorV} cm @arg {ExParams} params*/\n    nmap: function(cm, params) { this.map(cm, params, 'normal'); },\n    /** @arg {CodeMirrorV} cm @arg {ExParams} params*/\n    vmap: function(cm, params) { this.map(cm, params, 'visual'); },\n    /** @arg {CodeMirrorV} cm @arg {ExParams} params*/\n    omap: function(cm, params) { this.map(cm, params, 'operatorPending'); },\n    /** @arg {CodeMirrorV} cm @arg {ExParams} params*/\n    noremap: function(cm, params) { this.map(cm, params, undefined, true); },\n    /** @arg {CodeMirrorV} cm @arg {ExParams} params*/\n    inoremap: function(cm, params) { this.map(cm, params, 'insert', true); },\n    /** @arg {CodeMirrorV} cm @arg {ExParams} params*/\n    nnoremap: function(cm, params) { this.map(cm, params, 'normal', true); },\n    /** @arg {CodeMirrorV} cm @arg {ExParams} params*/\n    vnoremap: function(cm, params) { this.map(cm, params, 'visual', true); },\n    /** @arg {CodeMirrorV} cm @arg {ExParams} params*/\n    onoremap: function(cm, params) { this.map(cm, params, 'operatorPending', true); },\n    /** @arg {CodeMirrorV} cm @arg {ExParams} params @arg {string} ctx*/\n    unmap: function(cm, params, ctx) {\n      var mapArgs = params.args;\n      if (!mapArgs || mapArgs.length < 1 || !exCommandDispatcher.unmap(mapArgs[0], ctx)) {\n        if (cm) {\n          showConfirm(cm, 'No such mapping: ' + params.input);\n        }\n      }\n    },\n    /** @arg {CodeMirrorV} cm @arg {ExParams} params*/\n    mapclear: function(cm, params) { vimApi.mapclear(); },\n    /** @arg {CodeMirrorV} cm @arg {ExParams} params*/\n    imapclear: function(cm, params) { vimApi.mapclear('insert'); },\n    /** @arg {CodeMirrorV} cm @arg {ExParams} params*/\n    nmapclear: function(cm, params) { vimApi.mapclear('normal'); },\n    /** @arg {CodeMirrorV} cm @arg {ExParams} params*/\n    vmapclear: function(cm, params) { vimApi.mapclear('visual'); },\n    /** @arg {CodeMirrorV} cm @arg {ExParams} params*/\n    omapclear: function(cm, params) { vimApi.mapclear('operatorPending'); },\n    /** @arg {CodeMirrorV} cm @arg {ExParams} params*/\n    move: function(cm, params) {\n      commandDispatcher.processCommand(cm, cm.state.vim, {\n        keys: \"\",\n        type: 'motion',\n        motion: 'moveToLineOrEdgeOfDocument',\n        motionArgs: { forward: false, explicitRepeat: true, linewise: true },\n        repeatOverride: params.line+1\n      });\n    },\n    /** @arg {CodeMirrorV} cm @arg {ExParams} params*/\n    set: function(cm, params) {\n      var setArgs = params.args;\n      // Options passed through to the setOption/getOption calls. May be passed in by the\n      // local/global versions of the set command\n      var setCfg = params.setCfg || {};\n      if (!setArgs || setArgs.length < 1) {\n        if (cm) {\n          showConfirm(cm, 'Invalid mapping: ' + params.input);\n        }\n        return;\n      }\n      var expr = setArgs[0].split('=');\n      var optionName = expr.shift() || \"\";\n      /**@type {string|boolean|undefined} */\n      var value = expr.length > 0 ? expr.join('=') : undefined;\n      var forceGet = false;\n      var forceToggle = false;\n\n      if (optionName.charAt(optionName.length - 1) == '?') {\n        // If post-fixed with ?, then the set is actually a get.\n        if (value) { throw Error('Trailing characters: ' + params.argString); }\n        optionName = optionName.substring(0, optionName.length - 1);\n        forceGet = true;\n      } else if (optionName.charAt(optionName.length - 1) == '!') {\n        optionName = optionName.substring(0, optionName.length - 1);\n        forceToggle = true;\n      }\n      if (value === undefined && optionName.substring(0, 2) == 'no') {\n        // To set boolean options to false, the option name is prefixed with\n        // 'no'.\n        optionName = optionName.substring(2);\n        value = false;\n      }\n\n      var optionIsBoolean = options[optionName] && options[optionName].type == 'boolean';\n      if (optionIsBoolean) {\n        if (forceToggle) {\n          value = !getOption(optionName, cm, setCfg);\n        } else if (value == undefined) {\n          // Calling set with a boolean option sets it to true.\n          value = true;\n        }\n      }\n      // If no value is provided, then we assume this is a get.\n      if (!optionIsBoolean && value === undefined || forceGet) {\n        var oldValue = getOption(optionName, cm, setCfg);\n        if (oldValue instanceof Error) {\n          showConfirm(cm, oldValue.message);\n        } else if (oldValue === true || oldValue === false) {\n          showConfirm(cm, ' ' + (oldValue ? '' : 'no') + optionName);\n        } else {\n          showConfirm(cm, '  ' + optionName + '=' + oldValue);\n        }\n      } else {\n        var setOptionReturn = setOption(optionName, value, cm, setCfg);\n        if (setOptionReturn instanceof Error) {\n          showConfirm(cm, setOptionReturn.message);\n        }\n      }\n    },\n    /** @arg {CodeMirrorV} cm @arg {ExParams} params*/\n    setlocal: function (cm, params) {\n      // setCfg is passed through to setOption\n      params.setCfg = {scope: 'local'};\n      this.set(cm, params);\n    },\n    /** @arg {CodeMirrorV} cm @arg {ExParams} params*/\n    setglobal: function (cm, params) {\n      // setCfg is passed through to setOption\n      params.setCfg = {scope: 'global'};\n      this.set(cm, params);\n    },\n    /** @arg {CodeMirrorV} cm @arg {ExParams} params*/\n    registers: function(cm, params) {\n      var regArgs = params.args;\n      var registers = vimGlobalState.registerController.registers;\n      var regInfo = '----------Registers----------\\n\\n';\n      if (!regArgs) {\n        for (var registerName in registers) {\n          var text = registers[registerName].toString();\n          if (text.length) {\n            regInfo += '\"' + registerName + '    ' + text + '\\n';\n          }\n        }\n      } else {\n        var registerNames = regArgs.join('');\n        for (var i = 0; i < registerNames.length; i++) {\n          var registerName = registerNames.charAt(i);\n          if (!vimGlobalState.registerController.isValidRegister(registerName)) {\n            continue;\n          }\n          var register = registers[registerName] || new Register();\n          regInfo += '\"' + registerName + '    ' + register.toString() + '\\n';\n        }\n      }\n      showConfirm(cm, regInfo, true);\n    },\n    /** @arg {CodeMirrorV} cm @arg {ExParams} params*/\n    marks: function(cm, params) {\n      var filterArgs = params.args;\n      var marks = cm.state.vim.marks;\n      var regInfo = '-----------Marks-----------\\nmark\\tline\\tcol\\n\\n';\n      if (!filterArgs) {\n        for (var name in marks) {\n          var marker = marks[name] && marks[name].find();\n          if (marker) {\n            regInfo += name + '\\t' + marker.line + '\\t' + marker.ch +  '\\n';\n          }\n        }\n      } else {\n        var registerNames = filterArgs.join('');\n        for (var i = 0; i < registerNames.length; i++) {\n          var name = registerNames.charAt(i);\n          var marker = marks[name] && marks[name].find();\n          if (marker) {\n            regInfo += name + '\\t' + marker.line + '\\t' + marker.ch +  '\\n';\n          }\n        }\n      }\n      showConfirm(cm, regInfo, true);\n    },\n    /** @arg {CodeMirrorV} cm @arg {ExParams} params*/\n    sort: function(cm, params) {\n      var reverse, ignoreCase, unique, number, pattern;\n      function parseArgs() {\n        if (params.argString) {\n          var args = new CM.StringStream(params.argString);\n          if (args.eat('!')) { reverse = true; }\n          if (args.eol()) { return; }\n          if (!args.eatSpace()) { return 'Invalid arguments'; }\n          var opts = args.match(/([dinuox]+)?\\s*(\\/.+\\/)?\\s*/);\n          if (!opts || !args.eol()) { return 'Invalid arguments'; }\n          if (opts[1]) {\n            ignoreCase = opts[1].indexOf('i') != -1;\n            unique = opts[1].indexOf('u') != -1;\n            var decimal = opts[1].indexOf('d') != -1 || opts[1].indexOf('n') != -1;\n            var hex = opts[1].indexOf('x') != -1;\n            var octal = opts[1].indexOf('o') != -1;\n            if (Number(decimal) + Number(hex) + Number(octal) > 1) { return 'Invalid arguments'; }\n            number = decimal && 'decimal' || hex && 'hex' || octal && 'octal';\n          }\n          if (opts[2]) {\n            pattern = new RegExp(opts[2].substr(1, opts[2].length - 2), ignoreCase ? 'i' : '');\n          }\n        }\n      }\n      var err = parseArgs();\n      if (err) {\n        showConfirm(cm, err + ': ' + params.argString);\n        return;\n      }\n      var lineStart = params.line || cm.firstLine();\n      var lineEnd = params.lineEnd || params.line || cm.lastLine();\n      if (lineStart == lineEnd) { return; }\n      var curStart = new Pos(lineStart, 0);\n      var curEnd = new Pos(lineEnd, lineLength(cm, lineEnd));\n      var text = cm.getRange(curStart, curEnd).split('\\n');\n      var numberRegex =\n          (number == 'decimal') ? /(-?)([\\d]+)/ :\n          (number == 'hex') ? /(-?)(?:0x)?([0-9a-f]+)/i :\n          (number == 'octal') ? /([0-7]+)/ : null;\n      var radix = (number == 'decimal') ? 10 : (number == 'hex') ? 16 : (number == 'octal') ? 8 : undefined;\n      var numPart = [], textPart = [];\n      if (number || pattern) {\n        for (var i = 0; i < text.length; i++) {\n          var matchPart = pattern ? text[i].match(pattern) : null;\n          if (matchPart && matchPart[0] != '') {\n            numPart.push(matchPart);\n          } else if (numberRegex && numberRegex.exec(text[i])) {\n            numPart.push(text[i]);\n          } else {\n            textPart.push(text[i]);\n          }\n        }\n      } else {\n        textPart = text;\n      }\n      /** @arg {string} a  @arg {string} b */\n      function compareFn(a, b) {\n        if (reverse) { var tmp; tmp = a; a = b; b = tmp; }\n        if (ignoreCase) { a = a.toLowerCase(); b = b.toLowerCase(); }\n        var amatch = numberRegex && numberRegex.exec(a);\n        var bmatch = numberRegex && numberRegex.exec(b);\n        if (!amatch || !bmatch) { return a < b ? -1 : 1; }\n        var anum = parseInt((amatch[1] + amatch[2]).toLowerCase(), radix);\n        var bnum = parseInt((bmatch[1] + bmatch[2]).toLowerCase(), radix);\n        return anum - bnum;\n      }\n      /** @arg {string[]} a  @arg {string[]} b */\n      function comparePatternFn(a, b) {\n        if (reverse) { var tmp; tmp = a; a = b; b = tmp; }\n        if (ignoreCase) { a[0] = a[0].toLowerCase(); b[0] = b[0].toLowerCase(); }\n        return (a[0] < b[0]) ? -1 : 1;\n      }\n      // @ts-ignore\n      numPart.sort(pattern ? comparePatternFn : compareFn);\n      if (pattern) {\n        for (var i = 0; i < numPart.length; i++) {\n          // @ts-ignore\n          numPart[i] = numPart[i].input;\n        }\n      } else if (!number) { textPart.sort(compareFn); }\n      text = (!reverse) ? textPart.concat(numPart) : numPart.concat(textPart);\n      if (unique) { // Remove duplicate lines\n        var textOld = text;\n        var lastLine;\n        text = [];\n        for (var i = 0; i < textOld.length; i++) {\n          if (textOld[i] != lastLine) {\n            text.push(textOld[i]);\n          }\n          lastLine = textOld[i];\n        }\n      }\n      cm.replaceRange(text.join('\\n'), curStart, curEnd);\n    },\n    /** @arg {CodeMirrorV} cm @arg {ExParams} params*/\n    vglobal: function(cm, params) {\n      // global inspects params.commandName\n      this.global(cm, params);\n    },\n    /** @arg {CodeMirrorV} cm @arg {ExParams} params*/\n    normal: function(cm, params) {\n      var noremap = false;\n      var argString = params.argString;\n      if (argString && argString[0] == '!') {\n          argString = argString.slice(1);\n          noremap = true;\n      }\n      argString = argString.trimStart();\n      if (!argString) {\n        showConfirm(cm, 'Argument is required.');\n        return;\n      }\n      var line = params.line;\n      if (typeof line == 'number') {\n        var lineEnd = isNaN(params.lineEnd) ? line : params.lineEnd;\n        for (var i = line; i <= lineEnd; i++) {\n          cm.setCursor(i, 0);\n          doKeyToKey(cm, params.argString.trimStart(), {noremap});\n          if (cm.state.vim.insertMode) {\n            exitInsertMode(cm, true);\n          }\n        }\n      } else {\n        doKeyToKey(cm, params.argString.trimStart(), {noremap});\n        if (cm.state.vim.insertMode) {\n          exitInsertMode(cm, true);\n        }\n      }\n    },\n    /** @arg {CodeMirrorV} cm @arg {ExParams} params*/\n    global: function(cm, params) {\n      // a global command is of the form\n      // :[range]g/pattern/[cmd]\n      // argString holds the string /pattern/[cmd]\n      var argString = params.argString;\n      if (!argString) {\n        showConfirm(cm, 'Regular Expression missing from global');\n        return;\n      }\n      var inverted = params.commandName[0] === 'v';\n      if (argString[0] === '!' && params.commandName[0] === 'g') {\n        inverted = true;\n        argString = argString.slice(1);\n      }\n      // range is specified here\n      var lineStart = (params.line !== undefined) ? params.line : cm.firstLine();\n      var lineEnd = params.lineEnd || params.line || cm.lastLine();\n      // get the tokens from argString\n      var tokens = splitBySlash(argString);\n      var regexPart = argString, cmd = \"\";\n      if (tokens && tokens.length) {\n        regexPart = tokens[0];\n        cmd = tokens.slice(1, tokens.length).join('/');\n      }\n      if (regexPart) {\n        // If regex part is empty, then use the previous query. Otherwise\n        // use the regex part as the new query.\n        try {\n          updateSearchQuery(cm, regexPart, true /** ignoreCase */,\n            true /** smartCase */);\n        } catch (e) {\n          showConfirm(cm, 'Invalid regex: ' + regexPart);\n          return;\n        }\n      }\n      // now that we have the regexPart, search for regex matches in the\n      // specified range of lines\n      var query = getSearchState(cm).getQuery();\n      /**@type {(string|import(\"./types\").LineHandle)[]}*/\n      var matchedLines = [];\n      for (var i = lineStart; i <= lineEnd; i++) {\n        var line = cm.getLine(i);\n        var matched = query.test(line);\n        if (matched !== inverted) {\n          matchedLines.push(cmd ? cm.getLineHandle(i) : line);\n        }\n      }\n      // if there is no [cmd], just display the list of matched lines\n      if (!cmd) {\n        showConfirm(cm, matchedLines.join('\\n'));\n        return;\n      }\n      var index = 0;\n      var nextCommand = function() {\n        if (index < matchedLines.length) {\n          var lineHandle = matchedLines[index++];\n          var lineNum = cm.getLineNumber(lineHandle);\n          if (lineNum == null) {\n            nextCommand();\n            return;\n          }\n          var command = (lineNum + 1) + cmd;\n          exCommandDispatcher.processCommand(cm, command, {\n            callback: nextCommand\n          });\n        } else if (cm.releaseLineHandles) {\n          cm.releaseLineHandles();\n        }\n      };\n      nextCommand();\n    },\n    /** @arg {CodeMirrorV} cm @arg {ExParams} params*/\n    substitute: function(cm, params) {\n      if (!cm.getSearchCursor) {\n        throw new Error('Search feature not available. Requires searchcursor.js or ' +\n            'any other getSearchCursor implementation.');\n      }\n      var argString = params.argString;\n      var tokens = argString ? splitBySeparator(argString, argString[0]) : [];\n      var regexPart = '', replacePart = '', trailing, flagsPart, count;\n      var confirm = false; // Whether to confirm each replace.\n      var global = false; // True to replace all instances on a line, false to replace only 1.\n      if (tokens && tokens.length) {\n        regexPart = tokens[0];\n        if (getOption('pcre') && regexPart !== '') {\n            regexPart = new RegExp(regexPart).source; //normalize not escaped characters\n        }\n        replacePart = tokens[1];\n        if (replacePart !== undefined) {\n          if (getOption('pcre')) {\n            replacePart = unescapeRegexReplace(replacePart.replace(/([^\\\\])&/g,\"$1$$&\"));\n          } else {\n            replacePart = translateRegexReplace(replacePart);\n          }\n          vimGlobalState.lastSubstituteReplacePart = replacePart;\n        }\n        trailing = tokens[2] ? tokens[2].split(' ') : [];\n      } else {\n        // either the argString is empty or its of the form ' hello/world'\n        // actually splitBySlash returns a list of tokens\n        // only if the string starts with a '/'\n        if (argString && argString.length) {\n          showConfirm(cm, 'Substitutions should be of the form ' +\n              ':s/pattern/replace/');\n          return;\n        }\n      }\n      // After the 3rd slash, we can have flags followed by a space followed\n      // by count.\n      if (trailing) {\n        flagsPart = trailing[0];\n        count = parseInt(trailing[1]);\n        if (flagsPart) {\n          if (flagsPart.indexOf('c') != -1) {\n            confirm = true;\n          }\n          if (flagsPart.indexOf('g') != -1) {\n            global = true;\n          }\n          if (getOption('pcre')) {\n            regexPart = regexPart + '/' + flagsPart;\n          } else {\n            regexPart = regexPart.replace(/\\//g, \"\\\\/\") + '/' + flagsPart;\n          }\n        }\n      }\n      if (regexPart) {\n        // If regex part is empty, then use the previous query. Otherwise use\n        // the regex part as the new query.\n        try {\n          updateSearchQuery(cm, regexPart, true /** ignoreCase */,\n            true /** smartCase */);\n        } catch (e) {\n          showConfirm(cm, 'Invalid regex: ' + regexPart);\n          return;\n        }\n      }\n      replacePart = replacePart || vimGlobalState.lastSubstituteReplacePart;\n      if (replacePart === undefined) {\n        showConfirm(cm, 'No previous substitute regular expression');\n        return;\n      }\n      var state = getSearchState(cm);\n      var query = state.getQuery();\n      var lineStart = (params.line !== undefined) ? params.line : cm.getCursor().line;\n      var lineEnd = params.lineEnd || lineStart;\n      if (lineStart == cm.firstLine() && lineEnd == cm.lastLine()) {\n        lineEnd = Infinity;\n      }\n      if (count) {\n        lineStart = lineEnd;\n        lineEnd = lineStart + count - 1;\n      }\n      var startPos = clipCursorToContent(cm, new Pos(lineStart, 0));\n      var cursor = cm.getSearchCursor(query, startPos);\n      doReplace(cm, confirm, global, lineStart, lineEnd, cursor, query, replacePart, params.callback);\n    },\n    /** @arg {CodeMirrorV} cm @arg {ExParams} params*/\n    startinsert: function(cm, params) {\n      doKeyToKey(cm, params.argString == '!' ? 'A' : 'i', {});\n    },\n    redo: CM.commands.redo,\n    undo: CM.commands.undo,\n    /** @arg {CodeMirrorV} cm */\n    write: function(cm) {\n      if (CM.commands.save) {\n        CM.commands.save(cm);\n      } else if (cm.save) {\n        // Saves to text area if no save command is defined and cm.save() is available.\n        cm.save();\n      }\n    },\n    /** @arg {CodeMirrorV} cm */\n    nohlsearch: function(cm) {\n      clearSearchHighlight(cm);\n    },\n    /** @arg {CodeMirrorV} cm */\n    yank: function (cm) {\n      var cur = copyCursor(cm.getCursor());\n      var line = cur.line;\n      var lineText = cm.getLine(line);\n      vimGlobalState.registerController.pushText(\n        '0', 'yank', lineText, true, true);\n    },\n    /** @arg {CodeMirrorV} cm @arg {ExParams} params*/\n    delete: function(cm, params) {\n      var line = params.selectionLine;\n      var lineEnd = isNaN(params.selectionLineEnd) ? line : params.selectionLineEnd;\n      operators.delete(cm, {linewise: true}, [\n        { anchor: new Pos(line, 0),\n          head: new Pos(lineEnd + 1, 0) }\n      ]);\n    },\n    /** @arg {CodeMirrorV} cm @arg {ExParams} params*/\n    join: function(cm, params) {\n      var line = params.selectionLine;\n      var lineEnd = isNaN(params.selectionLineEnd) ? line : params.selectionLineEnd;\n      cm.setCursor(new Pos(line, 0));\n      actions.joinLines(cm, {repeat: lineEnd - line}, cm.state.vim);\n    },\n    /** @arg {CodeMirrorV} cm @arg {ExParams} params*/\n    delmarks: function(cm, params) {\n      if (!params.argString || !trim(params.argString)) {\n        showConfirm(cm, 'Argument required');\n        return;\n      }\n\n      var state = cm.state.vim;\n      var stream = new CM.StringStream(trim(params.argString));\n      while (!stream.eol()) {\n        stream.eatSpace();\n\n        // Record the streams position at the beginning of the loop for use\n        // in error messages.\n        var count = stream.pos;\n\n        if (!stream.match(/[a-zA-Z]/, false)) {\n          showConfirm(cm, 'Invalid argument: ' + params.argString.substring(count));\n          return;\n        }\n\n        var sym = stream.next();\n        // Check if this symbol is part of a range\n        if (stream.match('-', true)) {\n          // This symbol is part of a range.\n\n          // The range must terminate at an alphabetic character.\n          if (!stream.match(/[a-zA-Z]/, false)) {\n            showConfirm(cm, 'Invalid argument: ' + params.argString.substring(count));\n            return;\n          }\n\n          var startMark = sym;\n          var finishMark = stream.next();\n          // The range must terminate at an alphabetic character which\n          // shares the same case as the start of the range.\n          if (startMark && finishMark && isLowerCase(startMark) == isLowerCase(finishMark)) {\n            var start = startMark.charCodeAt(0);\n            var finish = finishMark.charCodeAt(0);\n            if (start >= finish) {\n              showConfirm(cm, 'Invalid argument: ' + params.argString.substring(count));\n              return;\n            }\n\n            // Because marks are always ASCII values, and we have\n            // determined that they are the same case, we can use\n            // their char codes to iterate through the defined range.\n            for (var j = 0; j <= finish - start; j++) {\n              var mark = String.fromCharCode(start + j);\n              delete state.marks[mark];\n            }\n          } else {\n            showConfirm(cm, 'Invalid argument: ' + startMark + '-');\n            return;\n          }\n        } else if (sym) {\n          // This symbol is a valid mark, and is not part of a range.\n          delete state.marks[sym];\n        }\n      }\n    }\n  };\n\n  var exCommandDispatcher = new ExCommandDispatcher();\n\n  vimApi.defineEx(\"version\", \"ve\", (cm) => {\n    showConfirm(cm, \"Codemirror-vim version: 6.3.0\");\n  });\n\n  /**\n   * @arg {CodeMirrorV} cm CodeMirror instance we are in.\n   * @arg {boolean} confirm Whether to confirm each replace.\n   * @arg {boolean} global \n   * @arg {number} lineStart Line to start replacing from.\n   * @arg {number} lineEnd Line to stop replacing at.\n   * TODO: find a way for typescript to understand that when match is found searchCursor.from() is not null\n   * @arg {ReturnType<CodeMirror[\"getSearchCursor\"]>|any} searchCursor Search cursor to use for finding matches.\n   * @arg {RegExp} query Query for performing matches with.\n   * @arg {string} replaceWith Text to replace matches with. May contain $1,\n   *     $2, etc for replacing captured groups using JavaScript replace.\n   * @arg {function} [callback] A callback for when the replace is done.\n   */\n  function doReplace(cm, confirm, global, lineStart, lineEnd, searchCursor, query,\n      replaceWith, callback) {\n    // Set up all the functions.\n    cm.state.vim.exMode = true;\n    var done = false;\n    var matches = 0;\n    \n    /** @type {Pos}*/ var lastPos;\n    /** @type {number}*/ var modifiedLineNumber;\n    /** @type {boolean}*/var joined;\n    function replaceAll() {\n      cm.operation(function() {\n        while (!done) {\n          replace();\n          next();\n        }\n        stop();\n      });\n    }\n    function replace() {\n      var newText = '';\n      var match = searchCursor.match || searchCursor.pos && searchCursor.pos.match;\n      if (match) {\n        newText = replaceWith.replace(/\\$(\\d{1,3}|[$&])/g, function(_, x) {\n          if (x == \"$\") return \"$\";\n          if (x == '&') return match[0];\n          var x1 = x;\n          while (parseInt(x1) >= match.length && x1.length > 0) {\n            x1 = x1.slice(0, x1.length - 1);\n          }\n          if (x1) return match[x1] + x.slice(x1.length, x.length);\n          return _;\n        });\n      } else {\n        var text = cm.getRange(searchCursor.from(), searchCursor.to());\n        newText = text.replace(query, replaceWith);\n      }\n      var unmodifiedLineNumber = searchCursor.to().line;\n      searchCursor.replace(newText);\n      modifiedLineNumber = searchCursor.to().line;\n      lineEnd += modifiedLineNumber - unmodifiedLineNumber;\n      joined = modifiedLineNumber < unmodifiedLineNumber;\n    }\n    function findNextValidMatch() {\n      var lastMatchTo = lastPos && copyCursor(searchCursor.to());\n      var match = searchCursor.findNext();\n      if (match && !match[0] && lastMatchTo && cursorEqual(searchCursor.from(), lastMatchTo)) {\n        match = searchCursor.findNext();\n      }\n      if (match) matches++;\n      return match;\n    }\n    function next() {\n      // The below only loops to skip over multiple occurrences on the same\n      // line when 'global' is not true.\n      while(findNextValidMatch() &&\n            isInRange(searchCursor.from(), lineStart, lineEnd)) {\n        if (!global && searchCursor.from().line == modifiedLineNumber && !joined) {\n          continue;\n        }\n        cm.scrollIntoView(searchCursor.from(), 30);\n        cm.setSelection(searchCursor.from(), searchCursor.to());\n        lastPos = searchCursor.from();\n        done = false;\n        return;\n      }\n      done = true;\n    }\n    /** @arg {(() => void) | undefined} [close] */\n    function stop(close) {\n      if (close) { close(); }\n      cm.focus();\n      if (lastPos) {\n        cm.setCursor(lastPos);\n        var vim = cm.state.vim;\n        vim.exMode = false;\n        vim.lastHPos = vim.lastHSPos = lastPos.ch;\n      }\n      if (callback) { callback(); }\n      else if (done) {\n        showConfirm(cm, \n          (matches ? 'Found ' + matches + ' matches' : 'No matches found') +\n          ' for pattern: ' + query +\n          (getOption('pcre') ? ' (set nopcre to use Vim regexps)' : '')\n        );\n      }\n    }\n    /** @arg {KeyboardEvent} e   @arg {any} _value   @arg {any} close */\n    function onPromptKeyDown(e, _value, close) {\n      // Swallow all keys.\n      CM.e_stop(e);\n      var keyName = vimKeyFromEvent(e);\n      switch (keyName) {\n        case 'y':\n          replace(); next(); break;\n        case 'n':\n          next(); break;\n        case 'a':\n          // replaceAll contains a call to close of its own. We don't want it\n          // to fire too early or multiple times.\n          var savedCallback = callback;\n          callback = undefined;\n          cm.operation(replaceAll);\n          callback = savedCallback;\n          break;\n        case 'l':\n          replace();\n          // fall through and exit.\n        case 'q':\n        case '<Esc>':\n        case '<C-c>':\n        case '<C-[>':\n          stop(close);\n          break;\n      }\n      if (done) { stop(close); }\n      return true;\n    }\n\n    // Actually do replace.\n    next();\n    if (done) {\n      showConfirm(cm, 'No matches for ' + query +  (getOption('pcre') ? ' (set nopcre to use vim regexps)' : ''));\n      return;\n    }\n    if (!confirm) {\n      replaceAll();\n      if (callback) { callback(); }\n      return;\n    }\n    showPrompt(cm, {\n      prefix: dom('span', 'replace with ', dom('strong', replaceWith), ' (y/n/a/q/l)'),\n      onKeyDown: onPromptKeyDown\n    });\n  }\n\n  /** @arg {CodeMirrorV} cm  @arg {boolean} [keepCursor] */\n  function exitInsertMode(cm, keepCursor) {\n    var vim = cm.state.vim;\n    var macroModeState = vimGlobalState.macroModeState;\n    var insertModeChangeRegister = vimGlobalState.registerController.getRegister('.');\n    var isPlaying = macroModeState.isPlaying;\n    var lastChange = macroModeState.lastInsertModeChanges;\n    if (!isPlaying) {\n      cm.off('change', onChange);\n      if (vim.insertEnd) vim.insertEnd.clear();\n      vim.insertEnd = undefined;\n      CM.off(cm.getInputField(), 'keydown', onKeyEventTargetKeyDown);\n    }\n    if (!isPlaying && vim.insertModeRepeat && vim.insertModeRepeat > 1) {\n      // Perform insert mode repeat for commands like 3,a and 3,o.\n      repeatLastEdit(cm, vim, vim.insertModeRepeat - 1,\n          true /** repeatForInsert */);\n      // @ts-ignore\n      vim.lastEditInputState.repeatOverride = vim.insertModeRepeat;\n    }\n    delete vim.insertModeRepeat;\n    vim.insertMode = false;\n    if (!keepCursor) {\n      cm.setCursor(cm.getCursor().line, cm.getCursor().ch-1);\n    }\n    cm.setOption('keyMap', 'vim');\n    cm.setOption('disableInput', true);\n    cm.toggleOverwrite(false); // exit replace mode if we were in it.\n    // update the \". register before exiting insert mode\n    insertModeChangeRegister.setText(lastChange.changes.join(''));\n    CM.signal(cm, \"vim-mode-change\", {mode: \"normal\"});\n    if (macroModeState.isRecording) {\n      logInsertModeChange(macroModeState);\n    }\n  }\n\n  /** @arg {vimKey} command*/\n  function _mapCommand(command) {\n    defaultKeymap.unshift(command);\n    if (command.keys) addUsedKeys(command.keys);\n  }\n\n  /** @arg {string} keys */\n  function addUsedKeys(keys) {\n    keys.split(/(<(?:[CSMA]-)*\\w+>|.)/i).forEach(function(part) {\n      if (part) {\n        if (!usedKeys[part]) usedKeys[part] = 0;\n        usedKeys[part]++;\n      }\n    });\n  }\n\n  /** @arg {string} keys */\n  function removeUsedKeys(keys) {\n    keys.split(/(<(?:[CSMA]-)*\\w+>|.)/i).forEach(function(part) {\n      if (usedKeys[part])\n        usedKeys[part]--;\n    });\n  }\n\n  /** \n   * @arg {string} keys\n   * @arg {string} type   \n   * @arg {string} name\n   * @arg {any} args\n   * @arg {{ [x: string]: any; }} extra \n   **/\n  function mapCommand(keys, type, name, args, extra) {\n    /**@type{any} */\n    var command = {keys: keys, type: type};\n    command[type] = name;\n    command[type + \"Args\"] = args;\n    for (var key in extra)\n      command[key] = extra[key];\n    _mapCommand(command);\n  }\n\n  // The timeout in milliseconds for the two-character ESC keymap should be\n  // adjusted according to your typing speed to prevent false positives.\n  defineOption('insertModeEscKeysTimeout', 200, 'number');\n\n\n  /**\n   * @arg {CodeMirrorV} cm \n   * @arg {vimState} vim \n   * @arg {MacroModeState} macroModeState \n   * @arg {string} registerName\n   */\n  function executeMacroRegister(cm, vim, macroModeState, registerName) {\n    var register = vimGlobalState.registerController.getRegister(registerName);\n    if (registerName == ':') {\n      // Read-only register containing last Ex command.\n      if (register.keyBuffer[0]) {\n        exCommandDispatcher.processCommand(cm, register.keyBuffer[0]);\n      }\n      macroModeState.isPlaying = false;\n      return;\n    }\n    var keyBuffer = register.keyBuffer;\n    var imc = 0;\n    macroModeState.isPlaying = true;\n    macroModeState.replaySearchQueries = register.searchQueries.slice(0);\n    for (var i = 0; i < keyBuffer.length; i++) {\n      var text = keyBuffer[i];\n      var match, key;\n      var keyRe = /<(?:[CSMA]-)*\\w+>|./gi;\n      while ((match = keyRe.exec(text))) {\n        // Pull off one command key, which is either a single character\n        // or a special sequence wrapped in '<' and '>', e.g. '<Space>'.\n        key = match[0];\n        vimApi.handleKey(cm, key, 'macro');\n        if (vim.insertMode) {\n          var changes = register.insertModeChanges[imc++].changes;\n          vimGlobalState.macroModeState.lastInsertModeChanges.changes = changes;\n          repeatInsertModeChanges(cm, changes, 1);\n          exitInsertMode(cm);\n        }\n      }\n    }\n    macroModeState.isPlaying = false;\n  }\n\n  /** @arg {MacroModeState} macroModeState @arg {any} key */\n  function logKey(macroModeState, key) {\n    if (macroModeState.isPlaying) { return; }\n    var registerName = macroModeState.latestRegister;\n    var register = vimGlobalState.registerController.getRegister(registerName);\n    if (register) {\n      register.pushText(key);\n    }\n  }\n\n  /** @arg {MacroModeState} macroModeState */\n  function logInsertModeChange(macroModeState) {\n    if (macroModeState.isPlaying) { return; }\n    var registerName = macroModeState.latestRegister;\n    var register = vimGlobalState.registerController.getRegister(registerName);\n    if (register && register.pushInsertModeChanges) {\n      register.pushInsertModeChanges(macroModeState.lastInsertModeChanges);\n    }\n  }\n\n  /** @arg {MacroModeState} macroModeState @arg {string} query */\n  function logSearchQuery(macroModeState, query) {\n    if (macroModeState.isPlaying) { return; }\n    var registerName = macroModeState.latestRegister;\n    var register = vimGlobalState.registerController.getRegister(registerName);\n    if (register && register.pushSearchQuery) {\n      register.pushSearchQuery(query);\n    }\n  }\n\n  /**\n   * Listens for changes made in insert mode.\n   * Should only be active in insert mode.\n   * @arg {CodeMirror} cm\n   * @arg {{ origin: string | undefined; text: any[]; next: any; }} changeObj\n   */\n  function onChange(cm, changeObj) {\n    var macroModeState = vimGlobalState.macroModeState;\n    var lastChange = macroModeState.lastInsertModeChanges;\n    if (!macroModeState.isPlaying) {\n      var vim = cm.state.vim;\n      while(changeObj) {\n        lastChange.expectCursorActivityForChange = true;\n        // @ts-ignore\n        if (lastChange.ignoreCount > 1) {\n          // @ts-ignore\n          lastChange.ignoreCount--;\n        } else if (changeObj.origin == '+input' || changeObj.origin == 'paste'\n            || changeObj.origin === undefined /* only in testing */) {\n          var selectionCount = cm.listSelections().length;\n          if (selectionCount > 1)\n            lastChange.ignoreCount = selectionCount;\n          var text = changeObj.text.join('\\n');\n          if (lastChange.maybeReset) {\n            lastChange.changes = [];\n            lastChange.maybeReset = false;\n          }\n          if (text) {\n            if (cm.state.overwrite && !/\\n/.test(text)) {\n              lastChange.changes.push([text]);\n            } else {\n              if (text.length > 1) {\n                var insertEnd = vim && vim.insertEnd && vim.insertEnd.find();\n                var cursor = cm.getCursor();\n                if (insertEnd && insertEnd.line == cursor.line) {\n                  var offset = insertEnd.ch - cursor.ch;\n                  if (offset > 0 && offset < text.length) {\n                    lastChange.changes.push([text, offset]);\n                    text = '';\n                  }\n                }\n              }\n              if (text) lastChange.changes.push(text);\n            }\n          }\n        }\n        // Change objects may be chained with next.\n        changeObj = changeObj.next;\n      }\n    }\n  }\n\n  /**\n   * Listens for any kind of cursor activity on CodeMirror.\n   * @arg {CodeMirrorV} cm\n   */\n  function onCursorActivity(cm) {\n    var vim = cm.state.vim;\n    if (vim.insertMode) {\n      // Tracking cursor activity in insert mode (for macro support).\n      var macroModeState = vimGlobalState.macroModeState;\n      if (macroModeState.isPlaying) { return; }\n      var lastChange = macroModeState.lastInsertModeChanges;\n      if (lastChange.expectCursorActivityForChange) {\n        lastChange.expectCursorActivityForChange = false;\n      } else {\n        // Cursor moved outside the context of an edit. Reset the change.\n        lastChange.maybeReset = true;\n        if (vim.insertEnd) vim.insertEnd.clear();\n        vim.insertEnd = cm.setBookmark(cm.getCursor(), {insertLeft: true});\n      }\n    } else if (!cm.curOp?.isVimOp) {\n      handleExternalSelection(cm, vim);\n    }\n  }\n  /** @arg {CodeMirrorV} cm  @arg {vimState} vim */\n  function handleExternalSelection(cm, vim) {\n    var anchor = cm.getCursor('anchor');\n    var head = cm.getCursor('head');\n    // Enter or exit visual mode to match mouse selection.\n    if (vim.visualMode && !cm.somethingSelected()) {\n      exitVisualMode(cm, false);\n    } else if (!vim.visualMode && !vim.insertMode && cm.somethingSelected()) {\n      vim.visualMode = true;\n      vim.visualLine = false;\n      CM.signal(cm, \"vim-mode-change\", {mode: \"visual\"});\n    }\n    if (vim.visualMode) {\n      // Bind CodeMirror selection model to vim selection model.\n      // Mouse selections are considered visual characterwise.\n      var headOffset = !cursorIsBefore(head, anchor) ? -1 : 0;\n      var anchorOffset = cursorIsBefore(head, anchor) ? -1 : 0;\n      head = offsetCursor(head, 0, headOffset);\n      anchor = offsetCursor(anchor, 0, anchorOffset);\n      vim.sel = {\n        anchor: anchor,\n        head: head\n      };\n      updateMark(cm, vim, '<', cursorMin(head, anchor));\n      updateMark(cm, vim, '>', cursorMax(head, anchor));\n    } else if (!vim.insertMode) {\n      // Reset lastHPos if selection was modified by something outside of vim mode e.g. by mouse.\n      vim.lastHPos = cm.getCursor().ch;\n    }\n  }\n\n  /**\n   * Handles raw key down events from the text area.\n   * - Should only be active in insert mode.\n   * - For recording deletes in insert mode.\n   * @arg {KeyboardEvent} e\n   */\n  function onKeyEventTargetKeyDown(e) {\n    var macroModeState = vimGlobalState.macroModeState;\n    var lastChange = macroModeState.lastInsertModeChanges;\n    var keyName = CM.keyName ? CM.keyName(e) : e.key;\n    if (!keyName) { return; }\n    \n    if (keyName.indexOf('Delete') != -1 || keyName.indexOf('Backspace') != -1) {\n      if (lastChange.maybeReset) {\n        lastChange.changes = [];\n        lastChange.maybeReset = false;\n      }\n      lastChange.changes.push(new InsertModeKey(keyName, e));\n    }\n  }\n\n  /**\n   * Repeats the last edit, which includes exactly 1 command and at most 1\n   * insert. Operator and motion commands are read from lastEditInputState,\n   * while action commands are read from lastEditActionCommand.\n   *\n   * If repeatForInsert is true, then the function was called by\n   * exitInsertMode to repeat the insert mode changes the user just made. The\n   * corresponding enterInsertMode call was made with a count.\n   * @arg {CodeMirrorV} cm \n   * @arg {vimState} vim \n   * @arg {number} repeat  \n   * @arg {boolean} repeatForInsert\n   */\n  function repeatLastEdit(cm, vim, repeat, repeatForInsert) {\n    var macroModeState = vimGlobalState.macroModeState;\n    macroModeState.isPlaying = true;\n    var lastAction = vim.lastEditActionCommand;\n    var cachedInputState = vim.inputState;\n    function repeatCommand() {\n      if (lastAction) {\n        commandDispatcher.processAction(cm, vim, lastAction);\n      } else {\n        commandDispatcher.evalInput(cm, vim);\n      }\n    }\n    /** @arg {number} repeat */\n    function repeatInsert(repeat) {\n      if (macroModeState.lastInsertModeChanges.changes.length > 0) {\n        // For some reason, repeat cw in desktop VIM does not repeat\n        // insert mode changes. Will conform to that behavior.\n        repeat = !vim.lastEditActionCommand ? 1 : repeat;\n        var changeObject = macroModeState.lastInsertModeChanges;\n        repeatInsertModeChanges(cm, changeObject.changes, repeat);\n      }\n    }\n    // @ts-ignore\n    vim.inputState = vim.lastEditInputState;\n    if (lastAction && lastAction.interlaceInsertRepeat) {\n      // o and O repeat have to be interlaced with insert repeats so that the\n      // insertions appear on separate lines instead of the last line.\n      for (var i = 0; i < repeat; i++) {\n        repeatCommand();\n        repeatInsert(1);\n      }\n    } else {\n      if (!repeatForInsert) {\n        // Hack to get the cursor to end up at the right place. If I is\n        // repeated in insert mode repeat, cursor will be 1 insert\n        // change set left of where it should be.\n        repeatCommand();\n      }\n      repeatInsert(repeat);\n    }\n    vim.inputState = cachedInputState;\n    if (vim.insertMode && !repeatForInsert) {\n      // Don't exit insert mode twice. If repeatForInsert is set, then we\n      // were called by an exitInsertMode call lower on the stack.\n      exitInsertMode(cm);\n    }\n    macroModeState.isPlaying = false;\n  }\n  /**@arg {CodeMirrorV} cm, @arg {string} key */\n  function sendCmKey(cm, key) {\n    CM.lookupKey(key, 'vim-insert', function keyHandler(binding) {\n      if (typeof binding == 'string') {\n        CM.commands[binding](cm);\n      } else {\n        binding(cm);\n      }\n      return true;\n    });\n  }\n  /**\n   * @param {CodeMirrorV} cm\n   * @param {InsertModeChanges[\"changes\"]} changes\n   * @param {number} repeat\n   */\n  function repeatInsertModeChanges(cm, changes, repeat) {\n    var head = cm.getCursor('head');\n    var visualBlock = vimGlobalState.macroModeState.lastInsertModeChanges.visualBlock;\n    if (visualBlock) {\n      // Set up block selection again for repeating the changes.\n      selectForInsert(cm, head, visualBlock + 1);\n      repeat = cm.listSelections().length;\n      cm.setCursor(head);\n    }\n    for (var i = 0; i < repeat; i++) {\n      if (visualBlock) {\n        cm.setCursor(offsetCursor(head, i, 0));\n      }\n      for (var j = 0; j < changes.length; j++) {\n        var change = changes[j];\n        if (change instanceof InsertModeKey) {\n          sendCmKey(cm, change.keyName);\n        } else if (typeof change == \"string\") {\n          cm.replaceSelection(change);\n        } else {\n          var start = cm.getCursor();\n          var end = offsetCursor(start, 0, change[0].length - (change[1] || 0));\n          cm.replaceRange(change[0], start, change[1] ? start: end);\n          cm.setCursor(end);\n        }\n      }\n    }\n    if (visualBlock) {\n      cm.setCursor(offsetCursor(head, 0, 1));\n    }\n  }\n\n  // multiselect support\n  /** @arg {vimState} state */\n  function cloneVimState(state) {\n    // @ts-ignore\n    var n = new state.constructor();\n    Object.keys(state).forEach(function(key) {\n      if (key == \"insertEnd\") return;\n      var o = state[key];\n      if (Array.isArray(o))\n        o = o.slice();\n      else if (o && typeof o == \"object\" && o.constructor != Object)\n        o = cloneVimState(o);\n      n[key] = o;\n    });\n    if (state.sel) {\n      n.sel = {\n        head: state.sel.head && copyCursor(state.sel.head),\n        anchor: state.sel.anchor && copyCursor(state.sel.anchor)\n      };\n    }\n    return n;\n  }\n  /** @arg {CodeMirror} cm_  @arg {string} key @arg {string} origin */\n  function multiSelectHandleKey(cm_, key, origin) {\n    var vim = maybeInitVimState(cm_);\n    var cm = /**@type {CodeMirrorV}*/(cm_);\n    /** @type {boolean | undefined} */\n    var isHandled = false;\n    var vim = vimApi.maybeInitVimState_(cm);\n    var visualBlock = vim.visualBlock || vim.wasInVisualBlock;\n\n    if (cm.state.closeVimNotification) {\n      var close = cm.state.closeVimNotification;\n      cm.state.closeVimNotification = null;\n      close();\n      if (key == '<CR>') {\n        clearInputState(cm);\n        return true;\n      }\n    }\n\n    var wasMultiselect = cm.isInMultiSelectMode();\n    if (vim.wasInVisualBlock && !wasMultiselect) {\n      vim.wasInVisualBlock = false;\n    } else if (wasMultiselect && vim.visualBlock) {\n        vim.wasInVisualBlock = true;\n    }\n\n    if (key == '<Esc>' && !vim.insertMode && !vim.visualMode && wasMultiselect && vim.status == \"<Esc>\") {\n      // allow editor to exit multiselect\n      clearInputState(cm);\n    // @ts-ignore\n    } else if (visualBlock || !wasMultiselect || cm.inVirtualSelectionMode) {\n      isHandled = vimApi.handleKey(cm, key, origin);\n    } else {\n      var old = cloneVimState(vim);\n      var changeQueueList = vim.inputState.changeQueueList || [];\n\n      cm.operation(function() {\n        if (cm.curOp)\n          cm.curOp.isVimOp = true;\n        var index = 0;\n        cm.forEachSelection(function() {\n          cm.state.vim.inputState.changeQueue = changeQueueList[index];\n          var head = cm.getCursor(\"head\");\n          var anchor = cm.getCursor(\"anchor\");\n          var headOffset = !cursorIsBefore(head, anchor) ? -1 : 0;\n          var anchorOffset = cursorIsBefore(head, anchor) ? -1 : 0;\n          head = offsetCursor(head, 0, headOffset);\n          anchor = offsetCursor(anchor, 0, anchorOffset);\n          cm.state.vim.sel.head = head;\n          cm.state.vim.sel.anchor = anchor;\n\n          isHandled = vimApi.handleKey(cm, key, origin);\n          if (cm.virtualSelection) {\n            changeQueueList[index] = cm.state.vim.inputState.changeQueue;\n            cm.state.vim = cloneVimState(old);\n          }\n          index++;\n        });\n        if (cm.curOp?.cursorActivity && !isHandled)\n          cm.curOp.cursorActivity = false;\n        cm.state.vim = vim;\n        vim.inputState.changeQueueList = changeQueueList;\n        vim.inputState.changeQueue = null;\n      }, true);\n    }\n    // some commands may bring visualMode and selection out of sync\n    if (isHandled && !vim.visualMode && !vim.insertMode && vim.visualMode != cm.somethingSelected()) {\n      handleExternalSelection(cm, vim);\n    }\n    return isHandled;\n  }\n  resetVimGlobalState();\n\n  return vimApi;\n}\n\nfunction indexFromPos(doc, pos) {\n    var ch = pos.ch;\n    var lineNumber = pos.line + 1;\n    if (lineNumber < 1) {\n        lineNumber = 1;\n        ch = 0;\n    }\n    if (lineNumber > doc.lines) {\n        lineNumber = doc.lines;\n        ch = Number.MAX_VALUE;\n    }\n    var line = doc.line(lineNumber);\n    return Math.min(line.from + Math.max(0, ch), line.to);\n}\nfunction posFromIndex(doc, offset) {\n    let line = doc.lineAt(offset);\n    return { line: line.number - 1, ch: offset - line.from };\n}\nclass Pos {\n    constructor(line, ch) {\n        this.line = line;\n        this.ch = ch;\n    }\n}\nfunction on(emitter, type, f) {\n    if (emitter.addEventListener) {\n        emitter.addEventListener(type, f, false);\n    }\n    else {\n        var map = emitter._handlers || (emitter._handlers = {});\n        map[type] = (map[type] || []).concat(f);\n    }\n}\nfunction off(emitter, type, f) {\n    if (emitter.removeEventListener) {\n        emitter.removeEventListener(type, f, false);\n    }\n    else {\n        var map = emitter._handlers, arr = map && map[type];\n        if (arr) {\n            var index = arr.indexOf(f);\n            if (index > -1) {\n                map[type] = arr.slice(0, index).concat(arr.slice(index + 1));\n            }\n        }\n    }\n}\nfunction signal(emitter, type, ...args) {\n    var _a;\n    var handlers = (_a = emitter._handlers) === null || _a === void 0 ? void 0 : _a[type];\n    if (!handlers)\n        return;\n    for (var i = 0; i < handlers.length; ++i) {\n        handlers[i](...args);\n    }\n}\nfunction signalTo(handlers, ...args) {\n    if (!handlers)\n        return;\n    for (var i = 0; i < handlers.length; ++i) {\n        handlers[i](...args);\n    }\n}\nlet wordChar;\ntry {\n    wordChar = /*@__PURE__*/new RegExp(\"[\\\\w\\\\p{Alphabetic}\\\\p{Number}_]\", \"u\");\n}\ncatch (_) {\n    wordChar = /[\\w]/;\n}\n// workaround for missing api for merging transactions\nfunction dispatchChange(cm, transaction) {\n    var view = cm.cm6;\n    if (view.state.readOnly)\n        return;\n    var type = \"input.type.compose\";\n    if (cm.curOp) {\n        if (!cm.curOp.lastChange)\n            type = \"input.type.compose.start\";\n    }\n    if (transaction.annotations) {\n        try {\n            transaction.annotations.some(function (note) {\n                if (note.value == \"input\")\n                    note.value = type;\n            });\n        }\n        catch (e) {\n            console.error(e);\n        }\n    }\n    else {\n        transaction.userEvent = type;\n    }\n    return view.dispatch(transaction);\n}\nfunction runHistoryCommand(cm, revert) {\n    var _a;\n    if (cm.curOp) {\n        cm.curOp.$changeStart = undefined;\n    }\n    (revert ? _codemirror_commands__WEBPACK_IMPORTED_MODULE_0__.undo : _codemirror_commands__WEBPACK_IMPORTED_MODULE_0__.redo)(cm.cm6);\n    let changeStartIndex = (_a = cm.curOp) === null || _a === void 0 ? void 0 : _a.$changeStart;\n    // vim mode expects the changed text to be either selected or cursor placed at the start\n    if (changeStartIndex != null) {\n        cm.cm6.dispatch({ selection: { anchor: changeStartIndex } });\n    }\n}\nvar keys = {\n    Left: (cm) => (0,_codemirror_view__WEBPACK_IMPORTED_MODULE_1__.runScopeHandlers)(cm.cm6, { key: \"Left\" }, \"editor\"),\n    Right: (cm) => (0,_codemirror_view__WEBPACK_IMPORTED_MODULE_1__.runScopeHandlers)(cm.cm6, { key: \"Right\" }, \"editor\"),\n    Up: (cm) => (0,_codemirror_view__WEBPACK_IMPORTED_MODULE_1__.runScopeHandlers)(cm.cm6, { key: \"Up\" }, \"editor\"),\n    Down: (cm) => (0,_codemirror_view__WEBPACK_IMPORTED_MODULE_1__.runScopeHandlers)(cm.cm6, { key: \"Down\" }, \"editor\"),\n    Backspace: (cm) => (0,_codemirror_view__WEBPACK_IMPORTED_MODULE_1__.runScopeHandlers)(cm.cm6, { key: \"Backspace\" }, \"editor\"),\n    Delete: (cm) => (0,_codemirror_view__WEBPACK_IMPORTED_MODULE_1__.runScopeHandlers)(cm.cm6, { key: \"Delete\" }, \"editor\"),\n};\nclass CodeMirror {\n    // --------------------------\n    openDialog(template, callback, options) {\n        return openDialog(this, template, callback, options);\n    }\n    ;\n    openNotification(template, options) {\n        return openNotification(this, template, options);\n    }\n    ;\n    constructor(cm6) {\n        this.state = {};\n        this.marks = Object.create(null);\n        this.$mid = 0; // marker id counter\n        this.options = {};\n        this._handlers = {};\n        this.$lastChangeEndOffset = 0;\n        this.virtualSelection = null;\n        this.cm6 = cm6;\n        this.onChange = this.onChange.bind(this);\n        this.onSelectionChange = this.onSelectionChange.bind(this);\n    }\n    ;\n    on(type, f) { on(this, type, f); }\n    off(type, f) { off(this, type, f); }\n    signal(type, e, handlers) { signal(this, type, e, handlers); }\n    indexFromPos(pos) {\n        return indexFromPos(this.cm6.state.doc, pos);\n    }\n    ;\n    posFromIndex(offset) {\n        return posFromIndex(this.cm6.state.doc, offset);\n    }\n    ;\n    foldCode(pos) {\n        let view = this.cm6;\n        let ranges = view.state.selection.ranges;\n        let doc = this.cm6.state.doc;\n        let index = indexFromPos(doc, pos);\n        let tmpRanges = _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.create([_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.range(index, index)], 0).ranges;\n        view.state.selection.ranges = tmpRanges;\n        (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.foldCode)(view);\n        view.state.selection.ranges = ranges;\n    }\n    firstLine() { return 0; }\n    ;\n    lastLine() { return this.cm6.state.doc.lines - 1; }\n    ;\n    lineCount() { return this.cm6.state.doc.lines; }\n    ;\n    setCursor(line, ch) {\n        if (typeof line === 'object') {\n            ch = line.ch;\n            line = line.line;\n        }\n        var offset = indexFromPos(this.cm6.state.doc, { line, ch: ch || 0 });\n        this.cm6.dispatch({ selection: { anchor: offset } }, { scrollIntoView: !this.curOp });\n        if (this.curOp && !this.curOp.isVimOp)\n            this.onBeforeEndOperation();\n    }\n    ;\n    getCursor(p) {\n        var sel = this.cm6.state.selection.main;\n        var offset = p == \"head\" || !p\n            ? sel.head\n            : p == \"anchor\"\n                ? sel.anchor\n                : p == \"start\"\n                    ? sel.from\n                    : p == \"end\"\n                        ? sel.to\n                        : null;\n        if (offset == null)\n            throw new Error(\"Invalid cursor type\");\n        return this.posFromIndex(offset);\n    }\n    ;\n    listSelections() {\n        var doc = this.cm6.state.doc;\n        return this.cm6.state.selection.ranges.map(r => {\n            return {\n                anchor: posFromIndex(doc, r.anchor),\n                head: posFromIndex(doc, r.head),\n            };\n        });\n    }\n    ;\n    setSelections(p, primIndex) {\n        var doc = this.cm6.state.doc;\n        var ranges = p.map(x => {\n            var head = indexFromPos(doc, x.head);\n            var anchor = indexFromPos(doc, x.anchor);\n            // workaround for codemirror bug, see https://github.com/replit/codemirror-vim/issues/169\n            if (head == anchor)\n                return _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.cursor(head, 1);\n            return _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.range(anchor, head);\n        });\n        this.cm6.dispatch({\n            selection: _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.create(ranges, primIndex)\n        });\n    }\n    ;\n    setSelection(anchor, head, options) {\n        this.setSelections([{ anchor, head }], 0);\n        if (options && options.origin == '*mouse') {\n            this.onBeforeEndOperation();\n        }\n    }\n    ;\n    getLine(row) {\n        var doc = this.cm6.state.doc;\n        if (row < 0 || row >= doc.lines)\n            return \"\";\n        return this.cm6.state.doc.line(row + 1).text;\n    }\n    ;\n    getLineHandle(row) {\n        if (!this.$lineHandleChanges)\n            this.$lineHandleChanges = [];\n        return { row: row, index: this.indexFromPos(new Pos(row, 0)) };\n    }\n    getLineNumber(handle) {\n        var updates = this.$lineHandleChanges;\n        if (!updates)\n            return null;\n        var offset = handle.index;\n        for (var i = 0; i < updates.length; i++) {\n            offset = updates[i].changes.mapPos(offset, 1, _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.MapMode.TrackAfter);\n            if (offset == null)\n                return null;\n        }\n        var pos = this.posFromIndex(offset);\n        return pos.ch == 0 ? pos.line : null;\n    }\n    releaseLineHandles() {\n        this.$lineHandleChanges = undefined;\n    }\n    getRange(s, e) {\n        var doc = this.cm6.state.doc;\n        return this.cm6.state.sliceDoc(indexFromPos(doc, s), indexFromPos(doc, e));\n    }\n    ;\n    replaceRange(text, s, e, source) {\n        if (!e)\n            e = s;\n        var doc = this.cm6.state.doc;\n        var from = indexFromPos(doc, s);\n        var to = indexFromPos(doc, e);\n        dispatchChange(this, { changes: { from, to, insert: text } });\n    }\n    ;\n    replaceSelection(text) {\n        dispatchChange(this, this.cm6.state.replaceSelection(text));\n    }\n    ;\n    replaceSelections(replacements) {\n        var ranges = this.cm6.state.selection.ranges;\n        var changes = ranges.map((r, i) => {\n            return { from: r.from, to: r.to, insert: replacements[i] || \"\" };\n        });\n        dispatchChange(this, { changes });\n    }\n    ;\n    getSelection() {\n        return this.getSelections().join(\"\\n\");\n    }\n    ;\n    getSelections() {\n        var cm = this.cm6;\n        return cm.state.selection.ranges.map(r => cm.state.sliceDoc(r.from, r.to));\n    }\n    ;\n    somethingSelected() {\n        return this.cm6.state.selection.ranges.some(r => !r.empty);\n    }\n    ;\n    getInputField() {\n        return this.cm6.contentDOM;\n    }\n    ;\n    clipPos(p) {\n        var doc = this.cm6.state.doc;\n        var ch = p.ch;\n        var lineNumber = p.line + 1;\n        if (lineNumber < 1) {\n            lineNumber = 1;\n            ch = 0;\n        }\n        if (lineNumber > doc.lines) {\n            lineNumber = doc.lines;\n            ch = Number.MAX_VALUE;\n        }\n        var line = doc.line(lineNumber);\n        ch = Math.min(Math.max(0, ch), line.to - line.from);\n        return new Pos(lineNumber - 1, ch);\n    }\n    ;\n    getValue() {\n        return this.cm6.state.doc.toString();\n    }\n    ;\n    setValue(text) {\n        var cm = this.cm6;\n        return cm.dispatch({\n            changes: { from: 0, to: cm.state.doc.length, insert: text },\n            selection: _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.range(0, 0)\n        });\n    }\n    ;\n    focus() {\n        return this.cm6.focus();\n    }\n    ;\n    blur() {\n        return this.cm6.contentDOM.blur();\n    }\n    ;\n    defaultTextHeight() {\n        return this.cm6.defaultLineHeight;\n    }\n    ;\n    findMatchingBracket(pos, _options) {\n        var state = this.cm6.state;\n        var offset = indexFromPos(state.doc, pos);\n        var m = (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.matchBrackets)(state, offset + 1, -1);\n        if (m && m.end) {\n            return { to: posFromIndex(state.doc, m.end.from) };\n        }\n        m = (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.matchBrackets)(state, offset, 1);\n        if (m && m.end) {\n            return { to: posFromIndex(state.doc, m.end.from) };\n        }\n        return { to: undefined };\n    }\n    ;\n    scanForBracket(pos, dir, style, config) {\n        return scanForBracket(this, pos, dir, style, config);\n    }\n    ;\n    indentLine(line, more) {\n        // todo how to indent only one line instead of selection\n        if (more)\n            this.indentMore();\n        else\n            this.indentLess();\n    }\n    ;\n    indentMore() {\n        (0,_codemirror_commands__WEBPACK_IMPORTED_MODULE_0__.indentMore)(this.cm6);\n    }\n    ;\n    indentLess() {\n        (0,_codemirror_commands__WEBPACK_IMPORTED_MODULE_0__.indentLess)(this.cm6);\n    }\n    ;\n    execCommand(name) {\n        if (name == \"indentAuto\")\n            CodeMirror.commands.indentAuto(this);\n        else if (name == \"goLineLeft\")\n            (0,_codemirror_commands__WEBPACK_IMPORTED_MODULE_0__.cursorLineBoundaryBackward)(this.cm6);\n        else if (name == \"goLineRight\") {\n            (0,_codemirror_commands__WEBPACK_IMPORTED_MODULE_0__.cursorLineBoundaryForward)(this.cm6);\n            let state = this.cm6.state;\n            let cur = state.selection.main.head;\n            if (cur < state.doc.length && state.sliceDoc(cur, cur + 1) !== \"\\n\") {\n                (0,_codemirror_commands__WEBPACK_IMPORTED_MODULE_0__.cursorCharBackward)(this.cm6);\n            }\n        }\n        else\n            console.log(name + \" is not implemented\");\n    }\n    ;\n    setBookmark(cursor, options) {\n        var assoc = (options === null || options === void 0 ? void 0 : options.insertLeft) ? 1 : -1;\n        var offset = this.indexFromPos(cursor);\n        var bm = new Marker(this, offset, assoc);\n        return bm;\n    }\n    ;\n    addOverlay({ query }) {\n        let cm6Query = new _codemirror_search__WEBPACK_IMPORTED_MODULE_4__.SearchQuery({\n            regexp: true,\n            search: query.source,\n            caseSensitive: !/i/.test(query.flags),\n        });\n        if (cm6Query.valid) {\n            cm6Query.forVim = true;\n            this.cm6Query = cm6Query;\n            let effect = _codemirror_search__WEBPACK_IMPORTED_MODULE_4__.setSearchQuery.of(cm6Query);\n            this.cm6.dispatch({ effects: effect });\n            return cm6Query;\n        }\n    }\n    ;\n    removeOverlay(overlay) {\n        if (!this.cm6Query)\n            return;\n        this.cm6Query.forVim = false;\n        let effect = _codemirror_search__WEBPACK_IMPORTED_MODULE_4__.setSearchQuery.of(this.cm6Query);\n        this.cm6.dispatch({ effects: effect });\n    }\n    ;\n    getSearchCursor(query, pos) {\n        var cm = this;\n        var last = null;\n        var lastCM5Result = null;\n        var afterEmptyMatch = false;\n        if (pos.ch == undefined)\n            pos.ch = Number.MAX_VALUE;\n        var firstOffset = indexFromPos(cm.cm6.state.doc, pos);\n        var source = query.source.replace(/(\\\\.|{(?:\\d+(?:,\\d*)?|,\\d+)})|[{}]/g, function (a, b) {\n            if (!b)\n                return \"\\\\\" + a;\n            return b;\n        });\n        function rCursor(doc, from = 0, to = doc.length) {\n            return new _codemirror_search__WEBPACK_IMPORTED_MODULE_4__.RegExpCursor(doc, source, { ignoreCase: query.ignoreCase }, from, to);\n        }\n        function nextMatch(from) {\n            var doc = cm.cm6.state.doc;\n            if (from > doc.length)\n                return null;\n            let res = rCursor(doc, from).next();\n            return res.done ? null : res.value;\n        }\n        var ChunkSize = 10000;\n        function prevMatchInRange(from, to) {\n            var doc = cm.cm6.state.doc;\n            for (let size = 1;; size++) {\n                let start = Math.max(from, to - size * ChunkSize);\n                let cursor = rCursor(doc, start, to), range = null;\n                while (!cursor.next().done)\n                    range = cursor.value;\n                if (range && (start == from || range.from > start + 10))\n                    return range;\n                if (start == from)\n                    return null;\n            }\n        }\n        return {\n            findNext: function () { return this.find(false); },\n            findPrevious: function () { return this.find(true); },\n            find: function (back) {\n                var doc = cm.cm6.state.doc;\n                if (back) {\n                    let endAt = last ? (afterEmptyMatch ? last.to - 1 : last.from) : firstOffset;\n                    last = prevMatchInRange(0, endAt);\n                }\n                else {\n                    let startFrom = last ? (afterEmptyMatch ? last.to + 1 : last.to) : firstOffset;\n                    last = nextMatch(startFrom);\n                }\n                lastCM5Result = last && {\n                    from: posFromIndex(doc, last.from),\n                    to: posFromIndex(doc, last.to),\n                    match: last.match,\n                };\n                afterEmptyMatch = last ? last.from == last.to : false;\n                return last && last.match;\n            },\n            from: function () { return lastCM5Result === null || lastCM5Result === void 0 ? void 0 : lastCM5Result.from; },\n            to: function () { return lastCM5Result === null || lastCM5Result === void 0 ? void 0 : lastCM5Result.to; },\n            replace: function (text) {\n                if (last) {\n                    dispatchChange(cm, {\n                        changes: { from: last.from, to: last.to, insert: text }\n                    });\n                    last.to = last.from + text.length;\n                    if (lastCM5Result) {\n                        lastCM5Result.to = posFromIndex(cm.cm6.state.doc, last.to);\n                    }\n                }\n            },\n            get match() {\n                return lastCM5Result && lastCM5Result.match;\n            }\n        };\n    }\n    ;\n    findPosV(start, amount, unit, goalColumn) {\n        let { cm6 } = this;\n        const doc = cm6.state.doc;\n        let pixels = unit == 'page' ? cm6.dom.clientHeight : 0;\n        const startOffset = indexFromPos(doc, start);\n        let range = _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.cursor(startOffset, 1, undefined, goalColumn);\n        let count = Math.round(Math.abs(amount));\n        for (let i = 0; i < count; i++) {\n            if (unit == 'page') {\n                range = cm6.moveVertically(range, amount > 0, pixels);\n            }\n            else if (unit == 'line') {\n                range = cm6.moveVertically(range, amount > 0);\n            }\n        }\n        let pos = posFromIndex(doc, range.head);\n        // set hitside to true if there was no place to move and cursor was clipped to the edge\n        // of document. Needed for gj/gk\n        if ((amount < 0 &&\n            range.head == 0 && goalColumn != 0 &&\n            start.line == 0 && start.ch != 0) || (amount > 0 &&\n            range.head == doc.length && pos.ch != goalColumn\n            && start.line == pos.line)) {\n            pos.hitSide = true;\n        }\n        return pos;\n    }\n    ;\n    charCoords(pos, mode) {\n        var rect = this.cm6.contentDOM.getBoundingClientRect();\n        var offset = indexFromPos(this.cm6.state.doc, pos);\n        var coords = this.cm6.coordsAtPos(offset);\n        var d = -rect.top;\n        return { left: ((coords === null || coords === void 0 ? void 0 : coords.left) || 0) - rect.left, top: ((coords === null || coords === void 0 ? void 0 : coords.top) || 0) + d, bottom: ((coords === null || coords === void 0 ? void 0 : coords.bottom) || 0) + d };\n    }\n    ;\n    coordsChar(coords, mode) {\n        var rect = this.cm6.contentDOM.getBoundingClientRect();\n        var offset = this.cm6.posAtCoords({ x: coords.left + rect.left, y: coords.top + rect.top }) || 0;\n        return posFromIndex(this.cm6.state.doc, offset);\n    }\n    ;\n    getScrollInfo() {\n        var scroller = this.cm6.scrollDOM;\n        return {\n            left: scroller.scrollLeft, top: scroller.scrollTop,\n            height: scroller.scrollHeight,\n            width: scroller.scrollWidth,\n            clientHeight: scroller.clientHeight, clientWidth: scroller.clientWidth\n        };\n    }\n    ;\n    scrollTo(x, y) {\n        if (x != null)\n            this.cm6.scrollDOM.scrollLeft = x;\n        if (y != null)\n            this.cm6.scrollDOM.scrollTop = y;\n    }\n    ;\n    scrollIntoView(pos, margin) {\n        if (pos) {\n            var offset = this.indexFromPos(pos);\n            this.cm6.dispatch({\n                effects: _codemirror_view__WEBPACK_IMPORTED_MODULE_1__.EditorView.scrollIntoView(offset)\n            });\n        }\n        else {\n            this.cm6.dispatch({ scrollIntoView: true, userEvent: \"scroll\" });\n        }\n    }\n    ;\n    getWrapperElement() {\n        return this.cm6.dom;\n    }\n    ;\n    // for tests\n    getMode() {\n        return { name: this.getOption(\"mode\") };\n    }\n    ;\n    setSize(w, h) {\n        this.cm6.dom.style.width = w + 4 + \"px\";\n        this.cm6.dom.style.height = h + \"px\";\n        this.refresh();\n    }\n    refresh() {\n        this.cm6.measure();\n    }\n    // event listeners\n    destroy() {\n        this.removeOverlay();\n    }\n    ;\n    getLastEditEnd() {\n        return this.posFromIndex(this.$lastChangeEndOffset);\n    }\n    ;\n    onChange(update) {\n        if (this.$lineHandleChanges) {\n            this.$lineHandleChanges.push(update);\n        }\n        for (let i in this.marks) {\n            let m = this.marks[i];\n            m.update(update.changes);\n        }\n        if (this.virtualSelection) {\n            this.virtualSelection.ranges = this.virtualSelection.ranges.map(range => range.map(update.changes));\n        }\n        var curOp = this.curOp = this.curOp || {};\n        update.changes.iterChanges((fromA, toA, fromB, toB, text) => {\n            if (curOp.$changeStart == null || curOp.$changeStart > fromB)\n                curOp.$changeStart = fromB;\n            this.$lastChangeEndOffset = toB;\n            var change = { text: text.toJSON() };\n            if (!curOp.lastChange) {\n                curOp.lastChange = curOp.change = change;\n            }\n            else {\n                curOp.lastChange.next = curOp.lastChange = change;\n            }\n        }, true);\n        if (!curOp.changeHandlers)\n            curOp.changeHandlers = this._handlers[\"change\"] && this._handlers[\"change\"].slice();\n    }\n    ;\n    onSelectionChange() {\n        var curOp = this.curOp = this.curOp || {};\n        if (!curOp.cursorActivityHandlers)\n            curOp.cursorActivityHandlers = this._handlers[\"cursorActivity\"] && this._handlers[\"cursorActivity\"].slice();\n        this.curOp.cursorActivity = true;\n    }\n    ;\n    operation(fn, force) {\n        if (!this.curOp)\n            this.curOp = { $d: 0 };\n        this.curOp.$d++;\n        try {\n            var result = fn();\n        }\n        finally {\n            if (this.curOp) {\n                this.curOp.$d--;\n                if (!this.curOp.$d)\n                    this.onBeforeEndOperation();\n            }\n        }\n        return result;\n    }\n    ;\n    onBeforeEndOperation() {\n        var op = this.curOp;\n        var scrollIntoView = false;\n        if (op) {\n            if (op.change) {\n                signalTo(op.changeHandlers, this, op.change);\n            }\n            if (op && op.cursorActivity) {\n                signalTo(op.cursorActivityHandlers, this, null);\n                if (op.isVimOp)\n                    scrollIntoView = true;\n            }\n            this.curOp = null;\n        }\n        if (scrollIntoView)\n            this.scrollIntoView();\n    }\n    ;\n    moveH(increment, unit) {\n        if (unit == 'char') {\n            // todo\n            var cur = this.getCursor();\n            this.setCursor(cur.line, cur.ch + increment);\n        }\n    }\n    ;\n    setOption(name, val) {\n        switch (name) {\n            case \"keyMap\":\n                this.state.keyMap = val;\n                break;\n            case \"textwidth\":\n                this.state.textwidth = val;\n                break;\n        }\n    }\n    ;\n    getOption(name) {\n        switch (name) {\n            case \"firstLineNumber\": return 1;\n            case \"tabSize\": return this.cm6.state.tabSize || 4;\n            case \"readOnly\": return this.cm6.state.readOnly;\n            case \"indentWithTabs\": return this.cm6.state.facet(_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.indentUnit) == \"\\t\"; // TODO\n            case \"indentUnit\": return this.cm6.state.facet(_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.indentUnit).length || 2;\n            case \"textwidth\": return this.state.textwidth;\n            // for tests\n            case \"keyMap\": return this.state.keyMap || \"vim\";\n        }\n    }\n    ;\n    toggleOverwrite(on) {\n        this.state.overwrite = on;\n    }\n    ;\n    getTokenTypeAt(pos) {\n        var _a;\n        // only comment|string are needed\n        var offset = this.indexFromPos(pos);\n        var tree = (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.ensureSyntaxTree)(this.cm6.state, offset);\n        var node = tree === null || tree === void 0 ? void 0 : tree.resolve(offset);\n        var type = ((_a = node === null || node === void 0 ? void 0 : node.type) === null || _a === void 0 ? void 0 : _a.name) || \"\";\n        if (/comment/i.test(type))\n            return \"comment\";\n        if (/string/i.test(type))\n            return \"string\";\n        return \"\";\n    }\n    ;\n    overWriteSelection(text) {\n        var doc = this.cm6.state.doc;\n        var sel = this.cm6.state.selection;\n        var ranges = sel.ranges.map(x => {\n            if (x.empty) {\n                var ch = x.to < doc.length ? doc.sliceString(x.from, x.to + 1) : \"\";\n                if (ch && !/\\n/.test(ch))\n                    return _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.range(x.from, x.to + 1);\n            }\n            return x;\n        });\n        this.cm6.dispatch({\n            selection: _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.create(ranges, sel.mainIndex)\n        });\n        this.replaceSelection(text);\n    }\n    /*** multiselect ****/\n    isInMultiSelectMode() {\n        return this.cm6.state.selection.ranges.length > 1;\n    }\n    virtualSelectionMode() {\n        return !!this.virtualSelection;\n    }\n    forEachSelection(command) {\n        var selection = this.cm6.state.selection;\n        this.virtualSelection = _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.create(selection.ranges, selection.mainIndex);\n        for (var i = 0; i < this.virtualSelection.ranges.length; i++) {\n            var range = this.virtualSelection.ranges[i];\n            if (!range)\n                continue;\n            this.cm6.dispatch({ selection: _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.create([range]) });\n            command();\n            this.virtualSelection.ranges[i] = this.cm6.state.selection.ranges[0];\n        }\n        this.cm6.dispatch({ selection: this.virtualSelection });\n        this.virtualSelection = null;\n    }\n    hardWrap(options) {\n        return hardWrap(this, options);\n    }\n}\nCodeMirror.isMac = typeof navigator != \"undefined\" && /*@__PURE__*//Mac/.test(navigator.platform);\n// --------------------------\nCodeMirror.Pos = Pos;\nCodeMirror.StringStream = _codemirror_language__WEBPACK_IMPORTED_MODULE_3__.StringStream;\nCodeMirror.commands = {\n    cursorCharLeft: function (cm) { (0,_codemirror_commands__WEBPACK_IMPORTED_MODULE_0__.cursorCharLeft)(cm.cm6); },\n    redo: function (cm) { runHistoryCommand(cm, false); },\n    undo: function (cm) { runHistoryCommand(cm, true); },\n    newlineAndIndent: function (cm) {\n        (0,_codemirror_commands__WEBPACK_IMPORTED_MODULE_0__.insertNewlineAndIndent)({\n            state: cm.cm6.state,\n            dispatch: (tr) => {\n                return dispatchChange(cm, tr);\n            }\n        });\n    },\n    indentAuto: function (cm) {\n        (0,_codemirror_commands__WEBPACK_IMPORTED_MODULE_0__.indentSelection)(cm.cm6);\n    },\n    newlineAndIndentContinueComment: undefined,\n    save: undefined,\n};\nCodeMirror.isWordChar = function (ch) {\n    return wordChar.test(ch);\n};\nCodeMirror.keys = keys;\nCodeMirror.addClass = function (el, str) { };\nCodeMirror.rmClass = function (el, str) { };\nCodeMirror.e_preventDefault = function (e) {\n    e.preventDefault();\n};\nCodeMirror.e_stop = function (e) {\n    var _a, _b;\n    (_a = e === null || e === void 0 ? void 0 : e.stopPropagation) === null || _a === void 0 ? void 0 : _a.call(e);\n    (_b = e === null || e === void 0 ? void 0 : e.preventDefault) === null || _b === void 0 ? void 0 : _b.call(e);\n};\nCodeMirror.lookupKey = function lookupKey(key, map, handle) {\n    var result = CodeMirror.keys[key];\n    if (!result && /^Arrow/.test(key))\n        result = CodeMirror.keys[key.slice(5)];\n    if (result)\n        handle(result);\n};\nCodeMirror.on = on;\nCodeMirror.off = off;\nCodeMirror.signal = signal;\nCodeMirror.findMatchingTag = findMatchingTag;\nCodeMirror.findEnclosingTag = findEnclosingTag;\nCodeMirror.keyName = undefined;\n/************* dialog *************/\nfunction dialogDiv(cm, template, bottom) {\n    var dialog = document.createElement(\"div\");\n    dialog.appendChild(template);\n    return dialog;\n}\nfunction closeNotification(cm, newVal) {\n    if (cm.state.currentNotificationClose)\n        cm.state.currentNotificationClose();\n    cm.state.currentNotificationClose = newVal;\n}\nfunction openNotification(cm, template, options) {\n    closeNotification(cm, close);\n    var dialog = dialogDiv(cm, template, options && options.bottom);\n    var closed = false;\n    var doneTimer;\n    var duration = options && typeof options.duration !== \"undefined\" ? options.duration : 5000;\n    function close() {\n        if (closed)\n            return;\n        closed = true;\n        clearTimeout(doneTimer);\n        dialog.remove();\n        hideDialog(cm, dialog);\n    }\n    dialog.onclick = function (e) {\n        e.preventDefault();\n        close();\n    };\n    showDialog(cm, dialog);\n    if (duration)\n        doneTimer = setTimeout(close, duration);\n    return close;\n}\nfunction showDialog(cm, dialog) {\n    var oldDialog = cm.state.dialog;\n    cm.state.dialog = dialog;\n    dialog.style.flex = \"1\";\n    if (dialog && oldDialog !== dialog) {\n        if (oldDialog && oldDialog.contains(document.activeElement))\n            cm.focus();\n        if (oldDialog && oldDialog.parentElement) {\n            oldDialog.parentElement.replaceChild(dialog, oldDialog);\n        }\n        else if (oldDialog) {\n            oldDialog.remove();\n        }\n        CodeMirror.signal(cm, \"dialog\");\n    }\n}\nfunction hideDialog(cm, dialog) {\n    if (cm.state.dialog == dialog) {\n        cm.state.dialog = null;\n        CodeMirror.signal(cm, \"dialog\");\n    }\n}\nfunction openDialog(me, template, callback, options) {\n    if (!options)\n        options = {};\n    closeNotification(me, undefined);\n    var dialog = dialogDiv(me, template, options.bottom);\n    var closed = false;\n    showDialog(me, dialog);\n    function close(newVal) {\n        if (typeof newVal == 'string') {\n            inp.value = newVal;\n        }\n        else {\n            if (closed)\n                return;\n            closed = true;\n            hideDialog(me, dialog);\n            if (!me.state.dialog)\n                me.focus();\n            if (options.onClose)\n                options.onClose(dialog);\n        }\n    }\n    var inp = dialog.getElementsByTagName(\"input\")[0];\n    if (inp) {\n        if (options.value) {\n            inp.value = options.value;\n            if (options.selectValueOnOpen !== false)\n                inp.select();\n        }\n        if (options.onInput)\n            CodeMirror.on(inp, \"input\", function (e) { options.onInput(e, inp.value, close); });\n        if (options.onKeyUp)\n            CodeMirror.on(inp, \"keyup\", function (e) { options.onKeyUp(e, inp.value, close); });\n        CodeMirror.on(inp, \"keydown\", function (e) {\n            if (options && options.onKeyDown && options.onKeyDown(e, inp.value, close)) {\n                return;\n            }\n            if (e.keyCode == 13)\n                callback && callback(inp.value);\n            if (e.keyCode == 27 || (options.closeOnEnter !== false && e.keyCode == 13)) {\n                inp.blur();\n                CodeMirror.e_stop(e);\n                close();\n            }\n        });\n        if (options.closeOnBlur !== false)\n            CodeMirror.on(inp, \"blur\", function () {\n                setTimeout(function () {\n                    if (document.activeElement === inp)\n                        return;\n                    close();\n                });\n            });\n        inp.focus();\n    }\n    return close;\n}\nvar matching = { \"(\": \")>\", \")\": \"(<\", \"[\": \"]>\", \"]\": \"[<\", \"{\": \"}>\", \"}\": \"{<\", \"<\": \">>\", \">\": \"<<\" };\nfunction bracketRegex(config) {\n    return config && config.bracketRegex || /[(){}[\\]]/;\n}\nfunction scanForBracket(cm, where, dir, style, config) {\n    var maxScanLen = (config && config.maxScanLineLength) || 10000;\n    var maxScanLines = (config && config.maxScanLines) || 1000;\n    var stack = [];\n    var re = bracketRegex(config);\n    var lineEnd = dir > 0 ? Math.min(where.line + maxScanLines, cm.lastLine() + 1)\n        : Math.max(cm.firstLine() - 1, where.line - maxScanLines);\n    for (var lineNo = where.line; lineNo != lineEnd; lineNo += dir) {\n        var line = cm.getLine(lineNo);\n        if (!line)\n            continue;\n        var pos = dir > 0 ? 0 : line.length - 1, end = dir > 0 ? line.length : -1;\n        if (line.length > maxScanLen)\n            continue;\n        if (lineNo == where.line)\n            pos = where.ch - (dir < 0 ? 1 : 0);\n        for (; pos != end; pos += dir) {\n            var ch = line.charAt(pos);\n            if (re.test(ch) /*&& (style === undefined ||\n                                (cm.getTokenTypeAt(new Pos(lineNo, pos + 1)) || \"\") == (style || \"\"))*/) {\n                var match = matching[ch];\n                if (match && (match.charAt(1) == \">\") == (dir > 0))\n                    stack.push(ch);\n                else if (!stack.length)\n                    return { pos: new Pos(lineNo, pos), ch: ch };\n                else\n                    stack.pop();\n            }\n        }\n    }\n    return lineNo - dir == (dir > 0 ? cm.lastLine() : cm.firstLine()) ? false : null;\n}\nfunction findMatchingTag(cm, pos) {\n    return null;\n}\nfunction findEnclosingTag(cm, pos) {\n    var _a, _b;\n    var state = cm.cm6.state;\n    var offset = cm.indexFromPos(pos);\n    if (offset < state.doc.length) {\n        var text = state.sliceDoc(offset, offset + 1);\n        if (text == \"<\")\n            offset++;\n    }\n    var tree = (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.ensureSyntaxTree)(state, offset);\n    var node = (tree === null || tree === void 0 ? void 0 : tree.resolve(offset)) || null;\n    while (node) {\n        if (((_a = node.firstChild) === null || _a === void 0 ? void 0 : _a.type.name) == 'OpenTag'\n            && ((_b = node.lastChild) === null || _b === void 0 ? void 0 : _b.type.name) == 'CloseTag') {\n            return {\n                open: convertRange(state.doc, node.firstChild),\n                close: convertRange(state.doc, node.lastChild),\n            };\n        }\n        node = node.parent;\n    }\n}\nfunction convertRange(doc, cm6Range) {\n    return {\n        from: posFromIndex(doc, cm6Range.from),\n        to: posFromIndex(doc, cm6Range.to)\n    };\n}\nclass Marker {\n    constructor(cm, offset, assoc) {\n        this.cm = cm;\n        this.id = cm.$mid++;\n        this.offset = offset;\n        this.assoc = assoc;\n        cm.marks[this.id] = this;\n    }\n    ;\n    clear() { delete this.cm.marks[this.id]; }\n    ;\n    find() {\n        if (this.offset == null)\n            return null;\n        return this.cm.posFromIndex(this.offset);\n    }\n    ;\n    update(change) {\n        if (this.offset != null)\n            this.offset = change.mapPos(this.offset, this.assoc, _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.MapMode.TrackDel);\n    }\n}\nfunction hardWrap(cm, options) {\n    var _a;\n    var max = options.column || cm.getOption('textwidth') || 80;\n    var allowMerge = options.allowMerge != false;\n    var row = Math.min(options.from, options.to);\n    var endRow = Math.max(options.from, options.to);\n    while (row <= endRow) {\n        var line = cm.getLine(row);\n        if (line.length > max) {\n            var space = findSpace(line, max, 5);\n            if (space) {\n                var indentation = (_a = /^\\s*/.exec(line)) === null || _a === void 0 ? void 0 : _a[0];\n                cm.replaceRange(\"\\n\" + indentation, new Pos(row, space.start), new Pos(row, space.end));\n            }\n            endRow++;\n        }\n        else if (allowMerge && /\\S/.test(line) && row != endRow) {\n            var nextLine = cm.getLine(row + 1);\n            if (nextLine && /\\S/.test(nextLine)) {\n                var trimmedLine = line.replace(/\\s+$/, \"\");\n                var trimmedNextLine = nextLine.replace(/^\\s+/, \"\");\n                var mergedLine = trimmedLine + \" \" + trimmedNextLine;\n                var space = findSpace(mergedLine, max, 5);\n                if (space && space.start > trimmedLine.length || mergedLine.length < max) {\n                    cm.replaceRange(\" \", new Pos(row, trimmedLine.length), new Pos(row + 1, nextLine.length - trimmedNextLine.length));\n                    row--;\n                    endRow--;\n                }\n                else if (trimmedLine.length < line.length) {\n                    cm.replaceRange(\"\", new Pos(row, trimmedLine.length), new Pos(row, line.length));\n                }\n            }\n        }\n        row++;\n    }\n    return row;\n    function findSpace(line, max, min) {\n        if (line.length < max)\n            return;\n        var before = line.slice(0, max);\n        var after = line.slice(max);\n        var spaceAfter = /^(?:(\\s+)|(\\S+)(\\s+))/.exec(after);\n        var spaceBefore = /(?:(\\s+)|(\\s+)(\\S+))$/.exec(before);\n        var start = 0;\n        var end = 0;\n        if (spaceBefore && !spaceBefore[2]) {\n            start = max - spaceBefore[1].length;\n            end = max;\n        }\n        if (spaceAfter && !spaceAfter[2]) {\n            if (!start)\n                start = max;\n            end = max + spaceAfter[1].length;\n        }\n        if (start) {\n            return {\n                start: start,\n                end: end\n            };\n        }\n        if (spaceBefore && spaceBefore[2] && spaceBefore.index > min) {\n            return {\n                start: spaceBefore.index,\n                end: spaceBefore.index + spaceBefore[2].length\n            };\n        }\n        if (spaceAfter && spaceAfter[2]) {\n            start = max + spaceAfter[2].length;\n            return {\n                start: start,\n                end: start + spaceAfter[3].length\n            };\n        }\n    }\n}\n\n// backwards compatibility for old versions not supporting getDrawSelectionConfig\nlet getDrawSelectionConfig = _codemirror_view__WEBPACK_IMPORTED_MODULE_1__.getDrawSelectionConfig || /*@__PURE__*/function () {\n    let defaultConfig = { cursorBlinkRate: 1200 };\n    return function () {\n        return defaultConfig;\n    };\n}();\nclass Piece {\n    constructor(left, top, height, fontFamily, fontSize, fontWeight, color, className, letter, partial) {\n        this.left = left;\n        this.top = top;\n        this.height = height;\n        this.fontFamily = fontFamily;\n        this.fontSize = fontSize;\n        this.fontWeight = fontWeight;\n        this.color = color;\n        this.className = className;\n        this.letter = letter;\n        this.partial = partial;\n    }\n    draw() {\n        let elt = document.createElement(\"div\");\n        elt.className = this.className;\n        this.adjust(elt);\n        return elt;\n    }\n    adjust(elt) {\n        elt.style.left = this.left + \"px\";\n        elt.style.top = this.top + \"px\";\n        elt.style.height = this.height + \"px\";\n        elt.style.lineHeight = this.height + \"px\";\n        elt.style.fontFamily = this.fontFamily;\n        elt.style.fontSize = this.fontSize;\n        elt.style.fontWeight = this.fontWeight;\n        elt.style.color = this.partial ? \"transparent\" : this.color;\n        elt.className = this.className;\n        elt.textContent = this.letter;\n    }\n    eq(p) {\n        return this.left == p.left && this.top == p.top && this.height == p.height &&\n            this.fontFamily == p.fontFamily && this.fontSize == p.fontSize &&\n            this.fontWeight == p.fontWeight && this.color == p.color &&\n            this.className == p.className &&\n            this.letter == p.letter;\n    }\n}\nclass BlockCursorPlugin {\n    constructor(view, cm) {\n        this.view = view;\n        this.rangePieces = [];\n        this.cursors = [];\n        this.cm = cm;\n        this.measureReq = { read: this.readPos.bind(this), write: this.drawSel.bind(this) };\n        this.cursorLayer = view.scrollDOM.appendChild(document.createElement(\"div\"));\n        this.cursorLayer.className = \"cm-cursorLayer cm-vimCursorLayer\";\n        this.cursorLayer.setAttribute(\"aria-hidden\", \"true\");\n        view.requestMeasure(this.measureReq);\n        this.setBlinkRate();\n    }\n    setBlinkRate() {\n        let config = getDrawSelectionConfig(this.cm.cm6.state);\n        let blinkRate = config.cursorBlinkRate;\n        this.cursorLayer.style.animationDuration = blinkRate + \"ms\";\n    }\n    update(update) {\n        if (update.selectionSet || update.geometryChanged || update.viewportChanged) {\n            this.view.requestMeasure(this.measureReq);\n            this.cursorLayer.style.animationName = this.cursorLayer.style.animationName == \"cm-blink\" ? \"cm-blink2\" : \"cm-blink\";\n        }\n        if (configChanged(update))\n            this.setBlinkRate();\n    }\n    scheduleRedraw() {\n        this.view.requestMeasure(this.measureReq);\n    }\n    readPos() {\n        let { state } = this.view;\n        let cursors = [];\n        for (let r of state.selection.ranges) {\n            let prim = r == state.selection.main;\n            let piece = measureCursor(this.cm, this.view, r, prim);\n            if (piece)\n                cursors.push(piece);\n        }\n        return { cursors };\n    }\n    drawSel({ cursors }) {\n        if (cursors.length != this.cursors.length || cursors.some((c, i) => !c.eq(this.cursors[i]))) {\n            let oldCursors = this.cursorLayer.children;\n            if (oldCursors.length !== cursors.length) {\n                this.cursorLayer.textContent = \"\";\n                for (const c of cursors)\n                    this.cursorLayer.appendChild(c.draw());\n            }\n            else {\n                cursors.forEach((c, idx) => c.adjust(oldCursors[idx]));\n            }\n            this.cursors = cursors;\n        }\n    }\n    destroy() {\n        this.cursorLayer.remove();\n    }\n}\nfunction configChanged(update) {\n    return getDrawSelectionConfig(update.startState) != getDrawSelectionConfig(update.state);\n}\nconst themeSpec = {\n    \".cm-vimMode .cm-line\": {\n        \"& ::selection\": { backgroundColor: \"transparent !important\" },\n        \"&::selection\": { backgroundColor: \"transparent !important\" },\n        caretColor: \"transparent !important\",\n    },\n    \".cm-fat-cursor\": {\n        position: \"absolute\",\n        background: \"#ff9696\",\n        border: \"none\",\n        whiteSpace: \"pre\",\n    },\n    \"&:not(.cm-focused) .cm-fat-cursor\": {\n        background: \"none\",\n        outline: \"solid 1px #ff9696\",\n        color: \"transparent !important\",\n    },\n};\nconst hideNativeSelection = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Prec.highest(/*@__PURE__*/_codemirror_view__WEBPACK_IMPORTED_MODULE_1__.EditorView.theme(themeSpec));\nfunction getBase(view) {\n    let rect = view.scrollDOM.getBoundingClientRect();\n    let left = view.textDirection == _codemirror_view__WEBPACK_IMPORTED_MODULE_1__.Direction.LTR ? rect.left : rect.right - view.scrollDOM.clientWidth;\n    return { left: left - view.scrollDOM.scrollLeft * view.scaleX, top: rect.top - view.scrollDOM.scrollTop * view.scaleY };\n}\nfunction measureCursor(cm, view, cursor, primary) {\n    var _a, _b, _c, _d;\n    let head = cursor.head;\n    let fatCursor = false;\n    let hCoeff = 1;\n    let vim = cm.state.vim;\n    if (vim && (!vim.insertMode || cm.state.overwrite)) {\n        fatCursor = true;\n        if (vim.visualBlock && !primary)\n            return null;\n        if (cursor.anchor < cursor.head) {\n            let letter = head < view.state.doc.length && view.state.sliceDoc(head, head + 1);\n            if (letter != \"\\n\")\n                head--;\n        }\n        if (cm.state.overwrite)\n            hCoeff = 0.2;\n        else if (vim.status)\n            hCoeff = 0.5;\n    }\n    if (fatCursor) {\n        let letter = head < view.state.doc.length && view.state.sliceDoc(head, head + 1);\n        if (letter && (/[\\uDC00-\\uDFFF]/.test(letter) && head > 1)) {\n            // step back if cursor is on the second half of a surrogate pair\n            head--;\n            letter = view.state.sliceDoc(head, head + 1);\n        }\n        let pos = view.coordsAtPos(head, 1);\n        if (!pos)\n            return null;\n        let base = getBase(view);\n        let domAtPos = view.domAtPos(head);\n        let node = domAtPos ? domAtPos.node : view.contentDOM;\n        if (node instanceof Text && domAtPos.offset >= node.data.length) {\n            if ((_a = node.parentElement) === null || _a === void 0 ? void 0 : _a.nextSibling) {\n                node = (_b = node.parentElement) === null || _b === void 0 ? void 0 : _b.nextSibling;\n                domAtPos = { node: node, offset: 0 };\n            }\n        }\n        while (domAtPos && domAtPos.node instanceof HTMLElement) {\n            node = domAtPos.node;\n            domAtPos = { node: domAtPos.node.childNodes[domAtPos.offset], offset: 0 };\n        }\n        if (!(node instanceof HTMLElement)) {\n            if (!node.parentNode)\n                return null;\n            node = node.parentNode;\n        }\n        let style = getComputedStyle(node);\n        let left = pos.left;\n        // TODO remove coordsAtPos when all supported versions of codemirror have coordsForChar api\n        let charCoords = (_d = (_c = view).coordsForChar) === null || _d === void 0 ? void 0 : _d.call(_c, head);\n        if (charCoords) {\n            left = charCoords.left;\n        }\n        if (!letter || letter == \"\\n\" || letter == \"\\r\") {\n            letter = \"\\xa0\";\n        }\n        else if (letter == \"\\t\") {\n            letter = \"\\xa0\";\n            var nextPos = view.coordsAtPos(head + 1, -1);\n            if (nextPos) {\n                left = nextPos.left - (nextPos.left - pos.left) / parseInt(style.tabSize);\n            }\n        }\n        else if ((/[\\uD800-\\uDBFF]/.test(letter) && head < view.state.doc.length - 1)) {\n            // include the second half of a surrogate pair in cursor\n            letter += view.state.sliceDoc(head + 1, head + 2);\n        }\n        let h = (pos.bottom - pos.top);\n        return new Piece((left - base.left) / view.scaleX, (pos.top - base.top + h * (1 - hCoeff)) / view.scaleY, h * hCoeff / view.scaleY, style.fontFamily, style.fontSize, style.fontWeight, style.color, primary ? \"cm-fat-cursor cm-cursor-primary\" : \"cm-fat-cursor cm-cursor-secondary\", letter, hCoeff != 1);\n    }\n    else {\n        return null;\n    }\n}\n\nvar FIREFOX_LINUX = typeof navigator != \"undefined\"\n    && /*@__PURE__*//linux/i.test(navigator.platform)\n    && /*@__PURE__*// Gecko\\/\\d+/.exec(navigator.userAgent);\nconst Vim = /*@__PURE__*/initVim(CodeMirror);\nconst HighlightMargin = 250;\nconst vimStyle = /*@__PURE__*/_codemirror_view__WEBPACK_IMPORTED_MODULE_1__.EditorView.baseTheme({\n    \".cm-vimMode .cm-cursorLayer:not(.cm-vimCursorLayer)\": {\n        display: \"none\",\n    },\n    \".cm-vim-panel\": {\n        padding: \"0px 10px\",\n        fontFamily: \"monospace\",\n        minHeight: \"1.3em\",\n        display: 'flex',\n    },\n    \".cm-vim-panel input\": {\n        border: \"none\",\n        outline: \"none\",\n        backgroundColor: \"inherit\",\n    },\n    \"&light .cm-searchMatch\": { backgroundColor: \"#ffff0054\" },\n    \"&dark .cm-searchMatch\": { backgroundColor: \"#00ffff8a\" },\n});\nconst vimPlugin = /*@__PURE__*/_codemirror_view__WEBPACK_IMPORTED_MODULE_1__.ViewPlugin.fromClass(class {\n    constructor(view) {\n        this.status = \"\";\n        this.query = null;\n        this.decorations = _codemirror_view__WEBPACK_IMPORTED_MODULE_1__.Decoration.none;\n        this.waitForCopy = false;\n        this.lastKeydown = '';\n        this.useNextTextInput = false;\n        this.compositionText = '';\n        this.view = view;\n        const cm = (this.cm = new CodeMirror(view));\n        Vim.enterVimMode(this.cm);\n        this.view.cm = this.cm;\n        this.cm.state.vimPlugin = this;\n        this.blockCursor = new BlockCursorPlugin(view, cm);\n        this.updateClass();\n        this.cm.on(\"vim-command-done\", () => {\n            if (cm.state.vim)\n                cm.state.vim.status = \"\";\n            this.blockCursor.scheduleRedraw();\n            this.updateStatus();\n        });\n        this.cm.on(\"vim-mode-change\", (e) => {\n            if (!cm.state.vim)\n                return;\n            cm.state.vim.mode = e.mode;\n            if (e.subMode) {\n                cm.state.vim.mode += \" block\";\n            }\n            cm.state.vim.status = \"\";\n            this.blockCursor.scheduleRedraw();\n            this.updateClass();\n            this.updateStatus();\n        });\n        this.cm.on(\"dialog\", () => {\n            if (this.cm.state.statusbar) {\n                this.updateStatus();\n            }\n            else {\n                view.dispatch({\n                    effects: showVimPanel.of(!!this.cm.state.dialog),\n                });\n            }\n        });\n        this.dom = document.createElement(\"span\");\n        this.spacer = document.createElement(\"span\");\n        this.spacer.style.flex = \"1\";\n        this.statusButton = document.createElement(\"span\");\n        this.statusButton.onclick = (e) => {\n            Vim.handleKey(this.cm, \"<Esc>\", \"user\");\n            this.cm.focus();\n        };\n        this.statusButton.style.cssText = \"cursor: pointer\";\n    }\n    update(update) {\n        var _a;\n        if ((update.viewportChanged || update.docChanged) && this.query) {\n            this.highlight(this.query);\n        }\n        if (update.docChanged) {\n            this.cm.onChange(update);\n        }\n        if (update.selectionSet) {\n            this.cm.onSelectionChange();\n        }\n        if (update.viewportChanged) ;\n        if (this.cm.curOp && !this.cm.curOp.isVimOp) {\n            this.cm.onBeforeEndOperation();\n        }\n        if (update.transactions) {\n            for (let tr of update.transactions)\n                for (let effect of tr.effects) {\n                    if (effect.is(_codemirror_search__WEBPACK_IMPORTED_MODULE_4__.setSearchQuery)) {\n                        let forVim = (_a = effect.value) === null || _a === void 0 ? void 0 : _a.forVim;\n                        if (!forVim) {\n                            this.highlight(null);\n                        }\n                        else {\n                            let query = effect.value.create();\n                            this.highlight(query);\n                        }\n                    }\n                }\n        }\n        this.blockCursor.update(update);\n    }\n    updateClass() {\n        const state = this.cm.state;\n        if (!state.vim || (state.vim.insertMode && !state.overwrite))\n            this.view.scrollDOM.classList.remove(\"cm-vimMode\");\n        else\n            this.view.scrollDOM.classList.add(\"cm-vimMode\");\n    }\n    updateStatus() {\n        let dom = this.cm.state.statusbar;\n        let vim = this.cm.state.vim;\n        if (!dom || !vim)\n            return;\n        let dialog = this.cm.state.dialog;\n        if (dialog) {\n            if (dialog.parentElement != dom) {\n                dom.textContent = \"\";\n                dom.appendChild(dialog);\n            }\n        }\n        else {\n            dom.textContent = \"\";\n            var status = (vim.mode || \"normal\").toUpperCase();\n            if (vim.insertModeReturn)\n                status += \"(C-O)\";\n            this.statusButton.textContent = `--${status}--`;\n            dom.appendChild(this.statusButton);\n            dom.appendChild(this.spacer);\n        }\n        this.dom.textContent = vim.status;\n        dom.appendChild(this.dom);\n    }\n    destroy() {\n        Vim.leaveVimMode(this.cm);\n        this.updateClass();\n        this.blockCursor.destroy();\n        delete this.view.cm;\n    }\n    highlight(query) {\n        this.query = query;\n        if (!query)\n            return (this.decorations = _codemirror_view__WEBPACK_IMPORTED_MODULE_1__.Decoration.none);\n        let { view } = this;\n        let builder = new _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.RangeSetBuilder();\n        for (let i = 0, ranges = view.visibleRanges, l = ranges.length; i < l; i++) {\n            let { from, to } = ranges[i];\n            while (i < l - 1 && to > ranges[i + 1].from - 2 * HighlightMargin)\n                to = ranges[++i].to;\n            query.highlight(view.state, from, to, (from, to) => {\n                builder.add(from, to, matchMark);\n            });\n        }\n        return (this.decorations = builder.finish());\n    }\n    handleKey(e, view) {\n        const cm = this.cm;\n        let vim = cm.state.vim;\n        if (!vim)\n            return;\n        const key = Vim.vimKeyFromEvent(e, vim);\n        CodeMirror.signal(this.cm, 'inputEvent', { type: \"handleKey\", key });\n        if (!key)\n            return;\n        // clear search highlight\n        if (key == \"<Esc>\" &&\n            !vim.insertMode &&\n            !vim.visualMode &&\n            this.query /* && !cm.inMultiSelectMode*/) {\n            const searchState = vim.searchState_;\n            if (searchState) {\n                cm.removeOverlay(searchState.getOverlay());\n                searchState.setOverlay(null);\n            }\n        }\n        let isCopy = key === \"<C-c>\" && !CodeMirror.isMac;\n        if (isCopy && cm.somethingSelected()) {\n            this.waitForCopy = true;\n            return true;\n        }\n        vim.status = (vim.status || \"\") + key;\n        let result = Vim.multiSelectHandleKey(cm, key, \"user\");\n        vim = Vim.maybeInitVimState_(cm); // the object can change if there is an exception in handleKey\n        // insert mode\n        if (!result && vim.insertMode && cm.state.overwrite) {\n            if (e.key && e.key.length == 1 && !/\\n/.test(e.key)) {\n                result = true;\n                cm.overWriteSelection(e.key);\n            }\n            else if (e.key == \"Backspace\") {\n                result = true;\n                CodeMirror.commands.cursorCharLeft(cm);\n            }\n        }\n        if (result) {\n            CodeMirror.signal(this.cm, 'vim-keypress', key);\n            e.preventDefault();\n            e.stopPropagation();\n            this.blockCursor.scheduleRedraw();\n        }\n        this.updateStatus();\n        return !!result;\n    }\n}, {\n    eventHandlers: {\n        copy: function (e, view) {\n            if (!this.waitForCopy)\n                return;\n            this.waitForCopy = false;\n            Promise.resolve().then(() => {\n                var cm = this.cm;\n                var vim = cm.state.vim;\n                if (!vim)\n                    return;\n                if (vim.insertMode) {\n                    cm.setSelection(cm.getCursor(), cm.getCursor());\n                }\n                else {\n                    cm.operation(() => {\n                        if (cm.curOp)\n                            cm.curOp.isVimOp = true;\n                        Vim.handleKey(cm, '<Esc>', 'user');\n                    });\n                }\n            });\n        },\n        compositionstart: function (e, view) {\n            this.useNextTextInput = true;\n            CodeMirror.signal(this.cm, 'inputEvent', e);\n        },\n        compositionupdate: function (e, view) {\n            CodeMirror.signal(this.cm, 'inputEvent', e);\n        },\n        compositionend: function (e, view) {\n            CodeMirror.signal(this.cm, 'inputEvent', e);\n        },\n        keypress: function (e, view) {\n            CodeMirror.signal(this.cm, 'inputEvent', e);\n            if (this.lastKeydown == \"Dead\")\n                this.handleKey(e, view);\n        },\n        keydown: function (e, view) {\n            CodeMirror.signal(this.cm, 'inputEvent', e);\n            this.lastKeydown = e.key;\n            if (this.lastKeydown == \"Unidentified\"\n                || this.lastKeydown == \"Process\"\n                || this.lastKeydown == \"Dead\") {\n                this.useNextTextInput = true;\n            }\n            else {\n                this.useNextTextInput = false;\n                this.handleKey(e, view);\n            }\n        },\n    },\n    provide: () => {\n        return [\n            _codemirror_view__WEBPACK_IMPORTED_MODULE_1__.EditorView.inputHandler.of((view, from, to, text) => {\n                var _a, _b;\n                var cm = getCM(view);\n                if (!cm)\n                    return false;\n                var vim = (_a = cm.state) === null || _a === void 0 ? void 0 : _a.vim;\n                var vimPlugin = cm.state.vimPlugin;\n                if (vim && !vim.insertMode && !((_b = cm.curOp) === null || _b === void 0 ? void 0 : _b.isVimOp)) {\n                    if (text === \"\\0\\0\") {\n                        return true;\n                    }\n                    CodeMirror.signal(cm, 'inputEvent', {\n                        type: \"text\",\n                        text,\n                        from,\n                        to,\n                    });\n                    if (text.length == 1 && vimPlugin.useNextTextInput) {\n                        if (vim.expectLiteralNext && view.composing) {\n                            vimPlugin.compositionText = text;\n                            return false;\n                        }\n                        if (vimPlugin.compositionText) {\n                            var toRemove = vimPlugin.compositionText;\n                            vimPlugin.compositionText = '';\n                            var head = view.state.selection.main.head;\n                            var textInDoc = view.state.sliceDoc(head - toRemove.length, head);\n                            if (toRemove === textInDoc) {\n                                var pos = cm.getCursor();\n                                cm.replaceRange('', cm.posFromIndex(head - toRemove.length), pos);\n                            }\n                        }\n                        vimPlugin.handleKey({\n                            key: text,\n                            preventDefault: () => { },\n                            stopPropagation: () => { }\n                        });\n                        forceEndComposition(view);\n                        return true;\n                    }\n                }\n                return false;\n            })\n        ];\n    },\n    decorations: (v) => v.decorations,\n});\n/**\n * removes contenteditable element and adds it back to end\n * IME composition in normal mode\n * this method works on all browsers except for Firefox on Linux\n * where we need to reset textContent of editor\n * (which doesn't work on other browsers)\n */\nfunction forceEndComposition(view) {\n    var parent = view.scrollDOM.parentElement;\n    if (!parent)\n        return;\n    if (FIREFOX_LINUX) {\n        view.contentDOM.textContent = \"\\0\\0\";\n        view.contentDOM.dispatchEvent(new CustomEvent(\"compositionend\"));\n        return;\n    }\n    var sibling = view.scrollDOM.nextSibling;\n    var selection = window.getSelection();\n    var savedSelection = selection && {\n        anchorNode: selection.anchorNode,\n        anchorOffset: selection.anchorOffset,\n        focusNode: selection.focusNode,\n        focusOffset: selection.focusOffset\n    };\n    view.scrollDOM.remove();\n    parent.insertBefore(view.scrollDOM, sibling);\n    try {\n        if (savedSelection && selection) {\n            selection.setPosition(savedSelection.anchorNode, savedSelection.anchorOffset);\n            if (savedSelection.focusNode) {\n                selection.extend(savedSelection.focusNode, savedSelection.focusOffset);\n            }\n        }\n    }\n    catch (e) {\n        console.error(e);\n    }\n    view.focus();\n    view.contentDOM.dispatchEvent(new CustomEvent(\"compositionend\"));\n}\nconst matchMark = /*@__PURE__*/_codemirror_view__WEBPACK_IMPORTED_MODULE_1__.Decoration.mark({ class: \"cm-searchMatch\" });\nconst showVimPanel = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.StateEffect.define();\nconst vimPanelState = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.StateField.define({\n    create: () => false,\n    update(value, tr) {\n        for (let e of tr.effects)\n            if (e.is(showVimPanel))\n                value = e.value;\n        return value;\n    },\n    provide: (f) => {\n        return _codemirror_view__WEBPACK_IMPORTED_MODULE_1__.showPanel.from(f, (on) => (on ? createVimPanel : null));\n    },\n});\nfunction createVimPanel(view) {\n    let dom = document.createElement(\"div\");\n    dom.className = \"cm-vim-panel\";\n    let cm = view.cm;\n    if (cm.state.dialog) {\n        dom.appendChild(cm.state.dialog);\n    }\n    return { top: false, dom };\n}\nfunction statusPanel(view) {\n    let dom = document.createElement(\"div\");\n    dom.className = \"cm-vim-panel\";\n    let cm = view.cm;\n    cm.state.statusbar = dom;\n    cm.state.vimPlugin.updateStatus();\n    return { dom };\n}\nfunction vim(options = {}) {\n    return [\n        vimStyle,\n        vimPlugin,\n        hideNativeSelection,\n        options.status ? _codemirror_view__WEBPACK_IMPORTED_MODULE_1__.showPanel.of(statusPanel) : vimPanelState,\n    ];\n}\nfunction getCM(view) {\n    return view.cm || null;\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcmVwbGl0L2NvZGVtaXJyb3ItdmltL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQTZHO0FBQ0Y7QUFDbEU7QUFDcUU7QUFDL0I7QUFDK0g7O0FBRTlNOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUVBQXFFLElBQUk7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsVUFBVSwwQ0FBMEM7QUFDcEQ7O0FBRUE7QUFDQSxjQUFjLG9DQUFvQztBQUNsRCxjQUFjLCtCQUErQjtBQUM3QyxjQUFjLHdCQUF3QjtBQUN0QyxjQUFjLDZCQUE2QjtBQUMzQyxjQUFjLHlCQUF5QjtBQUN2QyxjQUFjLCtCQUErQjtBQUM3QyxjQUFjLCtCQUErQjtBQUM3QyxjQUFjLGlDQUFpQztBQUMvQyxjQUFjLDJCQUEyQjtBQUN6QyxjQUFjLDJCQUEyQjtBQUN6QyxjQUFjLHdDQUF3QztBQUN0RCxjQUFjLHlDQUF5QztBQUN2RCxjQUFjLHNDQUFzQztBQUNwRDtBQUNBOztBQUVBLFlBQVksWUFBWSxTQUFTLEtBQUssZUFBZSxLQUFLO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFlBQVk7QUFDWjtBQUNBLGFBQWEsNkJBQTZCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBLE1BQU0sK0NBQStDO0FBQ3JELE1BQU0sZ0RBQWdEO0FBQ3RELE1BQU0sNkNBQTZDO0FBQ25ELE1BQU0sK0NBQStDO0FBQ3JELE1BQU0sK0NBQStDO0FBQ3JELE1BQU0saURBQWlEO0FBQ3ZELE1BQU0sZ0RBQWdEO0FBQ3RELE1BQU0s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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0Esc0JBQXNCLHVCQUF1QjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7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ckI7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQSxZQUFZLFFBQVEsWUFBWSw4QkFBOEI7QUFDOUQ7QUFDQTtBQUNBOztBQUVBLGFBQWEsOEJBQThCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxnQkFBZ0I7QUFDMUQsUUFBUTtBQUNSO0FBQ0E7QUFDQSwwQ0FBMEMsZUFBZTtBQUN6RDtBQUNBLEtBQUs7QUFDTDtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsZ0JBQWdCO0FBQzFELFFBQVE7QUFDUjtBQUNBO0FBQ0EsMENBQTBDLGVBQWU7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxpQkFBaUI7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLDBGQUEwRjtBQUNwSTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsMEZBQTBGO0FBQ3BJO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQ7QUFDdkQ7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxpQkFBaUI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQywyQkFBMkI7QUFDNUQsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsUUFBUTtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHNCQUFzQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsMEJBQTBCLHNCQUFzQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtDQUFrQztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFEO0FBQ3JEO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0Isd0RBQVUsUUFBUSx5QkFBeUI7QUFDMUUsa0NBQWtDLDBEQUFXO0FBQzdDLG1DQUFtQyx5REFBVTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxlQUFlLHVEQUFTO0FBQ3hCLEtBQUs7QUFDTCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsdURBQVM7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFdUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0ByZXBsaXQvY29kZW1pcnJvci12aW0vZGlzdC9pbmRleC5qcz9hNWJjIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEVkaXRvclNlbGVjdGlvbiwgTWFwTW9kZSwgUHJlYywgU3RhdGVFZmZlY3QsIFJhbmdlU2V0QnVpbGRlciwgU3RhdGVGaWVsZCB9IGZyb20gJ0Bjb2RlbWlycm9yL3N0YXRlJztcbmltcG9ydCB7IGZvbGRDb2RlLCBtYXRjaEJyYWNrZXRzLCBpbmRlbnRVbml0LCBlbnN1cmVTeW50YXhUcmVlLCBTdHJpbmdTdHJlYW0gfSBmcm9tICdAY29kZW1pcnJvci9sYW5ndWFnZSc7XG5pbXBvcnQgKiBhcyBWaWV3IGZyb20gJ0Bjb2RlbWlycm9yL3ZpZXcnO1xuaW1wb3J0IHsgRWRpdG9yVmlldywgcnVuU2NvcGVIYW5kbGVycywgRGlyZWN0aW9uLCBWaWV3UGx1Z2luLCBEZWNvcmF0aW9uLCBzaG93UGFuZWwgfSBmcm9tICdAY29kZW1pcnJvci92aWV3JztcbmltcG9ydCB7IFNlYXJjaFF1ZXJ5LCBzZXRTZWFyY2hRdWVyeSwgUmVnRXhwQ3Vyc29yIH0gZnJvbSAnQGNvZGVtaXJyb3Ivc2VhcmNoJztcbmltcG9ydCB7IGluZGVudE1vcmUsIGluZGVudExlc3MsIGN1cnNvckxpbmVCb3VuZGFyeUJhY2t3YXJkLCBjdXJzb3JMaW5lQm91bmRhcnlGb3J3YXJkLCBjdXJzb3JDaGFyQmFja3dhcmQsIGluZGVudFNlbGVjdGlvbiwgaW5zZXJ0TmV3bGluZUFuZEluZGVudCwgY3Vyc29yQ2hhckxlZnQsIHVuZG8sIHJlZG8gfSBmcm9tICdAY29kZW1pcnJvci9jb21tYW5kcyc7XG5cbi8vQHRzLWNoZWNrXG5cbi8vIENvZGVNaXJyb3IsIGNvcHlyaWdodCAoYykgYnkgTWFyaWpuIEhhdmVyYmVrZSBhbmQgb3RoZXJzXG4vLyBEaXN0cmlidXRlZCB1bmRlciBhbiBNSVQgbGljZW5zZTogaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC81L0xJQ0VOU0VcblxuLyoqXG4gKiBTdXBwb3J0ZWQga2V5YmluZGluZ3M6XG4gKiAgIFRvbyBtYW55IHRvIGxpc3QuIFJlZmVyIHRvIGRlZmF1bHRLZXltYXAgYmVsb3cuXG4gKlxuICogU3VwcG9ydGVkIEV4IGNvbW1hbmRzOlxuICogICBSZWZlciB0byBkZWZhdWx0RXhDb21tYW5kTWFwIGJlbG93LlxuICpcbiAqIFJlZ2lzdGVyczogdW5uYW1lZCwgLSwgLiwgOiwgLywgXywgYS16LCBBLVosIDAtOVxuICogICAoRG9lcyBub3QgcmVzcGVjdCB0aGUgc3BlY2lhbCBjYXNlIGZvciBudW1iZXIgcmVnaXN0ZXJzIHdoZW4gZGVsZXRlXG4gKiAgICBvcGVyYXRvciBpcyBtYWRlIHdpdGggdGhlc2UgY29tbWFuZHM6ICUsICgsICksICAsIC8sID8sIG4sIE4sIHssIH0gKVxuICogICBUT0RPOiBJbXBsZW1lbnQgdGhlIHJlbWFpbmluZyByZWdpc3RlcnMuXG4gKlxuICogTWFya3M6IGEteiwgQS1aLCBhbmQgMC05XG4gKiAgIFRPRE86IEltcGxlbWVudCB0aGUgcmVtYWluaW5nIHNwZWNpYWwgbWFya3MuIFRoZXkgaGF2ZSBtb3JlIGNvbXBsZXhcbiAqICAgICAgIGJlaGF2aW9yLlxuICpcbiAqIEV2ZW50czpcbiAqICAndmltLW1vZGUtY2hhbmdlJyAtIHJhaXNlZCBvbiB0aGUgZWRpdG9yIGFueXRpbWUgdGhlIGN1cnJlbnQgbW9kZSBjaGFuZ2VzLFxuICogICAgICAgICAgICAgICAgICAgICAgRXZlbnQgb2JqZWN0OiB7bW9kZTogXCJ2aXN1YWxcIiwgc3ViTW9kZTogXCJsaW5ld2lzZVwifVxuICpcbiAqIENvZGUgc3RydWN0dXJlOlxuICogIDEuIERlZmF1bHQga2V5bWFwXG4gKiAgMi4gVmFyaWFibGUgZGVjbGFyYXRpb25zIGFuZCBzaG9ydCBiYXNpYyBoZWxwZXJzXG4gKiAgMy4gSW5zdGFuY2UgKEV4dGVybmFsIEFQSSkgaW1wbGVtZW50YXRpb25cbiAqICA0LiBJbnRlcm5hbCBzdGF0ZSB0cmFja2luZyBvYmplY3RzIChpbnB1dCBzdGF0ZSwgY291bnRlcikgaW1wbGVtZW50YXRpb25cbiAqICAgICBhbmQgaW5zdGFudGlhdGlvblxuICogIDUuIEtleSBoYW5kbGVyICh0aGUgbWFpbiBjb21tYW5kIGRpc3BhdGNoZXIpIGltcGxlbWVudGF0aW9uXG4gKiAgNi4gTW90aW9uLCBvcGVyYXRvciwgYW5kIGFjdGlvbiBpbXBsZW1lbnRhdGlvbnNcbiAqICA3LiBIZWxwZXIgZnVuY3Rpb25zIGZvciB0aGUga2V5IGhhbmRsZXIsIG1vdGlvbnMsIG9wZXJhdG9ycywgYW5kIGFjdGlvbnNcbiAqICA4LiBTZXQgdXAgVmltIHRvIHdvcmsgYXMgYSBrZXltYXAgZm9yIENvZGVNaXJyb3IuXG4gKiAgOS4gRXggY29tbWFuZCBpbXBsZW1lbnRhdGlvbnMuXG4gKi9cblxuXG4vKiogQGFyZyB7dHlwZW9mIGltcG9ydChcIi4vY21fYWRhcHRlclwiKS5Db2RlTWlycm9yfSBDTSAqL1xuZnVuY3Rpb24gaW5pdFZpbShDTSkge1xuXG4vKipcbiAqIEB0eXBlZGVmIHsgaW1wb3J0KFwiLi9jbV9hZGFwdGVyXCIpLkNvZGVNaXJyb3IgfSBDb2RlTWlycm9yXG4gKiBAdHlwZWRlZiB7IGltcG9ydChcIi4vdHlwZXNcIikuQ29kZU1pcnJvclZ9IENvZGVNaXJyb3JWXG4gKiBAdHlwZWRlZiB7IGltcG9ydChcIi4vdHlwZXNcIikuUG9zIH0gUG9zXG4gKiBAdHlwZWRlZiB7IGltcG9ydChcIi4vdHlwZXNcIikudmltU3RhdGUgfSB2aW1TdGF0ZSBcbiAqIEB0eXBlZGVmIHsgaW1wb3J0KFwiLi90eXBlc1wiKS5FeEZuIH0gRXhGblxuICogQHR5cGVkZWYgeyBpbXBvcnQoXCIuL3R5cGVzXCIpLk1vdGlvbkFyZ3MgfSBNb3Rpb25BcmdzXG4gKiBAdHlwZWRlZiB7IGltcG9ydChcIi4vdHlwZXNcIikuQWN0aW9uQXJncyB9IEFjdGlvbkFyZ3NcbiAqIEB0eXBlZGVmIHsgaW1wb3J0KFwiLi90eXBlc1wiKS5PcGVyYXRvckFyZ3MgfSBPcGVyYXRvckFyZ3NcbiAqIEB0eXBlZGVmIHsgaW1wb3J0KFwiLi90eXBlc1wiKS52aW1LZXkgfSB2aW1LZXlcbiAqIEB0eXBlZGVmIHsgaW1wb3J0KFwiLi90eXBlc1wiKS5NYXJrZXIgfSBNYXJrZXJcbiAqIEB0eXBlZGVmIHsgaW1wb3J0KFwiLi90eXBlc1wiKS5JbnB1dFN0YXRlSW50ZXJmYWNlIH0gSW5wdXRTdGF0ZUludGVyZmFjZVxuICogQHR5cGVkZWYgeyBpbXBvcnQoXCIuL3R5cGVzXCIpLlNlYXJjaFN0YXRlSW50ZXJmYWNlIH0gU2VhcmNoU3RhdGVJbnRlcmZhY2VcbiAqIEB0eXBlZGVmIHsgaW1wb3J0KFwiLi90eXBlc1wiKS5JbnNlcnRNb2RlQ2hhbmdlcyB9IEluc2VydE1vZGVDaGFuZ2VzXG4gKi9cbiAgdmFyIFBvcyA9IENNLlBvcztcblxuICAvKiogQGFyZyB7Q29kZU1pcnJvcn0gY20gQGFyZyB7UG9zfSBjdXJTdGFydCBAYXJnIHtQb3N9IGN1ckVuZCAqL1xuICBmdW5jdGlvbiB1cGRhdGVTZWxlY3Rpb25Gb3JTdXJyb2dhdGVDaGFyYWN0ZXJzKGNtLCBjdXJTdGFydCwgY3VyRW5kKSB7XG4gICAgLy8gc3RhcnQgYW5kIGNoYXJhY3RlciBwb3NpdGlvbiB3aGVuIG5vIHNlbGVjdGlvbiBcbiAgICAvLyBpcyB0aGUgc2FtZSBpbiB2aXN1YWwgbW9kZSwgYW5kIGRpZmZlcnMgaW4gMSBjaGFyYWN0ZXIgaW4gbm9ybWFsIG1vZGVcbiAgICBpZiAoY3VyU3RhcnQubGluZSA9PT0gY3VyRW5kLmxpbmUgJiYgY3VyU3RhcnQuY2ggPj0gY3VyRW5kLmNoIC0gMSkge1xuICAgICAgdmFyIHRleHQgPSBjbS5nZXRMaW5lKGN1clN0YXJ0LmxpbmUpO1xuICAgICAgdmFyIGNoYXJDb2RlID0gdGV4dC5jaGFyQ29kZUF0KGN1clN0YXJ0LmNoKTtcbiAgICAgIGlmICgweEQ4MDAgPD0gY2hhckNvZGUgJiYgY2hhckNvZGUgPD0gMHhEOEZGKSB7XG4gICAgICAgIGN1ckVuZC5jaCArPSAxO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7c3RhcnQ6IGN1clN0YXJ0LCBlbmQ6IGN1ckVuZH07XG4gIH1cbiAgLyoqIEB0eXBlIHtpbXBvcnQoXCIuL3R5cGVzXCIpLnZpbUtleU1hcH0gKi9cbiAgdmFyIGRlZmF1bHRLZXltYXAgPSBbXG4gICAgLy8gS2V5IHRvIGtleSBtYXBwaW5nLiBUaGlzIGdvZXMgZmlyc3QgdG8gbWFrZSBpdCBwb3NzaWJsZSB0byBvdmVycmlkZVxuICAgIC8vIGV4aXN0aW5nIG1hcHBpbmdzLlxuICAgIHsga2V5czogJzxMZWZ0PicsIHR5cGU6ICdrZXlUb0tleScsIHRvS2V5czogJ2gnIH0sXG4gICAgeyBrZXlzOiAnPFJpZ2h0PicsIHR5cGU6ICdrZXlUb0tleScsIHRvS2V5czogJ2wnIH0sXG4gICAgeyBrZXlzOiAnPFVwPicsIHR5cGU6ICdrZXlUb0tleScsIHRvS2V5czogJ2snIH0sXG4gICAgeyBrZXlzOiAnPERvd24+JywgdHlwZTogJ2tleVRvS2V5JywgdG9LZXlzOiAnaicgfSxcbiAgICB7IGtleXM6ICdnPFVwPicsIHR5cGU6ICdrZXlUb0tleScsIHRvS2V5czogJ2drJyB9LFxuICAgIHsga2V5czogJ2c8RG93bj4nLCB0eXBlOiAna2V5VG9LZXknLCB0b0tleXM6ICdnaicgfSxcbiAgICB7IGtleXM6ICc8U3BhY2U+JywgdHlwZTogJ2tleVRvS2V5JywgdG9LZXlzOiAnbCcgfSxcbiAgICB7IGtleXM6ICc8QlM+JywgdHlwZTogJ2tleVRvS2V5JywgdG9LZXlzOiAnaCd9LFxuICAgIHsga2V5czogJzxEZWw+JywgdHlwZTogJ2tleVRvS2V5JywgdG9LZXlzOiAneCcgfSxcbiAgICB7IGtleXM6ICc8Qy1TcGFjZT4nLCB0eXBlOiAna2V5VG9LZXknLCB0b0tleXM6ICdXJyB9LFxuICAgIHsga2V5czogJzxDLUJTPicsIHR5cGU6ICdrZXlUb0tleScsIHRvS2V5czogJ0InIH0sXG4gICAgeyBrZXlzOiAnPFMtU3BhY2U+JywgdHlwZTogJ2tleVRvS2V5JywgdG9LZXlzOiAndycgfSxcbiAgICB7IGtleXM6ICc8Uy1CUz4nLCB0eXBlOiAna2V5VG9LZXknLCB0b0tleXM6ICdiJyB9LFxuICAgIHsga2V5czogJzxDLW4+JywgdHlwZTogJ2tleVRvS2V5JywgdG9LZXlzOiAnaicgfSxcbiAgICB7IGtleXM6ICc8Qy1wPicsIHR5cGU6ICdrZXlUb0tleScsIHRvS2V5czogJ2snIH0sXG4gICAgeyBrZXlzOiAnPEMtWz4nLCB0eXBlOiAna2V5VG9LZXknLCB0b0tleXM6ICc8RXNjPicgfSxcbiAgICB7IGtleXM6ICc8Qy1jPicsIHR5cGU6ICdrZXlUb0tleScsIHRvS2V5czogJzxFc2M+JyB9LFxuICAgIHsga2V5czogJzxDLVs+JywgdHlwZTogJ2tleVRvS2V5JywgdG9LZXlzOiAnPEVzYz4nLCBjb250ZXh0OiAnaW5zZXJ0JyB9LFxuICAgIHsga2V5czogJzxDLWM+JywgdHlwZTogJ2tleVRvS2V5JywgdG9LZXlzOiAnPEVzYz4nLCBjb250ZXh0OiAnaW5zZXJ0JyB9LFxuICAgIHsga2V5czogJzxDLUVzYz4nLCB0eXBlOiAna2V5VG9LZXknLCB0b0tleXM6ICc8RXNjPicgfSwgLy8gaXBhZCBrZXlib2FyZCBzZW5kcyBDLUVzYyBpbnN0ZWFkIG9mIEMtW1xuICAgIHsga2V5czogJzxDLUVzYz4nLCB0eXBlOiAna2V5VG9LZXknLCB0b0tleXM6ICc8RXNjPicsIGNvbnRleHQ6ICdpbnNlcnQnIH0sXG4gICAgeyBrZXlzOiAncycsIHR5cGU6ICdrZXlUb0tleScsIHRvS2V5czogJ2NsJywgY29udGV4dDogJ25vcm1hbCcgfSxcbiAgICB7IGtleXM6ICdzJywgdHlwZTogJ2tleVRvS2V5JywgdG9LZXlzOiAnYycsIGNvbnRleHQ6ICd2aXN1YWwnfSxcbiAgICB7IGtleXM6ICdTJywgdHlwZTogJ2tleVRvS2V5JywgdG9LZXlzOiAnY2MnLCBjb250ZXh0OiAnbm9ybWFsJyB9LFxuICAgIHsga2V5czogJ1MnLCB0eXBlOiAna2V5VG9LZXknLCB0b0tleXM6ICdWZE8nLCBjb250ZXh0OiAndmlzdWFsJyB9LFxuICAgIHsga2V5czogJzxIb21lPicsIHR5cGU6ICdrZXlUb0tleScsIHRvS2V5czogJzAnIH0sXG4gICAgeyBrZXlzOiAnPEVuZD4nLCB0eXBlOiAna2V5VG9LZXknLCB0b0tleXM6ICckJyB9LFxuICAgIHsga2V5czogJzxQYWdlVXA+JywgdHlwZTogJ2tleVRvS2V5JywgdG9LZXlzOiAnPEMtYj4nIH0sXG4gICAgeyBrZXlzOiAnPFBhZ2VEb3duPicsIHR5cGU6ICdrZXlUb0tleScsIHRvS2V5czogJzxDLWY+JyB9LFxuICAgIHsga2V5czogJzxDUj4nLCB0eXBlOiAna2V5VG9LZXknLCB0b0tleXM6ICdqXicsIGNvbnRleHQ6ICdub3JtYWwnIH0sXG4gICAgeyBrZXlzOiAnPElucz4nLCB0eXBlOiAna2V5VG9LZXknLCB0b0tleXM6ICdpJywgY29udGV4dDogJ25vcm1hbCd9LFxuICAgIHsga2V5czogJzxJbnM+JywgdHlwZTogJ2FjdGlvbicsIGFjdGlvbjogJ3RvZ2dsZU92ZXJ3cml0ZScsIGNvbnRleHQ6ICdpbnNlcnQnIH0sXG4gICAgLy8gTW90aW9uc1xuICAgIHsga2V5czogJ0gnLCB0eXBlOiAnbW90aW9uJywgbW90aW9uOiAnbW92ZVRvVG9wTGluZScsIG1vdGlvbkFyZ3M6IHsgbGluZXdpc2U6IHRydWUsIHRvSnVtcGxpc3Q6IHRydWUgfX0sXG4gICAgeyBrZXlzOiAnTScsIHR5cGU6ICdtb3Rpb24nLCBtb3Rpb246ICdtb3ZlVG9NaWRkbGVMaW5lJywgbW90aW9uQXJnczogeyBsaW5ld2lzZTogdHJ1ZSwgdG9KdW1wbGlzdDogdHJ1ZSB9fSxcbiAgICB7IGtleXM6ICdMJywgdHlwZTogJ21vdGlvbicsIG1vdGlvbjogJ21vdmVUb0JvdHRvbUxpbmUnLCBtb3Rpb25BcmdzOiB7IGxpbmV3aXNlOiB0cnVlLCB0b0p1bXBsaXN0OiB0cnVlIH19LFxuICAgIHsga2V5czogJ2gnLCB0eXBlOiAnbW90aW9uJywgbW90aW9uOiAnbW92ZUJ5Q2hhcmFjdGVycycsIG1vdGlvbkFyZ3M6IHsgZm9yd2FyZDogZmFsc2UgfX0sXG4gICAgeyBrZXlzOiAnbCcsIHR5cGU6ICdtb3Rpb24nLCBtb3Rpb246ICdtb3ZlQnlDaGFyYWN0ZXJzJywgbW90aW9uQXJnczogeyBmb3J3YXJkOiB0cnVlIH19LFxuICAgIHsga2V5czogJ2onLCB0eXBlOiAnbW90aW9uJywgbW90aW9uOiAnbW92ZUJ5TGluZXMnLCBtb3Rpb25BcmdzOiB7IGZvcndhcmQ6IHRydWUsIGxpbmV3aXNlOiB0cnVlIH19LFxuICAgIHsga2V5czogJ2snLCB0eXBlOiAnbW90aW9uJywgbW90aW9uOiAnbW92ZUJ5TGluZXMnLCBtb3Rpb25BcmdzOiB7IGZvcndhcmQ6IGZhbHNlLCBsaW5ld2lzZTogdHJ1ZSB9fSxcbiAgICB7IGtleXM6ICdnaicsIHR5cGU6ICdtb3Rpb24nLCBtb3Rpb246ICdtb3ZlQnlEaXNwbGF5TGluZXMnLCBtb3Rpb25BcmdzOiB7IGZvcndhcmQ6IHRydWUgfX0sXG4gICAgeyBrZXlzOiAnZ2snLCB0eXBlOiAnbW90aW9uJywgbW90aW9uOiAnbW92ZUJ5RGlzcGxheUxpbmVzJywgbW90aW9uQXJnczogeyBmb3J3YXJkOiBmYWxzZSB9fSxcbiAgICB7IGtleXM6ICd3JywgdHlwZTogJ21vdGlvbicsIG1vdGlvbjogJ21vdmVCeVdvcmRzJywgbW90aW9uQXJnczogeyBmb3J3YXJkOiB0cnVlLCB3b3JkRW5kOiBmYWxzZSB9fSxcbiAgICB7IGtleXM6ICdXJywgdHlwZTogJ21vdGlvbicsIG1vdGlvbjogJ21vdmVCeVdvcmRzJywgbW90aW9uQXJnczogeyBmb3J3YXJkOiB0cnVlLCB3b3JkRW5kOiBmYWxzZSwgYmlnV29yZDogdHJ1ZSB9fSxcbiAgICB7IGtleXM6ICdlJywgdHlwZTogJ21vdGlvbicsIG1vdGlvbjogJ21vdmVCeVdvcmRzJywgbW90aW9uQXJnczogeyBmb3J3YXJkOiB0cnVlLCB3b3JkRW5kOiB0cnVlLCBpbmNsdXNpdmU6IHRydWUgfX0sXG4gICAgeyBrZXlzOiAnRScsIHR5cGU6ICdtb3Rpb24nLCBtb3Rpb246ICdtb3ZlQnlXb3JkcycsIG1vdGlvbkFyZ3M6IHsgZm9yd2FyZDogdHJ1ZSwgd29yZEVuZDogdHJ1ZSwgYmlnV29yZDogdHJ1ZSwgaW5jbHVzaXZlOiB0cnVlIH19LFxuICAgIHsga2V5czogJ2InLCB0eXBlOiAnbW90aW9uJywgbW90aW9uOiAnbW92ZUJ5V29yZHMnLCBtb3Rpb25BcmdzOiB7IGZvcndhcmQ6IGZhbHNlLCB3b3JkRW5kOiBmYWxzZSB9fSxcbiAgICB7IGtleXM6ICdCJywgdHlwZTogJ21vdGlvbicsIG1vdGlvbjogJ21vdmVCeVdvcmRzJywgbW90aW9uQXJnczogeyBmb3J3YXJkOiBmYWxzZSwgd29yZEVuZDogZmFsc2UsIGJpZ1dvcmQ6IHRydWUgfX0sXG4gICAgeyBrZXlzOiAnZ2UnLCB0eXBlOiAnbW90aW9uJywgbW90aW9uOiAnbW92ZUJ5V29yZHMnLCBtb3Rpb25BcmdzOiB7IGZvcndhcmQ6IGZhbHNlLCB3b3JkRW5kOiB0cnVlLCBpbmNsdXNpdmU6IHRydWUgfX0sXG4gICAgeyBrZXlzOiAnZ0UnLCB0eXBlOiAnbW90aW9uJywgbW90aW9uOiAnbW92ZUJ5V29yZHMnLCBtb3Rpb25BcmdzOiB7IGZvcndhcmQ6IGZhbHNlLCB3b3JkRW5kOiB0cnVlLCBiaWdXb3JkOiB0cnVlLCBpbmNsdXNpdmU6IHRydWUgfX0sXG4gICAgeyBrZXlzOiAneycsIHR5cGU6ICdtb3Rpb24nLCBtb3Rpb246ICdtb3ZlQnlQYXJhZ3JhcGgnLCBtb3Rpb25BcmdzOiB7IGZvcndhcmQ6IGZhbHNlLCB0b0p1bXBsaXN0OiB0cnVlIH19LFxuICAgIHsga2V5czogJ30nLCB0eXBlOiAnbW90aW9uJywgbW90aW9uOiAnbW92ZUJ5UGFyYWdyYXBoJywgbW90aW9uQXJnczogeyBmb3J3YXJkOiB0cnVlLCB0b0p1bXBsaXN0OiB0cnVlIH19LFxuICAgIHsga2V5czogJygnLCB0eXBlOiAnbW90aW9uJywgbW90aW9uOiAnbW92ZUJ5U2VudGVuY2UnLCBtb3Rpb25BcmdzOiB7IGZvcndhcmQ6IGZhbHNlIH19LFxuICAgIHsga2V5czogJyknLCB0eXBlOiAnbW90aW9uJywgbW90aW9uOiAnbW92ZUJ5U2VudGVuY2UnLCBtb3Rpb25BcmdzOiB7IGZvcndhcmQ6IHRydWUgfX0sXG4gICAgeyBrZXlzOiAnPEMtZj4nLCB0eXBlOiAnbW90aW9uJywgbW90aW9uOiAnbW92ZUJ5UGFnZScsIG1vdGlvbkFyZ3M6IHsgZm9yd2FyZDogdHJ1ZSB9fSxcbiAgICB7IGtleXM6ICc8Qy1iPicsIHR5cGU6ICdtb3Rpb24nLCBtb3Rpb246ICdtb3ZlQnlQYWdlJywgbW90aW9uQXJnczogeyBmb3J3YXJkOiBmYWxzZSB9fSxcbiAgICB7IGtleXM6ICc8Qy1kPicsIHR5cGU6ICdtb3Rpb24nLCBtb3Rpb246ICdtb3ZlQnlTY3JvbGwnLCBtb3Rpb25BcmdzOiB7IGZvcndhcmQ6IHRydWUsIGV4cGxpY2l0UmVwZWF0OiB0cnVlIH19LFxuICAgIHsga2V5czogJzxDLXU+JywgdHlwZTogJ21vdGlvbicsIG1vdGlvbjogJ21vdmVCeVNjcm9sbCcsIG1vdGlvbkFyZ3M6IHsgZm9yd2FyZDogZmFsc2UsIGV4cGxpY2l0UmVwZWF0OiB0cnVlIH19LFxuICAgIHsga2V5czogJ2dnJywgdHlwZTogJ21vdGlvbicsIG1vdGlvbjogJ21vdmVUb0xpbmVPckVkZ2VPZkRvY3VtZW50JywgbW90aW9uQXJnczogeyBmb3J3YXJkOiBmYWxzZSwgZXhwbGljaXRSZXBlYXQ6IHRydWUsIGxpbmV3aXNlOiB0cnVlLCB0b0p1bXBsaXN0OiB0cnVlIH19LFxuICAgIHsga2V5czogJ0cnLCB0eXBlOiAnbW90aW9uJywgbW90aW9uOiAnbW92ZVRvTGluZU9yRWRnZU9mRG9jdW1lbnQnLCBtb3Rpb25BcmdzOiB7IGZvcndhcmQ6IHRydWUsIGV4cGxpY2l0UmVwZWF0OiB0cnVlLCBsaW5ld2lzZTogdHJ1ZSwgdG9KdW1wbGlzdDogdHJ1ZSB9fSxcbiAgICB7IGtleXM6IFwiZyRcIiwgdHlwZTogXCJtb3Rpb25cIiwgbW90aW9uOiBcIm1vdmVUb0VuZE9mRGlzcGxheUxpbmVcIiB9LFxuICAgIHsga2V5czogXCJnXlwiLCB0eXBlOiBcIm1vdGlvblwiLCBtb3Rpb246IFwibW92ZVRvU3RhcnRPZkRpc3BsYXlMaW5lXCIgfSxcbiAgICB7IGtleXM6IFwiZzBcIiwgdHlwZTogXCJtb3Rpb25cIiwgbW90aW9uOiBcIm1vdmVUb1N0YXJ0T2ZEaXNwbGF5TGluZVwiIH0sXG4gICAgeyBrZXlzOiAnMCcsIHR5cGU6ICdtb3Rpb24nLCBtb3Rpb246ICdtb3ZlVG9TdGFydE9mTGluZScgfSxcbiAgICB7IGtleXM6ICdeJywgdHlwZTogJ21vdGlvbicsIG1vdGlvbjogJ21vdmVUb0ZpcnN0Tm9uV2hpdGVTcGFjZUNoYXJhY3RlcicgfSxcbiAgICB7IGtleXM6ICcrJywgdHlwZTogJ21vdGlvbicsIG1vdGlvbjogJ21vdmVCeUxpbmVzJywgbW90aW9uQXJnczogeyBmb3J3YXJkOiB0cnVlLCB0b0ZpcnN0Q2hhcjp0cnVlIH19LFxuICAgIHsga2V5czogJy0nLCB0eXBlOiAnbW90aW9uJywgbW90aW9uOiAnbW92ZUJ5TGluZXMnLCBtb3Rpb25BcmdzOiB7IGZvcndhcmQ6IGZhbHNlLCB0b0ZpcnN0Q2hhcjp0cnVlIH19LFxuICAgIHsga2V5czogJ18nLCB0eXBlOiAnbW90aW9uJywgbW90aW9uOiAnbW92ZUJ5TGluZXMnLCBtb3Rpb25BcmdzOiB7IGZvcndhcmQ6IHRydWUsIHRvRmlyc3RDaGFyOnRydWUsIHJlcGVhdE9mZnNldDotMSB9fSxcbiAgICB7IGtleXM6ICckJywgdHlwZTogJ21vdGlvbicsIG1vdGlvbjogJ21vdmVUb0VvbCcsIG1vdGlvbkFyZ3M6IHsgaW5jbHVzaXZlOiB0cnVlIH19LFxuICAgIHsga2V5czogJyUnLCB0eXBlOiAnbW90aW9uJywgbW90aW9uOiAnbW92ZVRvTWF0Y2hlZFN5bWJvbCcsIG1vdGlvbkFyZ3M6IHsgaW5jbHVzaXZlOiB0cnVlLCB0b0p1bXBsaXN0OiB0cnVlIH19LFxuICAgIHsga2V5czogJ2Y8Y2hhcmFjdGVyPicsIHR5cGU6ICdtb3Rpb24nLCBtb3Rpb246ICdtb3ZlVG9DaGFyYWN0ZXInLCBtb3Rpb25BcmdzOiB7IGZvcndhcmQ6IHRydWUgLCBpbmNsdXNpdmU6IHRydWUgfX0sXG4gICAgeyBrZXlzOiAnRjxjaGFyYWN0ZXI+JywgdHlwZTogJ21vdGlvbicsIG1vdGlvbjogJ21vdmVUb0NoYXJhY3RlcicsIG1vdGlvbkFyZ3M6IHsgZm9yd2FyZDogZmFsc2UgfX0sXG4gICAgeyBrZXlzOiAndDxjaGFyYWN0ZXI+JywgdHlwZTogJ21vdGlvbicsIG1vdGlvbjogJ21vdmVUaWxsQ2hhcmFjdGVyJywgbW90aW9uQXJnczogeyBmb3J3YXJkOiB0cnVlLCBpbmNsdXNpdmU6IHRydWUgfX0sXG4gICAgeyBrZXlzOiAnVDxjaGFyYWN0ZXI+JywgdHlwZTogJ21vdGlvbicsIG1vdGlvbjogJ21vdmVUaWxsQ2hhcmFjdGVyJywgbW90aW9uQXJnczogeyBmb3J3YXJkOiBmYWxzZSB9fSxcbiAgICB7IGtleXM6ICc7JywgdHlwZTogJ21vdGlvbicsIG1vdGlvbjogJ3JlcGVhdExhc3RDaGFyYWN0ZXJTZWFyY2gnLCBtb3Rpb25BcmdzOiB7IGZvcndhcmQ6IHRydWUgfX0sXG4gICAgeyBrZXlzOiAnLCcsIHR5cGU6ICdtb3Rpb24nLCBtb3Rpb246ICdyZXBlYXRMYXN0Q2hhcmFjdGVyU2VhcmNoJywgbW90aW9uQXJnczogeyBmb3J3YXJkOiBmYWxzZSB9fSxcbiAgICB7IGtleXM6ICdcXCc8cmVnaXN0ZXI+JywgdHlwZTogJ21vdGlvbicsIG1vdGlvbjogJ2dvVG9NYXJrJywgbW90aW9uQXJnczoge3RvSnVtcGxpc3Q6IHRydWUsIGxpbmV3aXNlOiB0cnVlfX0sXG4gICAgeyBrZXlzOiAnYDxyZWdpc3Rlcj4nLCB0eXBlOiAnbW90aW9uJywgbW90aW9uOiAnZ29Ub01hcmsnLCBtb3Rpb25BcmdzOiB7dG9KdW1wbGlzdDogdHJ1ZX19LFxuICAgIHsga2V5czogJ11gJywgdHlwZTogJ21vdGlvbicsIG1vdGlvbjogJ2p1bXBUb01hcmsnLCBtb3Rpb25BcmdzOiB7IGZvcndhcmQ6IHRydWUgfSB9LFxuICAgIHsga2V5czogJ1tgJywgdHlwZTogJ21vdGlvbicsIG1vdGlvbjogJ2p1bXBUb01hcmsnLCBtb3Rpb25BcmdzOiB7IGZvcndhcmQ6IGZhbHNlIH0gfSxcbiAgICB7IGtleXM6ICddXFwnJywgdHlwZTogJ21vdGlvbicsIG1vdGlvbjogJ2p1bXBUb01hcmsnLCBtb3Rpb25BcmdzOiB7IGZvcndhcmQ6IHRydWUsIGxpbmV3aXNlOiB0cnVlIH0gfSxcbiAgICB7IGtleXM6ICdbXFwnJywgdHlwZTogJ21vdGlvbicsIG1vdGlvbjogJ2p1bXBUb01hcmsnLCBtb3Rpb25BcmdzOiB7IGZvcndhcmQ6IGZhbHNlLCBsaW5ld2lzZTogdHJ1ZSB9IH0sXG4gICAgLy8gdGhlIG5leHQgdHdvIGFyZW4ndCBtb3Rpb25zIGJ1dCBtdXN0IGNvbWUgYmVmb3JlIG1vcmUgZ2VuZXJhbCBtb3Rpb24gZGVjbGFyYXRpb25zXG4gICAgeyBrZXlzOiAnXXAnLCB0eXBlOiAnYWN0aW9uJywgYWN0aW9uOiAncGFzdGUnLCBpc0VkaXQ6IHRydWUsIGFjdGlvbkFyZ3M6IHsgYWZ0ZXI6IHRydWUsIGlzRWRpdDogdHJ1ZSwgbWF0Y2hJbmRlbnQ6IHRydWV9fSxcbiAgICB7IGtleXM6ICdbcCcsIHR5cGU6ICdhY3Rpb24nLCBhY3Rpb246ICdwYXN0ZScsIGlzRWRpdDogdHJ1ZSwgYWN0aW9uQXJnczogeyBhZnRlcjogZmFsc2UsIGlzRWRpdDogdHJ1ZSwgbWF0Y2hJbmRlbnQ6IHRydWV9fSxcbiAgICB7IGtleXM6ICddPGNoYXJhY3Rlcj4nLCB0eXBlOiAnbW90aW9uJywgbW90aW9uOiAnbW92ZVRvU3ltYm9sJywgbW90aW9uQXJnczogeyBmb3J3YXJkOiB0cnVlLCB0b0p1bXBsaXN0OiB0cnVlfX0sXG4gICAgeyBrZXlzOiAnWzxjaGFyYWN0ZXI+JywgdHlwZTogJ21vdGlvbicsIG1vdGlvbjogJ21vdmVUb1N5bWJvbCcsIG1vdGlvbkFyZ3M6IHsgZm9yd2FyZDogZmFsc2UsIHRvSnVtcGxpc3Q6IHRydWV9fSxcbiAgICB7IGtleXM6ICd8JywgdHlwZTogJ21vdGlvbicsIG1vdGlvbjogJ21vdmVUb0NvbHVtbid9LFxuICAgIHsga2V5czogJ28nLCB0eXBlOiAnbW90aW9uJywgbW90aW9uOiAnbW92ZVRvT3RoZXJIaWdobGlnaHRlZEVuZCcsIGNvbnRleHQ6J3Zpc3VhbCd9LFxuICAgIHsga2V5czogJ08nLCB0eXBlOiAnbW90aW9uJywgbW90aW9uOiAnbW92ZVRvT3RoZXJIaWdobGlnaHRlZEVuZCcsIG1vdGlvbkFyZ3M6IHtzYW1lTGluZTogdHJ1ZX0sIGNvbnRleHQ6J3Zpc3VhbCd9LFxuICAgIC8vIE9wZXJhdG9yc1xuICAgIHsga2V5czogJ2QnLCB0eXBlOiAnb3BlcmF0b3InLCBvcGVyYXRvcjogJ2RlbGV0ZScgfSxcbiAgICB7IGtleXM6ICd5JywgdHlwZTogJ29wZXJhdG9yJywgb3BlcmF0b3I6ICd5YW5rJyB9LFxuICAgIHsga2V5czogJ2MnLCB0eXBlOiAnb3BlcmF0b3InLCBvcGVyYXRvcjogJ2NoYW5nZScgfSxcbiAgICB7IGtleXM6ICc9JywgdHlwZTogJ29wZXJhdG9yJywgb3BlcmF0b3I6ICdpbmRlbnRBdXRvJyB9LFxuICAgIHsga2V5czogJz4nLCB0eXBlOiAnb3BlcmF0b3InLCBvcGVyYXRvcjogJ2luZGVudCcsIG9wZXJhdG9yQXJnczogeyBpbmRlbnRSaWdodDogdHJ1ZSB9fSxcbiAgICB7IGtleXM6ICc8JywgdHlwZTogJ29wZXJhdG9yJywgb3BlcmF0b3I6ICdpbmRlbnQnLCBvcGVyYXRvckFyZ3M6IHsgaW5kZW50UmlnaHQ6IGZhbHNlIH19LFxuICAgIHsga2V5czogJ2d+JywgdHlwZTogJ29wZXJhdG9yJywgb3BlcmF0b3I6ICdjaGFuZ2VDYXNlJyB9LFxuICAgIHsga2V5czogJ2d1JywgdHlwZTogJ29wZXJhdG9yJywgb3BlcmF0b3I6ICdjaGFuZ2VDYXNlJywgb3BlcmF0b3JBcmdzOiB7dG9Mb3dlcjogdHJ1ZX0sIGlzRWRpdDogdHJ1ZSB9LFxuICAgIHsga2V5czogJ2dVJywgdHlwZTogJ29wZXJhdG9yJywgb3BlcmF0b3I6ICdjaGFuZ2VDYXNlJywgb3BlcmF0b3JBcmdzOiB7dG9Mb3dlcjogZmFsc2V9LCBpc0VkaXQ6IHRydWUgfSxcbiAgICB7IGtleXM6ICduJywgdHlwZTogJ21vdGlvbicsIG1vdGlvbjogJ2ZpbmROZXh0JywgbW90aW9uQXJnczogeyBmb3J3YXJkOiB0cnVlLCB0b0p1bXBsaXN0OiB0cnVlIH19LFxuICAgIHsga2V5czogJ04nLCB0eXBlOiAnbW90aW9uJywgbW90aW9uOiAnZmluZE5leHQnLCBtb3Rpb25BcmdzOiB7IGZvcndhcmQ6IGZhbHNlLCB0b0p1bXBsaXN0OiB0cnVlIH19LFxuICAgIHsga2V5czogJ2duJywgdHlwZTogJ21vdGlvbicsIG1vdGlvbjogJ2ZpbmRBbmRTZWxlY3ROZXh0SW5jbHVzaXZlJywgbW90aW9uQXJnczogeyBmb3J3YXJkOiB0cnVlIH19LFxuICAgIHsga2V5czogJ2dOJywgdHlwZTogJ21vdGlvbicsIG1vdGlvbjogJ2ZpbmRBbmRTZWxlY3ROZXh0SW5jbHVzaXZlJywgbW90aW9uQXJnczogeyBmb3J3YXJkOiBmYWxzZSB9fSxcbiAgICB7IGtleXM6ICdncScsIHR5cGU6ICdvcGVyYXRvcicsIG9wZXJhdG9yOiAnaGFyZFdyYXAnIH0sXG4gICAgeyBrZXlzOiAnZ3cnLCB0eXBlOiAnb3BlcmF0b3InLCBvcGVyYXRvcjogJ2hhcmRXcmFwJywgb3BlcmF0b3JBcmdzOiB7a2VlcEN1cnNvcjogdHJ1ZX19LFxuICAgIHsga2V5czogJ2c/JywgdHlwZTogJ29wZXJhdG9yJywgb3BlcmF0b3I6ICdyb3QxMyd9LFxuICAgIC8vIE9wZXJhdG9yLU1vdGlvbiBkdWFsIGNvbW1hbmRzXG4gICAgeyBrZXlzOiAneCcsIHR5cGU6ICdvcGVyYXRvck1vdGlvbicsIG9wZXJhdG9yOiAnZGVsZXRlJywgbW90aW9uOiAnbW92ZUJ5Q2hhcmFjdGVycycsIG1vdGlvbkFyZ3M6IHsgZm9yd2FyZDogdHJ1ZSB9LCBvcGVyYXRvck1vdGlvbkFyZ3M6IHsgdmlzdWFsTGluZTogZmFsc2UgfX0sXG4gICAgeyBrZXlzOiAnWCcsIHR5cGU6ICdvcGVyYXRvck1vdGlvbicsIG9wZXJhdG9yOiAnZGVsZXRlJywgbW90aW9uOiAnbW92ZUJ5Q2hhcmFjdGVycycsIG1vdGlvbkFyZ3M6IHsgZm9yd2FyZDogZmFsc2UgfSwgb3BlcmF0b3JNb3Rpb25BcmdzOiB7IHZpc3VhbExpbmU6IHRydWUgfX0sXG4gICAgeyBrZXlzOiAnRCcsIHR5cGU6ICdvcGVyYXRvck1vdGlvbicsIG9wZXJhdG9yOiAnZGVsZXRlJywgbW90aW9uOiAnbW92ZVRvRW9sJywgbW90aW9uQXJnczogeyBpbmNsdXNpdmU6IHRydWUgfSwgY29udGV4dDogJ25vcm1hbCd9LFxuICAgIHsga2V5czogJ0QnLCB0eXBlOiAnb3BlcmF0b3InLCBvcGVyYXRvcjogJ2RlbGV0ZScsIG9wZXJhdG9yQXJnczogeyBsaW5ld2lzZTogdHJ1ZSB9LCBjb250ZXh0OiAndmlzdWFsJ30sXG4gICAgeyBrZXlzOiAnWScsIHR5cGU6ICdvcGVyYXRvck1vdGlvbicsIG9wZXJhdG9yOiAneWFuaycsIG1vdGlvbjogJ2V4cGFuZFRvTGluZScsIG1vdGlvbkFyZ3M6IHsgbGluZXdpc2U6IHRydWUgfSwgY29udGV4dDogJ25vcm1hbCd9LFxuICAgIHsga2V5czogJ1knLCB0eXBlOiAnb3BlcmF0b3InLCBvcGVyYXRvcjogJ3lhbmsnLCBvcGVyYXRvckFyZ3M6IHsgbGluZXdpc2U6IHRydWUgfSwgY29udGV4dDogJ3Zpc3VhbCd9LFxuICAgIHsga2V5czogJ0MnLCB0eXBlOiAnb3BlcmF0b3JNb3Rpb24nLCBvcGVyYXRvcjogJ2NoYW5nZScsIG1vdGlvbjogJ21vdmVUb0VvbCcsIG1vdGlvbkFyZ3M6IHsgaW5jbHVzaXZlOiB0cnVlIH0sIGNvbnRleHQ6ICdub3JtYWwnfSxcbiAgICB7IGtleXM6ICdDJywgdHlwZTogJ29wZXJhdG9yJywgb3BlcmF0b3I6ICdjaGFuZ2UnLCBvcGVyYXRvckFyZ3M6IHsgbGluZXdpc2U6IHRydWUgfSwgY29udGV4dDogJ3Zpc3VhbCd9LFxuICAgIHsga2V5czogJ34nLCB0eXBlOiAnb3BlcmF0b3JNb3Rpb24nLCBvcGVyYXRvcjogJ2NoYW5nZUNhc2UnLCBtb3Rpb246ICdtb3ZlQnlDaGFyYWN0ZXJzJywgbW90aW9uQXJnczogeyBmb3J3YXJkOiB0cnVlIH0sIG9wZXJhdG9yQXJnczogeyBzaG91bGRNb3ZlQ3Vyc29yOiB0cnVlIH0sIGNvbnRleHQ6ICdub3JtYWwnfSxcbiAgICB7IGtleXM6ICd+JywgdHlwZTogJ29wZXJhdG9yJywgb3BlcmF0b3I6ICdjaGFuZ2VDYXNlJywgY29udGV4dDogJ3Zpc3VhbCd9LFxuICAgIHsga2V5czogJzxDLXU+JywgdHlwZTogJ29wZXJhdG9yTW90aW9uJywgb3BlcmF0b3I6ICdkZWxldGUnLCBtb3Rpb246ICdtb3ZlVG9TdGFydE9mTGluZScsIGNvbnRleHQ6ICdpbnNlcnQnIH0sXG4gICAgeyBrZXlzOiAnPEMtdz4nLCB0eXBlOiAnb3BlcmF0b3JNb3Rpb24nLCBvcGVyYXRvcjogJ2RlbGV0ZScsIG1vdGlvbjogJ21vdmVCeVdvcmRzJywgbW90aW9uQXJnczogeyBmb3J3YXJkOiBmYWxzZSwgd29yZEVuZDogZmFsc2UgfSwgY29udGV4dDogJ2luc2VydCcgfSxcbiAgICAvL2lnbm9yZSBDLXcgaW4gbm9ybWFsIG1vZGVcbiAgICB7IGtleXM6ICc8Qy13PicsIHR5cGU6ICdpZGxlJywgY29udGV4dDogJ25vcm1hbCcgfSxcbiAgICAvLyBBY3Rpb25zXG4gICAgeyBrZXlzOiAnPEMtaT4nLCB0eXBlOiAnYWN0aW9uJywgYWN0aW9uOiAnanVtcExpc3RXYWxrJywgYWN0aW9uQXJnczogeyBmb3J3YXJkOiB0cnVlIH19LFxuICAgIHsga2V5czogJzxDLW8+JywgdHlwZTogJ2FjdGlvbicsIGFjdGlvbjogJ2p1bXBMaXN0V2FsaycsIGFjdGlvbkFyZ3M6IHsgZm9yd2FyZDogZmFsc2UgfX0sXG4gICAgeyBrZXlzOiAnPEMtZT4nLCB0eXBlOiAnYWN0aW9uJywgYWN0aW9uOiAnc2Nyb2xsJywgYWN0aW9uQXJnczogeyBmb3J3YXJkOiB0cnVlLCBsaW5ld2lzZTogdHJ1ZSB9fSxcbiAgICB7IGtleXM6ICc8Qy15PicsIHR5cGU6ICdhY3Rpb24nLCBhY3Rpb246ICdzY3JvbGwnLCBhY3Rpb25BcmdzOiB7IGZvcndhcmQ6IGZhbHNlLCBsaW5ld2lzZTogdHJ1ZSB9fSxcbiAgICB7IGtleXM6ICdhJywgdHlwZTogJ2FjdGlvbicsIGFjdGlvbjogJ2VudGVySW5zZXJ0TW9kZScsIGlzRWRpdDogdHJ1ZSwgYWN0aW9uQXJnczogeyBpbnNlcnRBdDogJ2NoYXJBZnRlcicgfSwgY29udGV4dDogJ25vcm1hbCcgfSxcbiAgICB7IGtleXM6ICdBJywgdHlwZTogJ2FjdGlvbicsIGFjdGlvbjogJ2VudGVySW5zZXJ0TW9kZScsIGlzRWRpdDogdHJ1ZSwgYWN0aW9uQXJnczogeyBpbnNlcnRBdDogJ2VvbCcgfSwgY29udGV4dDogJ25vcm1hbCcgfSxcbiAgICB7IGtleXM6ICdBJywgdHlwZTogJ2FjdGlvbicsIGFjdGlvbjogJ2VudGVySW5zZXJ0TW9kZScsIGlzRWRpdDogdHJ1ZSwgYWN0aW9uQXJnczogeyBpbnNlcnRBdDogJ2VuZE9mU2VsZWN0ZWRBcmVhJyB9LCBjb250ZXh0OiAndmlzdWFsJyB9LFxuICAgIHsga2V5czogJ2knLCB0eXBlOiAnYWN0aW9uJywgYWN0aW9uOiAnZW50ZXJJbnNlcnRNb2RlJywgaXNFZGl0OiB0cnVlLCBhY3Rpb25BcmdzOiB7IGluc2VydEF0OiAnaW5wbGFjZScgfSwgY29udGV4dDogJ25vcm1hbCcgfSxcbiAgICB7IGtleXM6ICdnaScsIHR5cGU6ICdhY3Rpb24nLCBhY3Rpb246ICdlbnRlckluc2VydE1vZGUnLCBpc0VkaXQ6IHRydWUsIGFjdGlvbkFyZ3M6IHsgaW5zZXJ0QXQ6ICdsYXN0RWRpdCcgfSwgY29udGV4dDogJ25vcm1hbCcgfSxcbiAgICB7IGtleXM6ICdJJywgdHlwZTogJ2FjdGlvbicsIGFjdGlvbjogJ2VudGVySW5zZXJ0TW9kZScsIGlzRWRpdDogdHJ1ZSwgYWN0aW9uQXJnczogeyBpbnNlcnRBdDogJ2ZpcnN0Tm9uQmxhbmsnfSwgY29udGV4dDogJ25vcm1hbCcgfSxcbiAgICB7IGtleXM6ICdnSScsIHR5cGU6ICdhY3Rpb24nLCBhY3Rpb246ICdlbnRlckluc2VydE1vZGUnLCBpc0VkaXQ6IHRydWUsIGFjdGlvbkFyZ3M6IHsgaW5zZXJ0QXQ6ICdib2wnfSwgY29udGV4dDogJ25vcm1hbCcgfSxcbiAgICB7IGtleXM6ICdJJywgdHlwZTogJ2FjdGlvbicsIGFjdGlvbjogJ2VudGVySW5zZXJ0TW9kZScsIGlzRWRpdDogdHJ1ZSwgYWN0aW9uQXJnczogeyBpbnNlcnRBdDogJ3N0YXJ0T2ZTZWxlY3RlZEFyZWEnIH0sIGNvbnRleHQ6ICd2aXN1YWwnIH0sXG4gICAgeyBrZXlzOiAnbycsIHR5cGU6ICdhY3Rpb24nLCBhY3Rpb246ICduZXdMaW5lQW5kRW50ZXJJbnNlcnRNb2RlJywgaXNFZGl0OiB0cnVlLCBpbnRlcmxhY2VJbnNlcnRSZXBlYXQ6IHRydWUsIGFjdGlvbkFyZ3M6IHsgYWZ0ZXI6IHRydWUgfSwgY29udGV4dDogJ25vcm1hbCcgfSxcbiAgICB7IGtleXM6ICdPJywgdHlwZTogJ2FjdGlvbicsIGFjdGlvbjogJ25ld0xpbmVBbmRFbnRlckluc2VydE1vZGUnLCBpc0VkaXQ6IHRydWUsIGludGVybGFjZUluc2VydFJlcGVhdDogdHJ1ZSwgYWN0aW9uQXJnczogeyBhZnRlcjogZmFsc2UgfSwgY29udGV4dDogJ25vcm1hbCcgfSxcbiAgICB7IGtleXM6ICd2JywgdHlwZTogJ2FjdGlvbicsIGFjdGlvbjogJ3RvZ2dsZVZpc3VhbE1vZGUnIH0sXG4gICAgeyBrZXlzOiAnVicsIHR5cGU6ICdhY3Rpb24nLCBhY3Rpb246ICd0b2dnbGVWaXN1YWxNb2RlJywgYWN0aW9uQXJnczogeyBsaW5ld2lzZTogdHJ1ZSB9fSxcbiAgICB7IGtleXM6ICc8Qy12PicsIHR5cGU6ICdhY3Rpb24nLCBhY3Rpb246ICd0b2dnbGVWaXN1YWxNb2RlJywgYWN0aW9uQXJnczogeyBibG9ja3dpc2U6IHRydWUgfX0sXG4gICAgeyBrZXlzOiAnPEMtcT4nLCB0eXBlOiAnYWN0aW9uJywgYWN0aW9uOiAndG9nZ2xlVmlzdWFsTW9kZScsIGFjdGlvbkFyZ3M6IHsgYmxvY2t3aXNlOiB0cnVlIH19LFxuICAgIHsga2V5czogJ2d2JywgdHlwZTogJ2FjdGlvbicsIGFjdGlvbjogJ3Jlc2VsZWN0TGFzdFNlbGVjdGlvbicgfSxcbiAgICB7IGtleXM6ICdKJywgdHlwZTogJ2FjdGlvbicsIGFjdGlvbjogJ2pvaW5MaW5lcycsIGlzRWRpdDogdHJ1ZSB9LFxuICAgIHsga2V5czogJ2dKJywgdHlwZTogJ2FjdGlvbicsIGFjdGlvbjogJ2pvaW5MaW5lcycsIGFjdGlvbkFyZ3M6IHsga2VlcFNwYWNlczogdHJ1ZSB9LCBpc0VkaXQ6IHRydWUgfSxcbiAgICB7IGtleXM6ICdwJywgdHlwZTogJ2FjdGlvbicsIGFjdGlvbjogJ3Bhc3RlJywgaXNFZGl0OiB0cnVlLCBhY3Rpb25BcmdzOiB7IGFmdGVyOiB0cnVlLCBpc0VkaXQ6IHRydWUgfX0sXG4gICAgeyBrZXlzOiAnUCcsIHR5cGU6ICdhY3Rpb24nLCBhY3Rpb246ICdwYXN0ZScsIGlzRWRpdDogdHJ1ZSwgYWN0aW9uQXJnczogeyBhZnRlcjogZmFsc2UsIGlzRWRpdDogdHJ1ZSB9fSxcbiAgICB7IGtleXM6ICdyPGNoYXJhY3Rlcj4nLCB0eXBlOiAnYWN0aW9uJywgYWN0aW9uOiAncmVwbGFjZScsIGlzRWRpdDogdHJ1ZSB9LFxuICAgIHsga2V5czogJ0A8cmVnaXN0ZXI+JywgdHlwZTogJ2FjdGlvbicsIGFjdGlvbjogJ3JlcGxheU1hY3JvJyB9LFxuICAgIHsga2V5czogJ3E8cmVnaXN0ZXI+JywgdHlwZTogJ2FjdGlvbicsIGFjdGlvbjogJ2VudGVyTWFjcm9SZWNvcmRNb2RlJyB9LFxuICAgIC8vIEhhbmRsZSBSZXBsYWNlLW1vZGUgYXMgYSBzcGVjaWFsIGNhc2Ugb2YgaW5zZXJ0IG1vZGUuXG4gICAgeyBrZXlzOiAnUicsIHR5cGU6ICdhY3Rpb24nLCBhY3Rpb246ICdlbnRlckluc2VydE1vZGUnLCBpc0VkaXQ6IHRydWUsIGFjdGlvbkFyZ3M6IHsgcmVwbGFjZTogdHJ1ZSB9LCBjb250ZXh0OiAnbm9ybWFsJ30sXG4gICAgeyBrZXlzOiAnUicsIHR5cGU6ICdvcGVyYXRvcicsIG9wZXJhdG9yOiAnY2hhbmdlJywgb3BlcmF0b3JBcmdzOiB7IGxpbmV3aXNlOiB0cnVlLCBmdWxsTGluZTogdHJ1ZSB9LCBjb250ZXh0OiAndmlzdWFsJywgZXhpdFZpc3VhbEJsb2NrOiB0cnVlfSxcbiAgICB7IGtleXM6ICd1JywgdHlwZTogJ2FjdGlvbicsIGFjdGlvbjogJ3VuZG8nLCBjb250ZXh0OiAnbm9ybWFsJyB9LFxuICAgIHsga2V5czogJ3UnLCB0eXBlOiAnb3BlcmF0b3InLCBvcGVyYXRvcjogJ2NoYW5nZUNhc2UnLCBvcGVyYXRvckFyZ3M6IHt0b0xvd2VyOiB0cnVlfSwgY29udGV4dDogJ3Zpc3VhbCcsIGlzRWRpdDogdHJ1ZSB9LFxuICAgIHsga2V5czogJ1UnLCB0eXBlOiAnb3BlcmF0b3InLCBvcGVyYXRvcjogJ2NoYW5nZUNhc2UnLCBvcGVyYXRvckFyZ3M6IHt0b0xvd2VyOiBmYWxzZX0sIGNvbnRleHQ6ICd2aXN1YWwnLCBpc0VkaXQ6IHRydWUgfSxcbiAgICB7IGtleXM6ICc8Qy1yPicsIHR5cGU6ICdhY3Rpb24nLCBhY3Rpb246ICdyZWRvJyB9LFxuICAgIHsga2V5czogJ208cmVnaXN0ZXI+JywgdHlwZTogJ2FjdGlvbicsIGFjdGlvbjogJ3NldE1hcmsnIH0sXG4gICAgeyBrZXlzOiAnXCI8cmVnaXN0ZXI+JywgdHlwZTogJ2FjdGlvbicsIGFjdGlvbjogJ3NldFJlZ2lzdGVyJyB9LFxuICAgIHsga2V5czogJzxDLXI+PHJlZ2lzdGVyPicsIHR5cGU6ICdhY3Rpb24nLCBhY3Rpb246ICdpbnNlcnRSZWdpc3RlcicsIGNvbnRleHQ6ICdpbnNlcnQnLCBpc0VkaXQ6IHRydWUgfSxcbiAgICB7IGtleXM6ICc8Qy1vPicsIHR5cGU6ICdhY3Rpb24nLCBhY3Rpb246ICdvbmVOb3JtYWxDb21tYW5kJywgY29udGV4dDogJ2luc2VydCcgfSxcbiAgICB7IGtleXM6ICd6eicsIHR5cGU6ICdhY3Rpb24nLCBhY3Rpb246ICdzY3JvbGxUb0N1cnNvcicsIGFjdGlvbkFyZ3M6IHsgcG9zaXRpb246ICdjZW50ZXInIH19LFxuICAgIHsga2V5czogJ3ouJywgdHlwZTogJ2FjdGlvbicsIGFjdGlvbjogJ3Njcm9sbFRvQ3Vyc29yJywgYWN0aW9uQXJnczogeyBwb3NpdGlvbjogJ2NlbnRlcicgfSwgbW90aW9uOiAnbW92ZVRvRmlyc3ROb25XaGl0ZVNwYWNlQ2hhcmFjdGVyJyB9LFxuICAgIHsga2V5czogJ3p0JywgdHlwZTogJ2FjdGlvbicsIGFjdGlvbjogJ3Njcm9sbFRvQ3Vyc29yJywgYWN0aW9uQXJnczogeyBwb3NpdGlvbjogJ3RvcCcgfX0sXG4gICAgeyBrZXlzOiAnejxDUj4nLCB0eXBlOiAnYWN0aW9uJywgYWN0aW9uOiAnc2Nyb2xsVG9DdXJzb3InLCBhY3Rpb25BcmdzOiB7IHBvc2l0aW9uOiAndG9wJyB9LCBtb3Rpb246ICdtb3ZlVG9GaXJzdE5vbldoaXRlU3BhY2VDaGFyYWN0ZXInIH0sXG4gICAgeyBrZXlzOiAnemInLCB0eXBlOiAnYWN0aW9uJywgYWN0aW9uOiAnc2Nyb2xsVG9DdXJzb3InLCBhY3Rpb25BcmdzOiB7IHBvc2l0aW9uOiAnYm90dG9tJyB9fSxcbiAgICB7IGtleXM6ICd6LScsIHR5cGU6ICdhY3Rpb24nLCBhY3Rpb246ICdzY3JvbGxUb0N1cnNvcicsIGFjdGlvbkFyZ3M6IHsgcG9zaXRpb246ICdib3R0b20nIH0sIG1vdGlvbjogJ21vdmVUb0ZpcnN0Tm9uV2hpdGVTcGFjZUNoYXJhY3RlcicgfSxcbiAgICB7IGtleXM6ICcuJywgdHlwZTogJ2FjdGlvbicsIGFjdGlvbjogJ3JlcGVhdExhc3RFZGl0JyB9LFxuICAgIHsga2V5czogJzxDLWE+JywgdHlwZTogJ2FjdGlvbicsIGFjdGlvbjogJ2luY3JlbWVudE51bWJlclRva2VuJywgaXNFZGl0OiB0cnVlLCBhY3Rpb25BcmdzOiB7aW5jcmVhc2U6IHRydWUsIGJhY2t0cmFjazogZmFsc2V9fSxcbiAgICB7IGtleXM6ICc8Qy14PicsIHR5cGU6ICdhY3Rpb24nLCBhY3Rpb246ICdpbmNyZW1lbnROdW1iZXJUb2tlbicsIGlzRWRpdDogdHJ1ZSwgYWN0aW9uQXJnczoge2luY3JlYXNlOiBmYWxzZSwgYmFja3RyYWNrOiBmYWxzZX19LFxuICAgIHsga2V5czogJzxDLXQ+JywgdHlwZTogJ2FjdGlvbicsIGFjdGlvbjogJ2luZGVudCcsIGFjdGlvbkFyZ3M6IHsgaW5kZW50UmlnaHQ6IHRydWUgfSwgY29udGV4dDogJ2luc2VydCcgfSxcbiAgICB7IGtleXM6ICc8Qy1kPicsIHR5cGU6ICdhY3Rpb24nLCBhY3Rpb246ICdpbmRlbnQnLCBhY3Rpb25BcmdzOiB7IGluZGVudFJpZ2h0OiBmYWxzZSB9LCBjb250ZXh0OiAnaW5zZXJ0JyB9LFxuICAgIC8vIFRleHQgb2JqZWN0IG1vdGlvbnNcbiAgICB7IGtleXM6ICdhPHJlZ2lzdGVyPicsIHR5cGU6ICdtb3Rpb24nLCBtb3Rpb246ICd0ZXh0T2JqZWN0TWFuaXB1bGF0aW9uJyB9LFxuICAgIHsga2V5czogJ2k8cmVnaXN0ZXI+JywgdHlwZTogJ21vdGlvbicsIG1vdGlvbjogJ3RleHRPYmplY3RNYW5pcHVsYXRpb24nLCBtb3Rpb25BcmdzOiB7IHRleHRPYmplY3RJbm5lcjogdHJ1ZSB9fSxcbiAgICAvLyBTZWFyY2hcbiAgICB7IGtleXM6ICcvJywgdHlwZTogJ3NlYXJjaCcsIHNlYXJjaEFyZ3M6IHsgZm9yd2FyZDogdHJ1ZSwgcXVlcnlTcmM6ICdwcm9tcHQnLCB0b0p1bXBsaXN0OiB0cnVlIH19LFxuICAgIHsga2V5czogJz8nLCB0eXBlOiAnc2VhcmNoJywgc2VhcmNoQXJnczogeyBmb3J3YXJkOiBmYWxzZSwgcXVlcnlTcmM6ICdwcm9tcHQnLCB0b0p1bXBsaXN0OiB0cnVlIH19LFxuICAgIHsga2V5czogJyonLCB0eXBlOiAnc2VhcmNoJywgc2VhcmNoQXJnczogeyBmb3J3YXJkOiB0cnVlLCBxdWVyeVNyYzogJ3dvcmRVbmRlckN1cnNvcicsIHdob2xlV29yZE9ubHk6IHRydWUsIHRvSnVtcGxpc3Q6IHRydWUgfX0sXG4gICAgeyBrZXlzOiAnIycsIHR5cGU6ICdzZWFyY2gnLCBzZWFyY2hBcmdzOiB7IGZvcndhcmQ6IGZhbHNlLCBxdWVyeVNyYzogJ3dvcmRVbmRlckN1cnNvcicsIHdob2xlV29yZE9ubHk6IHRydWUsIHRvSnVtcGxpc3Q6IHRydWUgfX0sXG4gICAgeyBrZXlzOiAnZyonLCB0eXBlOiAnc2VhcmNoJywgc2VhcmNoQXJnczogeyBmb3J3YXJkOiB0cnVlLCBxdWVyeVNyYzogJ3dvcmRVbmRlckN1cnNvcicsIHRvSnVtcGxpc3Q6IHRydWUgfX0sXG4gICAgeyBrZXlzOiAnZyMnLCB0eXBlOiAnc2VhcmNoJywgc2VhcmNoQXJnczogeyBmb3J3YXJkOiBmYWxzZSwgcXVlcnlTcmM6ICd3b3JkVW5kZXJDdXJzb3InLCB0b0p1bXBsaXN0OiB0cnVlIH19LFxuICAgIC8vIEV4IGNvbW1hbmRcbiAgICB7IGtleXM6ICc6JywgdHlwZTogJ2V4JyB9XG4gIF07XG4gIHZhciB1c2VkS2V5cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHZhciBkZWZhdWx0S2V5bWFwTGVuZ3RoID0gZGVmYXVsdEtleW1hcC5sZW5ndGg7XG5cbiAgLyoqXG4gICAqIEV4IGNvbW1hbmRzXG4gICAqIENhcmUgbXVzdCBiZSB0YWtlbiB3aGVuIGFkZGluZyB0byB0aGUgZGVmYXVsdCBFeCBjb21tYW5kIG1hcC4gRm9yIGFueVxuICAgKiBwYWlyIG9mIGNvbW1hbmRzIHRoYXQgaGF2ZSBhIHNoYXJlZCBwcmVmaXgsIGF0IGxlYXN0IG9uZSBvZiB0aGVpclxuICAgKiBzaG9ydE5hbWVzIG11c3Qgbm90IG1hdGNoIHRoZSBwcmVmaXggb2YgdGhlIG90aGVyIGNvbW1hbmQuXG4gICAqL1xuICB2YXIgZGVmYXVsdEV4Q29tbWFuZE1hcCA9IFtcbiAgICB7IG5hbWU6ICdjb2xvcnNjaGVtZScsIHNob3J0TmFtZTogJ2NvbG8nIH0sXG4gICAgeyBuYW1lOiAnbWFwJyB9LFxuICAgIHsgbmFtZTogJ2ltYXAnLCBzaG9ydE5hbWU6ICdpbScgfSxcbiAgICB7IG5hbWU6ICdubWFwJywgc2hvcnROYW1lOiAnbm0nIH0sXG4gICAgeyBuYW1lOiAndm1hcCcsIHNob3J0TmFtZTogJ3ZtJyB9LFxuICAgIHsgbmFtZTogJ29tYXAnLCBzaG9ydE5hbWU6ICdvbScgfSxcbiAgICB7IG5hbWU6ICdub3JlbWFwJywgc2hvcnROYW1lOiAnbm8nIH0sXG4gICAgeyBuYW1lOiAnbm5vcmVtYXAnLCBzaG9ydE5hbWU6ICdubicgfSxcbiAgICB7IG5hbWU6ICd2bm9yZW1hcCcsIHNob3J0TmFtZTogJ3ZuJyB9LFxuICAgIHsgbmFtZTogJ2lub3JlbWFwJywgc2hvcnROYW1lOiAnaW5vJyB9LFxuICAgIHsgbmFtZTogJ29ub3JlbWFwJywgc2hvcnROYW1lOiAnb25vJyB9LFxuICAgIHsgbmFtZTogJ3VubWFwJyB9LFxuICAgIHsgbmFtZTogJ21hcGNsZWFyJywgc2hvcnROYW1lOiAnbWFwYycgfSxcbiAgICB7IG5hbWU6ICdubWFwY2xlYXInLCBzaG9ydE5hbWU6ICdubWFwYycgfSxcbiAgICB7IG5hbWU6ICd2bWFwY2xlYXInLCBzaG9ydE5hbWU6ICd2bWFwYycgfSxcbiAgICB7IG5hbWU6ICdpbWFwY2xlYXInLCBzaG9ydE5hbWU6ICdpbWFwYycgfSxcbiAgICB7IG5hbWU6ICdvbWFwY2xlYXInLCBzaG9ydE5hbWU6ICdvbWFwYycgfSxcbiAgICB7IG5hbWU6ICd3cml0ZScsIHNob3J0TmFtZTogJ3cnIH0sXG4gICAgeyBuYW1lOiAndW5kbycsIHNob3J0TmFtZTogJ3UnIH0sXG4gICAgeyBuYW1lOiAncmVkbycsIHNob3J0TmFtZTogJ3JlZCcgfSxcbiAgICB7IG5hbWU6ICdzZXQnLCBzaG9ydE5hbWU6ICdzZScgfSxcbiAgICB7IG5hbWU6ICdzZXRsb2NhbCcsIHNob3J0TmFtZTogJ3NldGwnIH0sXG4gICAgeyBuYW1lOiAnc2V0Z2xvYmFsJywgc2hvcnROYW1lOiAnc2V0ZycgfSxcbiAgICB7IG5hbWU6ICdzb3J0Jywgc2hvcnROYW1lOiAnc29yJyB9LFxuICAgIHsgbmFtZTogJ3N1YnN0aXR1dGUnLCBzaG9ydE5hbWU6ICdzJywgcG9zc2libHlBc3luYzogdHJ1ZSB9LFxuICAgIHsgbmFtZTogJ3N0YXJ0aW5zZXJ0Jywgc2hvcnROYW1lOiAnc3RhcnQnIH0sXG4gICAgeyBuYW1lOiAnbm9obHNlYXJjaCcsIHNob3J0TmFtZTogJ25vaCcgfSxcbiAgICB7IG5hbWU6ICd5YW5rJywgc2hvcnROYW1lOiAneScgfSxcbiAgICB7IG5hbWU6ICdkZWxtYXJrcycsIHNob3J0TmFtZTogJ2RlbG0nIH0sXG4gICAgeyBuYW1lOiAnbWFya3MnLCAgZXhjbHVkZUZyb21Db21tYW5kSGlzdG9yeTogdHJ1ZSB9LFxuICAgIHsgbmFtZTogJ3JlZ2lzdGVycycsIHNob3J0TmFtZTogJ3JlZycsIGV4Y2x1ZGVGcm9tQ29tbWFuZEhpc3Rvcnk6IHRydWUgfSxcbiAgICB7IG5hbWU6ICd2Z2xvYmFsJywgc2hvcnROYW1lOiAndicgfSxcbiAgICB7IG5hbWU6ICdkZWxldGUnLCBzaG9ydE5hbWU6ICdkJyB9LFxuICAgIHsgbmFtZTogJ2pvaW4nLCBzaG9ydE5hbWU6ICdqJyB9LFxuICAgIHsgbmFtZTogJ25vcm1hbCcsIHNob3J0TmFtZTogJ25vcm0nIH0sXG4gICAgeyBuYW1lOiAnZ2xvYmFsJywgc2hvcnROYW1lOiAnZycgfVxuICBdO1xuXG4gIC8qKlxuICAgKiBMYW5nbWFwXG4gICAqIERldGVybWluZXMgaG93IHRvIGludGVycHJldCBrZXlzdHJva2VzIGluIE5vcm1hbCBhbmQgVmlzdWFsIG1vZGUuXG4gICAqIFVzZWZ1bCBmb3IgcGVvcGxlIHdobyB1c2UgYSBkaWZmZXJlbnQga2V5Ym9hcmQgbGF5b3V0IHRoYW4gUVdFUlRZXG4gICAqL1xuICB2YXIgbGFuZ21hcCA9IHBhcnNlTGFuZ21hcCgnJyk7XG5cbiAgLyoqIEBhcmcge0NvZGVNaXJyb3J9IGNtICovXG4gIGZ1bmN0aW9uIGVudGVyVmltTW9kZShjbSkge1xuICAgIGNtLnNldE9wdGlvbignZGlzYWJsZUlucHV0JywgdHJ1ZSk7XG4gICAgY20uc2V0T3B0aW9uKCdzaG93Q3Vyc29yV2hlblNlbGVjdGluZycsIGZhbHNlKTtcbiAgICBDTS5zaWduYWwoY20sIFwidmltLW1vZGUtY2hhbmdlXCIsIHttb2RlOiBcIm5vcm1hbFwifSk7XG4gICAgY20ub24oJ2N1cnNvckFjdGl2aXR5Jywgb25DdXJzb3JBY3Rpdml0eSk7XG4gICAgbWF5YmVJbml0VmltU3RhdGUoY20pO1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBDTS5vbihjbS5nZXRJbnB1dEZpZWxkKCksICdwYXN0ZScsIGdldE9uUGFzdGVGbihjbSkpO1xuICB9XG5cbiAgLyoqIEBhcmcge0NvZGVNaXJyb3J9IGNtICovXG4gIGZ1bmN0aW9uIGxlYXZlVmltTW9kZShjbSkge1xuICAgIGNtLnNldE9wdGlvbignZGlzYWJsZUlucHV0JywgZmFsc2UpO1xuICAgIGNtLm9mZignY3Vyc29yQWN0aXZpdHknLCBvbkN1cnNvckFjdGl2aXR5KTtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgQ00ub2ZmKGNtLmdldElucHV0RmllbGQoKSwgJ3Bhc3RlJywgZ2V0T25QYXN0ZUZuKGNtKSk7XG4gICAgY20uc3RhdGUudmltID0gbnVsbDtcbiAgICBpZiAoaGlnaGxpZ2h0VGltZW91dCkgY2xlYXJUaW1lb3V0KGhpZ2hsaWdodFRpbWVvdXQpO1xuICB9XG5cbiAgLyoqIEBhcmcge0NvZGVNaXJyb3JWfSBjbSAqL1xuICBmdW5jdGlvbiBnZXRPblBhc3RlRm4oY20pIHtcbiAgICB2YXIgdmltID0gY20uc3RhdGUudmltO1xuICAgIGlmICghdmltLm9uUGFzdGVGbikge1xuICAgICAgdmltLm9uUGFzdGVGbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIXZpbS5pbnNlcnRNb2RlKSB7XG4gICAgICAgICAgY20uc2V0Q3Vyc29yKG9mZnNldEN1cnNvcihjbS5nZXRDdXJzb3IoKSwgMCwgMSkpO1xuICAgICAgICAgIGFjdGlvbnMuZW50ZXJJbnNlcnRNb2RlKGNtLCB7fSwgdmltKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHZpbS5vblBhc3RlRm47XG4gIH1cblxuICB2YXIgbnVtYmVyUmVnZXggPSAvW1xcZF0vO1xuICB2YXIgd29yZENoYXJUZXN0ID0gW0NNLmlzV29yZENoYXIsIGZ1bmN0aW9uKGNoKSB7XG4gICAgcmV0dXJuIGNoICYmICFDTS5pc1dvcmRDaGFyKGNoKSAmJiAhL1xccy8udGVzdChjaCk7XG4gIH1dLCBiaWdXb3JkQ2hhclRlc3QgPSBbZnVuY3Rpb24oY2gpIHtcbiAgICByZXR1cm4gL1xcUy8udGVzdChjaCk7XG4gIH1dO1xuICB2YXIgdmFsaWRNYXJrcyA9IFsnPCcsICc+J107XG4gIHZhciB2YWxpZFJlZ2lzdGVycyA9IFsnLScsICdcIicsICcuJywgJzonLCAnXycsICcvJywgJysnXTtcbiAgdmFyIGxhdGluQ2hhclJlZ2V4ID0gL15cXHckLztcbiAgdmFyIHVwcGVyQ2FzZUNoYXJzID0gL15bQS1aXSQvO1xuICB0cnkgeyB1cHBlckNhc2VDaGFycyA9IG5ldyBSZWdFeHAoXCJeW1xcXFxwe0x1fV0kXCIsIFwidVwiKTsgfVxuICBjYXRjaCAoXykgeyB9XG5cbiAgLyoqIEBhcmcge0NvZGVNaXJyb3J9IGNtIEBhcmcge251bWJlcn0gbGluZSAqL1xuICBmdW5jdGlvbiBpc0xpbmUoY20sIGxpbmUpIHtcbiAgICByZXR1cm4gbGluZSA+PSBjbS5maXJzdExpbmUoKSAmJiBsaW5lIDw9IGNtLmxhc3RMaW5lKCk7XG4gIH1cbiAgLyoqIEBhcmcge3N0cmluZ30gayAqL1xuICBmdW5jdGlvbiBpc0xvd2VyQ2FzZShrKSB7XG4gICAgcmV0dXJuICgvXlthLXpdJC8pLnRlc3Qoayk7XG4gIH1cbiAgLyoqIEBhcmcge3N0cmluZ30gayAqL1xuICBmdW5jdGlvbiBpc01hdGNoYWJsZVN5bWJvbChrKSB7XG4gICAgcmV0dXJuICcoKVtde30nLmluZGV4T2YoaykgIT0gLTE7XG4gIH1cbiAgLyoqIEBhcmcge3N0cmluZ30gayAqL1xuICBmdW5jdGlvbiBpc051bWJlcihrKSB7XG4gICAgcmV0dXJuIG51bWJlclJlZ2V4LnRlc3Qoayk7XG4gIH1cbiAgLyoqIEBhcmcge3N0cmluZ30gayAqL1xuICBmdW5jdGlvbiBpc1VwcGVyQ2FzZShrKSB7XG4gICAgcmV0dXJuIHVwcGVyQ2FzZUNoYXJzLnRlc3Qoayk7XG4gIH1cbiAgLyoqIEBhcmcge3N0cmluZ30gayAqL1xuICBmdW5jdGlvbiBpc1doaXRlU3BhY2VTdHJpbmcoaykge1xuICAgIHJldHVybiAoL15cXHMqJC8pLnRlc3Qoayk7XG4gIH1cbiAgLyoqIEBhcmcge3N0cmluZ30gayAqL1xuICBmdW5jdGlvbiBpc0VuZE9mU2VudGVuY2VTeW1ib2woaykge1xuICAgIHJldHVybiAnLj8hJy5pbmRleE9mKGspICE9IC0xO1xuICB9XG4gIC8qKiBAYXJnIHthbnl9IHZhbCBAYXJnIHtzdHJpbmcgfCBhbnlbXX0gYXJyICovXG4gIGZ1bmN0aW9uIGluQXJyYXkodmFsLCBhcnIpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGFycltpXSA9PSB2YWwpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG5cbiAgLyoqIEB0eXBlZGVmIHtpbXBvcnQoXCIuL3R5cGVzXCIpLnZpbU9wdGlvbn0gdmltT3B0aW9uICovXG4gIC8qKiBAdHlwZSB7T2JqZWN0PHN0cmluZywgdmltT3B0aW9uPn0gKi9cbiAgdmFyIG9wdGlvbnMgPSB7fTtcbiAgLyoqXG4gICAqIEBvdmVybG9hZFxuICAgKiBAYXJnIHtzdHJpbmd9IG5hbWUgXG4gICAqIEBhcmcge2Jvb2xlYW58bnVsbHx1bmRlZmluZWR9IGRlZmF1bHRWYWx1ZSBcbiAgICogQGFyZyB7J2Jvb2xlYW4nfSB0eXBlIFxuICAgKiBAYXJnIHtzdHJpbmdbXXxudWxsfSBbYWxpYXNlc10gXG4gICAqIEBhcmcge2ltcG9ydChcIi4vdHlwZXNcIikuYm9vbGVhbk9wdGlvbkNhbGxiYWNrfSBbY2FsbGJhY2tdIFxuICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICovXG4gIC8qKlxuICAgKiBAb3ZlcmxvYWRcbiAgICogQGFyZyB7c3RyaW5nfSBuYW1lIFxuICAgKiBAYXJnIHtudW1iZXJ8bnVsbHx1bmRlZmluZWR9IGRlZmF1bHRWYWx1ZSBcbiAgICogQGFyZyB7J251bWJlcid9IHR5cGUgXG4gICAqIEBhcmcge3N0cmluZ1tdfG51bGx9IFthbGlhc2VzXSBcbiAgICogQGFyZyB7aW1wb3J0KFwiLi90eXBlc1wiKS5udW1iZXJPcHRpb25DYWxsYmFja30gW2NhbGxiYWNrXVxuICAgKiBAcmV0dXJucyB7dm9pZH0gXG4gICAqL1xuICAvKipcbiAgICogQG92ZXJsb2FkXG4gICAqIEBhcmcge3N0cmluZ30gbmFtZSBcbiAgICogQGFyZyB7c3RyaW5nfG51bGx8dW5kZWZpbmVkfSBkZWZhdWx0VmFsdWUgXG4gICAqIEBhcmcgeydzdHJpbmcnfSB0eXBlIFxuICAgKiBAYXJnIHtzdHJpbmdbXXxudWxsfSBbYWxpYXNlc10gXG4gICAqIEBhcmcge2ltcG9ydChcIi4vdHlwZXNcIikuc3RyaW5nT3B0aW9uQ2FsbGJhY2t9IFtjYWxsYmFja11cbiAgICogQHJldHVybnMge3ZvaWR9XG4gICAqL1xuICAvKiogXG4gICAqIEBhcmcge3N0cmluZ30gbmFtZSBcbiAgICogQGFyZyB7YW55fSBkZWZhdWx0VmFsdWUgXG4gICAqIEBhcmcgeydzdHJpbmcnfSB0eXBlIFxuICAgKiBAYXJnIHtzdHJpbmdbXXxudWxsfSBbYWxpYXNlc10gXG4gICAqIEBhcmcge2ltcG9ydChcIi4vdHlwZXNcIikub3B0aW9uQ2FsbGJhY2t9IFtjYWxsYmFja10gXG4gICAqICovXG4gIGZ1bmN0aW9uIGRlZmluZU9wdGlvbihuYW1lLCBkZWZhdWx0VmFsdWUsIHR5cGUsIGFsaWFzZXMsIGNhbGxiYWNrKSB7XG4gICAgaWYgKGRlZmF1bHRWYWx1ZSA9PT0gdW5kZWZpbmVkICYmICFjYWxsYmFjaykge1xuICAgICAgdGhyb3cgRXJyb3IoJ2RlZmF1bHRWYWx1ZSBpcyByZXF1aXJlZCB1bmxlc3MgY2FsbGJhY2sgaXMgcHJvdmlkZWQnKTtcbiAgICB9XG4gICAgaWYgKCF0eXBlKSB7IHR5cGUgPSAnc3RyaW5nJzsgfVxuICAgIG9wdGlvbnNbbmFtZV0gPSB7XG4gICAgICB0eXBlOiB0eXBlLFxuICAgICAgZGVmYXVsdFZhbHVlOiBkZWZhdWx0VmFsdWUsXG4gICAgICBjYWxsYmFjazogY2FsbGJhY2tcbiAgICB9O1xuICAgIGlmIChhbGlhc2VzKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFsaWFzZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgb3B0aW9uc1thbGlhc2VzW2ldXSA9IG9wdGlvbnNbbmFtZV07XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChkZWZhdWx0VmFsdWUpIHtcbiAgICAgIHNldE9wdGlvbihuYW1lLCBkZWZhdWx0VmFsdWUpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAYXJnIHtzdHJpbmd9IG5hbWUgXG4gICAqIEBhcmcge2FueX0gdmFsdWUgXG4gICAqIEBhcmcge0NvZGVNaXJyb3JWfSBbY21dIFxuICAgKiBAYXJnIHt7IHNjb3BlPzogYW55OyB9IHwgdW5kZWZpbmVkfSBbY2ZnXSAqL1xuICBmdW5jdGlvbiBzZXRPcHRpb24obmFtZSwgdmFsdWUsIGNtLCBjZmcpIHtcbiAgICB2YXIgb3B0aW9uID0gb3B0aW9uc1tuYW1lXTtcbiAgICBjZmcgPSBjZmcgfHwge307XG4gICAgdmFyIHNjb3BlID0gY2ZnLnNjb3BlO1xuICAgIGlmICghb3B0aW9uKSB7XG4gICAgICByZXR1cm4gbmV3IEVycm9yKCdVbmtub3duIG9wdGlvbjogJyArIG5hbWUpO1xuICAgIH1cbiAgICBpZiAob3B0aW9uLnR5cGUgPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICBpZiAodmFsdWUgJiYgdmFsdWUgIT09IHRydWUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBFcnJvcignSW52YWxpZCBhcmd1bWVudDogJyArIG5hbWUgKyAnPScgKyB2YWx1ZSk7XG4gICAgICB9IGVsc2UgaWYgKHZhbHVlICE9PSBmYWxzZSkge1xuICAgICAgICAvLyBCb29sZWFuIG9wdGlvbnMgYXJlIHNldCB0byB0cnVlIGlmIHZhbHVlIGlzIG5vdCBkZWZpbmVkLlxuICAgICAgICB2YWx1ZSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChvcHRpb24uY2FsbGJhY2spIHtcbiAgICAgIGlmIChzY29wZSAhPT0gJ2xvY2FsJykge1xuICAgICAgICBvcHRpb24uY2FsbGJhY2sodmFsdWUsIHVuZGVmaW5lZCk7XG4gICAgICB9XG4gICAgICBpZiAoc2NvcGUgIT09ICdnbG9iYWwnICYmIGNtKSB7XG4gICAgICAgIG9wdGlvbi5jYWxsYmFjayh2YWx1ZSwgY20pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoc2NvcGUgIT09ICdsb2NhbCcpIHtcbiAgICAgICAgb3B0aW9uLnZhbHVlID0gb3B0aW9uLnR5cGUgPT0gJ2Jvb2xlYW4nID8gISF2YWx1ZSA6IHZhbHVlO1xuICAgICAgfVxuICAgICAgaWYgKHNjb3BlICE9PSAnZ2xvYmFsJyAmJiBjbSkge1xuICAgICAgICBjbS5zdGF0ZS52aW0ub3B0aW9uc1tuYW1lXSA9IHt2YWx1ZTogdmFsdWV9O1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKiBcbiAgICogQGFyZyB7c3RyaW5nfSBuYW1lIFxuICAgKiBAYXJnIHtDb2RlTWlycm9yVn0gW2NtXSBcbiAgICogQGFyZyB7eyBzY29wZT86IGFueTsgfSB8IHVuZGVmaW5lZH0gW2NmZ10gKi9cbiAgZnVuY3Rpb24gZ2V0T3B0aW9uKG5hbWUsIGNtLCBjZmcpIHtcbiAgICB2YXIgb3B0aW9uID0gb3B0aW9uc1tuYW1lXTtcbiAgICBjZmcgPSBjZmcgfHwge307XG4gICAgdmFyIHNjb3BlID0gY2ZnLnNjb3BlO1xuICAgIGlmICghb3B0aW9uKSB7XG4gICAgICByZXR1cm4gbmV3IEVycm9yKCdVbmtub3duIG9wdGlvbjogJyArIG5hbWUpO1xuICAgIH1cbiAgICBpZiAob3B0aW9uLmNhbGxiYWNrKSB7XG4gICAgICBsZXQgbG9jYWwgPSBjbSAmJiBvcHRpb24uY2FsbGJhY2sodW5kZWZpbmVkLCBjbSk7XG4gICAgICBpZiAoc2NvcGUgIT09ICdnbG9iYWwnICYmIGxvY2FsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsO1xuICAgICAgfVxuICAgICAgaWYgKHNjb3BlICE9PSAnbG9jYWwnKSB7XG4gICAgICAgIHJldHVybiBvcHRpb24uY2FsbGJhY2soKTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IGxvY2FsID0gKHNjb3BlICE9PSAnZ2xvYmFsJykgJiYgKGNtICYmIGNtLnN0YXRlLnZpbS5vcHRpb25zW25hbWVdKTtcbiAgICAgIHJldHVybiAobG9jYWwgfHwgKHNjb3BlICE9PSAnbG9jYWwnKSAmJiBvcHRpb24gfHwge30pLnZhbHVlO1xuICAgIH1cbiAgfVxuICAvKiogQGFyZyB7c3RyaW5nfHVuZGVmaW5lZH0gbmFtZSBAYXJnIHtDb2RlTWlycm9yVn0gW2NtXSAqL1xuICBkZWZpbmVPcHRpb24oJ2ZpbGV0eXBlJywgdW5kZWZpbmVkLCAnc3RyaW5nJywgWydmdCddLCBmdW5jdGlvbihuYW1lLCBjbSkge1xuICAgIC8vIE9wdGlvbiBpcyBsb2NhbC4gRG8gbm90aGluZyBmb3IgZ2xvYmFsLlxuICAgIGlmIChjbSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIFRoZSAnZmlsZXR5cGUnIG9wdGlvbiBwcm94aWVzIHRvIHRoZSBDb2RlTWlycm9yICdtb2RlJyBvcHRpb24uXG4gICAgaWYgKG5hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgbGV0IG1vZGUgPSBjbS5nZXRPcHRpb24oJ21vZGUnKTtcbiAgICAgIHJldHVybiBtb2RlID09ICdudWxsJyA/ICcnIDogbW9kZTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IG1vZGUgPSBuYW1lID09ICcnID8gJ251bGwnIDogbmFtZTtcbiAgICAgIGNtLnNldE9wdGlvbignbW9kZScsIG1vZGUpO1xuICAgIH1cbiAgfSk7XG4gIGRlZmluZU9wdGlvbigndGV4dHdpZHRoJywgODAsICdudW1iZXInLCBbJ3R3J10sIGZ1bmN0aW9uKHdpZHRoLCBjbSkge1xuICAgIC8vIE9wdGlvbiBpcyBsb2NhbC4gRG8gbm90aGluZyBmb3IgZ2xvYmFsLlxuICAgIGlmIChjbSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIFRoZSAnZmlsZXR5cGUnIG9wdGlvbiBwcm94aWVzIHRvIHRoZSBDb2RlTWlycm9yICdtb2RlJyBvcHRpb24uXG4gICAgaWYgKHdpZHRoID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHZhciB2YWx1ZSA9IGNtLmdldE9wdGlvbigndGV4dHdpZHRoJyk7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBjb2x1bW4gPSBNYXRoLnJvdW5kKHdpZHRoKTtcbiAgICAgIGlmIChjb2x1bW4gPiAxKSB7XG4gICAgICAgIGNtLnNldE9wdGlvbigndGV4dHdpZHRoJywgY29sdW1uKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIHZhciBjcmVhdGVDaXJjdWxhckp1bXBMaXN0ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHNpemUgPSAxMDA7XG4gICAgdmFyIHBvaW50ZXIgPSAtMTtcbiAgICB2YXIgaGVhZCA9IDA7XG4gICAgdmFyIHRhaWwgPSAwO1xuICAgIFxuICAgIHZhciBidWZmZXIgPSAvKipAdHlwZSB7KE1hcmtlcnx1bmRlZmluZWQpW119ICovIChuZXcgQXJyYXkoc2l6ZSkpO1xuICAgIC8qKiBAYXJnIHtDb2RlTWlycm9yfSBjbSAgQGFyZyB7UG9zfSBvbGRDdXIgQGFyZyB7UG9zfSBuZXdDdXIgKi9cbiAgICBmdW5jdGlvbiBhZGQoY20sIG9sZEN1ciwgbmV3Q3VyKSB7XG4gICAgICB2YXIgY3VycmVudCA9IHBvaW50ZXIgJSBzaXplO1xuICAgICAgdmFyIGN1ck1hcmsgPSBidWZmZXJbY3VycmVudF07XG4gICAgICAvKiogQGFyZyB7UG9zfSBjdXJzb3IgKi9cbiAgICAgIGZ1bmN0aW9uIHVzZU5leHRTbG90KGN1cnNvcikge1xuICAgICAgICB2YXIgbmV4dCA9ICsrcG9pbnRlciAlIHNpemU7XG4gICAgICAgIHZhciB0cmFzaE1hcmsgPSBidWZmZXJbbmV4dF07XG4gICAgICAgIGlmICh0cmFzaE1hcmspIHtcbiAgICAgICAgICB0cmFzaE1hcmsuY2xlYXIoKTtcbiAgICAgICAgfVxuICAgICAgICBidWZmZXJbbmV4dF0gPSBjbS5zZXRCb29rbWFyayhjdXJzb3IpO1xuICAgICAgfVxuICAgICAgaWYgKGN1ck1hcmspIHtcbiAgICAgICAgdmFyIG1hcmtQb3MgPSBjdXJNYXJrLmZpbmQoKTtcbiAgICAgICAgLy8gYXZvaWQgcmVjb3JkaW5nIHJlZHVuZGFudCBjdXJzb3IgcG9zaXRpb25cbiAgICAgICAgaWYgKG1hcmtQb3MgJiYgIWN1cnNvckVxdWFsKG1hcmtQb3MsIG9sZEN1cikpIHtcbiAgICAgICAgICB1c2VOZXh0U2xvdChvbGRDdXIpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB1c2VOZXh0U2xvdChvbGRDdXIpO1xuICAgICAgfVxuICAgICAgdXNlTmV4dFNsb3QobmV3Q3VyKTtcbiAgICAgIGhlYWQgPSBwb2ludGVyO1xuICAgICAgdGFpbCA9IHBvaW50ZXIgLSBzaXplICsgMTtcbiAgICAgIGlmICh0YWlsIDwgMCkge1xuICAgICAgICB0YWlsID0gMDtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqIEBhcmcge0NvZGVNaXJyb3J9IGNtICBAYXJnIHtudW1iZXJ9IG9mZnNldCAqL1xuICAgIGZ1bmN0aW9uIG1vdmUoY20sIG9mZnNldCkge1xuICAgICAgcG9pbnRlciArPSBvZmZzZXQ7XG4gICAgICBpZiAocG9pbnRlciA+IGhlYWQpIHtcbiAgICAgICAgcG9pbnRlciA9IGhlYWQ7XG4gICAgICB9IGVsc2UgaWYgKHBvaW50ZXIgPCB0YWlsKSB7XG4gICAgICAgIHBvaW50ZXIgPSB0YWlsO1xuICAgICAgfVxuICAgICAgdmFyIG1hcmsgPSBidWZmZXJbKHNpemUgKyBwb2ludGVyKSAlIHNpemVdO1xuICAgICAgLy8gc2tpcCBtYXJrcyB0aGF0IGFyZSB0ZW1wb3JhcmlseSByZW1vdmVkIGZyb20gdGV4dCBidWZmZXJcbiAgICAgIGlmIChtYXJrICYmICFtYXJrLmZpbmQoKSkge1xuICAgICAgICB2YXIgaW5jID0gb2Zmc2V0ID4gMCA/IDEgOiAtMTtcbiAgICAgICAgdmFyIG5ld0N1cjtcbiAgICAgICAgdmFyIG9sZEN1ciA9IGNtLmdldEN1cnNvcigpO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgcG9pbnRlciArPSBpbmM7XG4gICAgICAgICAgbWFyayA9IGJ1ZmZlclsoc2l6ZSArIHBvaW50ZXIpICUgc2l6ZV07XG4gICAgICAgICAgLy8gc2tpcCBtYXJrcyB0aGF0IGFyZSB0aGUgc2FtZSBhcyBjdXJyZW50IHBvc2l0aW9uXG4gICAgICAgICAgaWYgKG1hcmsgJiZcbiAgICAgICAgICAgICAgKG5ld0N1ciA9IG1hcmsuZmluZCgpKSAmJlxuICAgICAgICAgICAgICAhY3Vyc29yRXF1YWwob2xkQ3VyLCBuZXdDdXIpKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH0gd2hpbGUgKHBvaW50ZXIgPCBoZWFkICYmIHBvaW50ZXIgPiB0YWlsKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBtYXJrO1xuICAgIH1cbiAgICAvKiogQGFyZyB7Q29kZU1pcnJvcn0gY20gQGFyZyB7bnVtYmVyfSBvZmZzZXQgKi9cbiAgICBmdW5jdGlvbiBmaW5kKGNtLCBvZmZzZXQpIHtcbiAgICAgIHZhciBvbGRQb2ludGVyID0gcG9pbnRlcjtcbiAgICAgIHZhciBtYXJrID0gbW92ZShjbSwgb2Zmc2V0KTtcbiAgICAgIHBvaW50ZXIgPSBvbGRQb2ludGVyO1xuICAgICAgcmV0dXJuIG1hcmsgJiYgbWFyay5maW5kKCk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAvKipAdHlwZXtQb3N8dW5kZWZpbmVkfSAqL1xuICAgICAgY2FjaGVkQ3Vyc29yOiB1bmRlZmluZWQsIC8vdXNlZCBmb3IgIyBhbmQgKiBqdW1wc1xuICAgICAgYWRkOiBhZGQsXG4gICAgICBmaW5kOiBmaW5kLFxuICAgICAgbW92ZTogbW92ZVxuICAgIH07XG4gIH07XG5cbiAgLyoqIFxuICAgKiBSZXR1cm5zIGFuIG9iamVjdCB0byB0cmFjayB0aGUgY2hhbmdlcyBhc3NvY2lhdGVkIGluc2VydCBtb2RlLiAgSXRcbiAgICogY2xvbmVzIHRoZSBvYmplY3QgdGhhdCBpcyBwYXNzZWQgaW4sIG9yIGNyZWF0ZXMgYW4gZW1wdHkgb2JqZWN0IG9uZSBpZlxuICAgKiBub25lIGlzIHByb3ZpZGVkLlxuICAgKiBAYXJnIHtpbXBvcnQoXCIuL3R5cGVzXCIpLkluc2VydE1vZGVDaGFuZ2VzIHwgdW5kZWZpbmVkfSBbY11cbiAgICogQHJldHVybnMge2ltcG9ydChcIi4vdHlwZXNcIikuSW5zZXJ0TW9kZUNoYW5nZXN9IFxuICAgKi9cbiAgdmFyIGNyZWF0ZUluc2VydE1vZGVDaGFuZ2VzID0gZnVuY3Rpb24oYykge1xuICAgIGlmIChjKSB7XG4gICAgICAvLyBDb3B5IGNvbnN0cnVjdGlvblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgY2hhbmdlczogYy5jaGFuZ2VzLFxuICAgICAgICBleHBlY3RDdXJzb3JBY3Rpdml0eUZvckNoYW5nZTogYy5leHBlY3RDdXJzb3JBY3Rpdml0eUZvckNoYW5nZVxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIC8vIENoYW5nZSBsaXN0XG4gICAgICBjaGFuZ2VzOiBbXSxcbiAgICAgIC8vIFNldCB0byB0cnVlIG9uIGNoYW5nZSwgZmFsc2Ugb24gY3Vyc29yQWN0aXZpdHkuXG4gICAgICBleHBlY3RDdXJzb3JBY3Rpdml0eUZvckNoYW5nZTogZmFsc2VcbiAgICB9O1xuICB9O1xuXG4gIGNsYXNzIE1hY3JvTW9kZVN0YXRlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgIHRoaXMubGF0ZXN0UmVnaXN0ZXIgPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLmlzUGxheWluZyA9IGZhbHNlO1xuICAgICAgdGhpcy5pc1JlY29yZGluZyA9IGZhbHNlO1xuICAgICAgLyoqIEB0eXBlIHtzdHJpbmdbXX0qL1xuICAgICAgdGhpcy5yZXBsYXlTZWFyY2hRdWVyaWVzID0gW107XG4gICAgICB0aGlzLm9uUmVjb3JkaW5nRG9uZSA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMubGFzdEluc2VydE1vZGVDaGFuZ2VzID0gY3JlYXRlSW5zZXJ0TW9kZUNoYW5nZXMoKTtcbiAgICB9XG4gICAgZXhpdE1hY3JvUmVjb3JkTW9kZSgpIHtcbiAgICAgIHZhciBtYWNyb01vZGVTdGF0ZSA9IHZpbUdsb2JhbFN0YXRlLm1hY3JvTW9kZVN0YXRlO1xuICAgICAgaWYgKG1hY3JvTW9kZVN0YXRlLm9uUmVjb3JkaW5nRG9uZSkge1xuICAgICAgICBtYWNyb01vZGVTdGF0ZS5vblJlY29yZGluZ0RvbmUoKTsgLy8gY2xvc2UgZGlhbG9nXG4gICAgICB9XG4gICAgICBtYWNyb01vZGVTdGF0ZS5vblJlY29yZGluZ0RvbmUgPSB1bmRlZmluZWQ7XG4gICAgICBtYWNyb01vZGVTdGF0ZS5pc1JlY29yZGluZyA9IGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAYXJnIHtDb2RlTWlycm9yfSBjbVxuICAgICAqIEBhcmcge3N0cmluZ30gcmVnaXN0ZXJOYW1lXG4gICAgICovXG4gICAgZW50ZXJNYWNyb1JlY29yZE1vZGUoY20sIHJlZ2lzdGVyTmFtZSkge1xuICAgICAgdmFyIHJlZ2lzdGVyID0gdmltR2xvYmFsU3RhdGUucmVnaXN0ZXJDb250cm9sbGVyLmdldFJlZ2lzdGVyKHJlZ2lzdGVyTmFtZSk7XG4gICAgICBpZiAocmVnaXN0ZXIpIHtcbiAgICAgICAgcmVnaXN0ZXIuY2xlYXIoKTtcbiAgICAgICAgdGhpcy5sYXRlc3RSZWdpc3RlciA9IHJlZ2lzdGVyTmFtZTtcbiAgICAgICAgaWYgKGNtLm9wZW5EaWFsb2cpIHtcbiAgICAgICAgICB2YXIgdGVtcGxhdGUgPSBkb20oJ3NwYW4nLCB7Y2xhc3M6ICdjbS12aW0tbWVzc2FnZSd9LCAncmVjb3JkaW5nIEAnICsgcmVnaXN0ZXJOYW1lKTtcbiAgICAgICAgICB0aGlzLm9uUmVjb3JkaW5nRG9uZSA9IGNtLm9wZW5EaWFsb2codGVtcGxhdGUsIGZ1bmN0aW9uKCkge30sIHtib3R0b206dHJ1ZX0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaXNSZWNvcmRpbmcgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKipcbiAgICogQGFyZyB7Q29kZU1pcnJvcn0gY21cbiAgICogQHJldHVybiB7dmltU3RhdGV9XG4gICAqL1xuICBmdW5jdGlvbiBtYXliZUluaXRWaW1TdGF0ZShjbSkge1xuICAgIGlmICghY20uc3RhdGUudmltKSB7XG4gICAgICAvLyBTdG9yZSBpbnN0YW5jZSBzdGF0ZSBpbiB0aGUgQ29kZU1pcnJvciBvYmplY3QuXG4gICAgICBjbS5zdGF0ZS52aW0gPSB7XG4gICAgICAgIGlucHV0U3RhdGU6IG5ldyBJbnB1dFN0YXRlKCksXG4gICAgICAgIC8vIFZpbSdzIGlucHV0IHN0YXRlIHRoYXQgdHJpZ2dlcmVkIHRoZSBsYXN0IGVkaXQsIHVzZWQgdG8gcmVwZWF0XG4gICAgICAgIC8vIG1vdGlvbnMgYW5kIG9wZXJhdG9ycyB3aXRoICcuJy5cbiAgICAgICAgbGFzdEVkaXRJbnB1dFN0YXRlOiB1bmRlZmluZWQsXG4gICAgICAgIC8vIFZpbSdzIGFjdGlvbiBjb21tYW5kIGJlZm9yZSB0aGUgbGFzdCBlZGl0LCB1c2VkIHRvIHJlcGVhdCBhY3Rpb25zXG4gICAgICAgIC8vIHdpdGggJy4nIGFuZCBpbnNlcnQgbW9kZSByZXBlYXQuXG4gICAgICAgIGxhc3RFZGl0QWN0aW9uQ29tbWFuZDogdW5kZWZpbmVkLFxuICAgICAgICAvLyBXaGVuIHVzaW5nIGprIGZvciBuYXZpZ2F0aW9uLCBpZiB5b3UgbW92ZSBmcm9tIGEgbG9uZ2VyIGxpbmUgdG8gYVxuICAgICAgICAvLyBzaG9ydGVyIGxpbmUsIHRoZSBjdXJzb3IgbWF5IGNsaXAgdG8gdGhlIGVuZCBvZiB0aGUgc2hvcnRlciBsaW5lLlxuICAgICAgICAvLyBJZiBqIGlzIHByZXNzZWQgYWdhaW4gYW5kIGN1cnNvciBnb2VzIHRvIHRoZSBuZXh0IGxpbmUsIHRoZVxuICAgICAgICAvLyBjdXJzb3Igc2hvdWxkIGdvIGJhY2sgdG8gaXRzIGhvcml6b250YWwgcG9zaXRpb24gb24gdGhlIGxvbmdlclxuICAgICAgICAvLyBsaW5lIGlmIGl0IGNhbi4gVGhpcyBpcyB0byBrZWVwIHRyYWNrIG9mIHRoZSBob3Jpem9udGFsIHBvc2l0aW9uLlxuICAgICAgICBsYXN0SFBvczogLTEsXG4gICAgICAgIC8vIERvaW5nIHRoZSBzYW1lIHdpdGggc2NyZWVuLXBvc2l0aW9uIGZvciBnai9na1xuICAgICAgICBsYXN0SFNQb3M6IC0xLFxuICAgICAgICAvLyBUaGUgbGFzdCBtb3Rpb24gY29tbWFuZCBydW4uIENsZWFyZWQgaWYgYSBub24tbW90aW9uIGNvbW1hbmQgZ2V0c1xuICAgICAgICAvLyBleGVjdXRlZCBpbiBiZXR3ZWVuLlxuICAgICAgICBsYXN0TW90aW9uOiBudWxsLFxuICAgICAgICBtYXJrczoge30sXG4gICAgICAgIGluc2VydE1vZGU6IGZhbHNlLFxuICAgICAgICBpbnNlcnRNb2RlUmV0dXJuOiBmYWxzZSxcbiAgICAgICAgLy8gUmVwZWF0IGNvdW50IGZvciBjaGFuZ2VzIG1hZGUgaW4gaW5zZXJ0IG1vZGUsIHRyaWdnZXJlZCBieSBrZXlcbiAgICAgICAgLy8gc2VxdWVuY2VzIGxpa2UgMyxpLiBPbmx5IGV4aXN0cyB3aGVuIGluc2VydE1vZGUgaXMgdHJ1ZS5cbiAgICAgICAgaW5zZXJ0TW9kZVJlcGVhdDogdW5kZWZpbmVkLFxuICAgICAgICB2aXN1YWxNb2RlOiBmYWxzZSxcbiAgICAgICAgLy8gSWYgd2UgYXJlIGluIHZpc3VhbCBsaW5lIG1vZGUuIE5vIGVmZmVjdCBpZiB2aXN1YWxNb2RlIGlzIGZhbHNlLlxuICAgICAgICB2aXN1YWxMaW5lOiBmYWxzZSxcbiAgICAgICAgdmlzdWFsQmxvY2s6IGZhbHNlLFxuICAgICAgICBsYXN0U2VsZWN0aW9uOiAvKipAdHlwZXt2aW1TdGF0ZVtcImxhc3RTZWxlY3Rpb25cIl19Ki8oIC8qKkB0eXBle3Vua25vd259Ki8obnVsbCkpLFxuICAgICAgICBsYXN0UGFzdGVkVGV4dDogdW5kZWZpbmVkLFxuICAgICAgICBzZWw6IHthbmNob3I6IG5ldyBQb3MoMCwgMCksIGhlYWQ6IG5ldyBQb3MoMCwgMCl9LFxuICAgICAgICAvLyBCdWZmZXItbG9jYWwvd2luZG93LWxvY2FsIHZhbHVlcyBvZiB2aW0gb3B0aW9ucy5cbiAgICAgICAgb3B0aW9uczoge30sXG4gICAgICAgIC8vIFdoZXRoZXIgdGhlIG5leHQgY2hhcmFjdGVyIHNob3VsZCBiZSBpbnRlcnByZXRlZCBsaXRlcmFsbHlcbiAgICAgICAgLy8gTmVjYXNzYXJ5IGZvciBjb3JyZWN0IGltcGxlbWVudGF0aW9uIG9mIGY8Y2hhcmFjdGVyPiwgcjxjaGFyYWN0ZXI+IGV0Yy5cbiAgICAgICAgLy8gaW4gdGVybXMgb2YgbGFuZ21hcHMuXG4gICAgICAgIGV4cGVjdExpdGVyYWxOZXh0OiBmYWxzZSxcbiAgICAgICAgc3RhdHVzOiBcIlwiLFxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIGNtLnN0YXRlLnZpbTtcbiAgfVxuICAvKipcbiAgICogQHR5cGUgeyBcbiAgICAgIHtcbiAgICAgICAgbWFjcm9Nb2RlU3RhdGU6IE1hY3JvTW9kZVN0YXRlO1xuICAgICAgICByZWdpc3RlckNvbnRyb2xsZXI6IFJlZ2lzdGVyQ29udHJvbGxlcjtcbiAgICAgICAgc2VhcmNoSGlzdG9yeUNvbnRyb2xsZXI6IEhpc3RvcnlDb250cm9sbGVyO1xuICAgICAgICBqdW1wTGlzdDogUmV0dXJuVHlwZTxjcmVhdGVDaXJjdWxhckp1bXBMaXN0PjtcbiAgICAgICAgZXhDb21tYW5kSGlzdG9yeUNvbnRyb2xsZXI6IEhpc3RvcnlDb250cm9sbGVyOyBcbiAgICAgICAgbGFzdENoYXJhY3RlclNlYXJjaDoge2luY3JlbWVudDogbnVtYmVyLCBmb3J3YXJkOiBib29sZWFuLCBzZWxlY3RlZENoYXJhY3Rlcjogc3RyaW5nfTsgXG4gICAgICAgIHF1ZXJ5PzogYW55O1xuICAgICAgICBpc1JldmVyc2VkPzogYm9vbGVhbjtcbiAgICAgICAgbGFzdFN1YnN0aXR1dGVSZXBsYWNlUGFydDogYW55O1xuICAgICAgICBzZWFyY2hRdWVyeT86IG51bGw7IFxuICAgICAgICBzZWFyY2hJc1JldmVyc2VkPzogYm9vbGVhbjsgXG4gICAgICB9XG4gICAgfVxuICAqL1xuICB2YXIgdmltR2xvYmFsU3RhdGU7XG4gIGZ1bmN0aW9uIHJlc2V0VmltR2xvYmFsU3RhdGUoKSB7XG4gICAgdmltR2xvYmFsU3RhdGUgPSB7XG4gICAgICAvLyBUaGUgY3VycmVudCBzZWFyY2ggcXVlcnkuXG4gICAgICBzZWFyY2hRdWVyeTogbnVsbCxcbiAgICAgIC8vIFdoZXRoZXIgd2UgYXJlIHNlYXJjaGluZyBiYWNrd2FyZHMuXG4gICAgICBzZWFyY2hJc1JldmVyc2VkOiBmYWxzZSxcbiAgICAgIC8vIFJlcGxhY2UgcGFydCBvZiB0aGUgbGFzdCBzdWJzdGl0dXRlZCBwYXR0ZXJuXG4gICAgICBsYXN0U3Vic3RpdHV0ZVJlcGxhY2VQYXJ0OiB1bmRlZmluZWQsXG4gICAgICBqdW1wTGlzdDogY3JlYXRlQ2lyY3VsYXJKdW1wTGlzdCgpLFxuICAgICAgbWFjcm9Nb2RlU3RhdGU6IG5ldyBNYWNyb01vZGVTdGF0ZSgpLFxuICAgICAgLy8gUmVjb3JkaW5nIGxhdGVzdCBmLCB0LCBGIG9yIFQgbW90aW9uIGNvbW1hbmQuXG4gICAgICBsYXN0Q2hhcmFjdGVyU2VhcmNoOiB7aW5jcmVtZW50OjAsIGZvcndhcmQ6dHJ1ZSwgc2VsZWN0ZWRDaGFyYWN0ZXI6Jyd9LFxuICAgICAgcmVnaXN0ZXJDb250cm9sbGVyOiBuZXcgUmVnaXN0ZXJDb250cm9sbGVyKHt9KSxcbiAgICAgIC8vIHNlYXJjaCBoaXN0b3J5IGJ1ZmZlclxuICAgICAgc2VhcmNoSGlzdG9yeUNvbnRyb2xsZXI6IG5ldyBIaXN0b3J5Q29udHJvbGxlcigpLFxuICAgICAgLy8gZXggQ29tbWFuZCBoaXN0b3J5IGJ1ZmZlclxuICAgICAgZXhDb21tYW5kSGlzdG9yeUNvbnRyb2xsZXIgOiBuZXcgSGlzdG9yeUNvbnRyb2xsZXIoKVxuICAgIH07XG4gICAgZm9yICh2YXIgb3B0aW9uTmFtZSBpbiBvcHRpb25zKSB7XG4gICAgICB2YXIgb3B0aW9uID0gb3B0aW9uc1tvcHRpb25OYW1lXTtcbiAgICAgIG9wdGlvbi52YWx1ZSA9IG9wdGlvbi5kZWZhdWx0VmFsdWU7XG4gICAgfVxuICB9XG5cbiAgY2xhc3MgSW5zZXJ0TW9kZUtleSB7XG4gICAgLyoqXG4gICAgICogV3JhcHBlciBmb3Igc3BlY2lhbCBrZXlzIHByZXNzZWQgaW4gaW5zZXJ0IG1vZGVcbiAgICAgKiBAYXJnIHtzdHJpbmd9IGtleU5hbWVcbiAgICAgKiBAYXJnIHtLZXlib2FyZEV2ZW50fSBlXG4gICAgICogQHJldHVybnNcbiAgICAgKi8gICAgXG4gICAgY29uc3RydWN0b3Ioa2V5TmFtZSwgZSkge1xuICAgICAgdGhpcy5rZXlOYW1lID0ga2V5TmFtZTtcbiAgICAgIHRoaXMua2V5ID0gZS5rZXk7XG4gICAgICB0aGlzLmN0cmxLZXkgPSBlLmN0cmxLZXk7XG4gICAgICB0aGlzLmFsdEtleSA9IGUuYWx0S2V5O1xuICAgICAgdGhpcy5tZXRhS2V5ID0gZS5tZXRhS2V5O1xuICAgICAgdGhpcy5zaGlmdEtleSA9IGUuc2hpZnRLZXk7XG4gICAgfVxuICB9XG5cblxuICAvKiogQHR5cGUge251bWJlciB8IHVuZGVmaW5lZHxmYWxzZX0gKi9cbiAgdmFyIGxhc3RJbnNlcnRNb2RlS2V5VGltZXI7XG4gIHZhciB2aW1BcGkgPSB7XG4gICAgZW50ZXJWaW1Nb2RlOiBlbnRlclZpbU1vZGUsXG4gICAgbGVhdmVWaW1Nb2RlOiBsZWF2ZVZpbU1vZGUsXG4gICAgYnVpbGRLZXlNYXA6IGZ1bmN0aW9uKCkge1xuICAgICAgLy8gVE9ETzogQ29udmVydCBrZXltYXAgaW50byBkaWN0aW9uYXJ5IGZvcm1hdCBmb3IgZmFzdCBsb29rdXAuXG4gICAgfSxcbiAgICAvLyBUZXN0aW5nIGhvb2ssIHRob3VnaCBpdCBtaWdodCBiZSB1c2VmdWwgdG8gZXhwb3NlIHRoZSByZWdpc3RlclxuICAgIC8vIGNvbnRyb2xsZXIgYW55d2F5LlxuICAgIGdldFJlZ2lzdGVyQ29udHJvbGxlcjogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdmltR2xvYmFsU3RhdGUucmVnaXN0ZXJDb250cm9sbGVyO1xuICAgIH0sXG4gICAgLy8gVGVzdGluZyBob29rLlxuICAgIHJlc2V0VmltR2xvYmFsU3RhdGVfOiByZXNldFZpbUdsb2JhbFN0YXRlLFxuXG4gICAgLy8gVGVzdGluZyBob29rLlxuICAgIGdldFZpbUdsb2JhbFN0YXRlXzogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdmltR2xvYmFsU3RhdGU7XG4gICAgfSxcblxuICAgIC8vIFRlc3RpbmcgaG9vay5cbiAgICBtYXliZUluaXRWaW1TdGF0ZV86IG1heWJlSW5pdFZpbVN0YXRlLFxuXG4gICAgc3VwcHJlc3NFcnJvckxvZ2dpbmc6IGZhbHNlLFxuXG4gICAgSW5zZXJ0TW9kZUtleTogSW5zZXJ0TW9kZUtleSxcbiAgICAvKipAdHlwZSB7KGxoczogc3RyaW5nLCByaHM6IHN0cmluZywgY3R4OiBzdHJpbmcpID0+IHZvaWR9ICovXG4gICAgbWFwOiBmdW5jdGlvbihsaHMsIHJocywgY3R4KSB7XG4gICAgICAvLyBBZGQgdXNlciBkZWZpbmVkIGtleSBiaW5kaW5ncy5cbiAgICAgIGV4Q29tbWFuZERpc3BhdGNoZXIubWFwKGxocywgcmhzLCBjdHgpO1xuICAgIH0sXG4gICAgLyoqQHR5cGUgeyhsaHM6IHN0cmluZywgY3R4OiBzdHJpbmcpID0+IGFueX0gKi9cbiAgICB1bm1hcDogZnVuY3Rpb24obGhzLCBjdHgpIHtcbiAgICAgIHJldHVybiBleENvbW1hbmREaXNwYXRjaGVyLnVubWFwKGxocywgY3R4KTtcbiAgICB9LFxuICAgIC8vIE5vbi1yZWN1cnNpdmUgbWFwIGZ1bmN0aW9uLlxuICAgIC8vIE5PVEU6IFRoaXMgd2lsbCBub3QgY3JlYXRlIG1hcHBpbmdzIHRvIGtleSBtYXBzIHRoYXQgYXJlbid0IHByZXNlbnRcbiAgICAvLyBpbiB0aGUgZGVmYXVsdCBrZXkgbWFwLiBTZWUgVE9ETyBhdCBib3R0b20gb2YgZnVuY3Rpb24uXG4gICAgLyoqQHR5cGUgeyhsaHM6IHN0cmluZywgcmhzOiBzdHJpbmcsIGN0eDogc3RyaW5nKSA9PiB2b2lkfSAqL1xuICAgIG5vcmVtYXA6IGZ1bmN0aW9uKGxocywgcmhzLCBjdHgpIHtcbiAgICAgIGV4Q29tbWFuZERpc3BhdGNoZXIubWFwKGxocywgcmhzLCBjdHgsIHRydWUpO1xuICAgIH0sXG4gICAgLy8gUmVtb3ZlIGFsbCB1c2VyLWRlZmluZWQgbWFwcGluZ3MgZm9yIHRoZSBwcm92aWRlZCBjb250ZXh0LlxuICAgIC8qKkBhcmcge3N0cmluZ30gW2N0eF19ICovXG4gICAgbWFwY2xlYXI6IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgLy8gUGFydGl0aW9uIHRoZSBleGlzdGluZyBrZXltYXAgaW50byB1c2VyLWRlZmluZWQgYW5kIHRydWUgZGVmYXVsdHMuXG4gICAgICB2YXIgYWN0dWFsTGVuZ3RoID0gZGVmYXVsdEtleW1hcC5sZW5ndGgsXG4gICAgICAgICAgb3JpZ0xlbmd0aCA9IGRlZmF1bHRLZXltYXBMZW5ndGg7XG4gICAgICB2YXIgdXNlcktleW1hcCA9IGRlZmF1bHRLZXltYXAuc2xpY2UoMCwgYWN0dWFsTGVuZ3RoIC0gb3JpZ0xlbmd0aCk7XG4gICAgICBkZWZhdWx0S2V5bWFwID0gZGVmYXVsdEtleW1hcC5zbGljZShhY3R1YWxMZW5ndGggLSBvcmlnTGVuZ3RoKTtcbiAgICAgIGlmIChjdHgpIHtcbiAgICAgICAgLy8gSWYgYSBzcGVjaWZpYyBjb250ZXh0IGlzIGJlaW5nIGNsZWFyZWQsIHdlIG5lZWQgdG8ga2VlcCBtYXBwaW5nc1xuICAgICAgICAvLyBmcm9tIGFsbCBvdGhlciBjb250ZXh0cy5cbiAgICAgICAgZm9yICh2YXIgaSA9IHVzZXJLZXltYXAubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICB2YXIgbWFwcGluZyA9IHVzZXJLZXltYXBbaV07XG4gICAgICAgICAgaWYgKGN0eCAhPT0gbWFwcGluZy5jb250ZXh0KSB7XG4gICAgICAgICAgICBpZiAobWFwcGluZy5jb250ZXh0KSB7XG4gICAgICAgICAgICAgIHRoaXMuX21hcENvbW1hbmQobWFwcGluZyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBgbWFwcGluZ2AgYXBwbGllcyB0byBhbGwgY29udGV4dHMgc28gY3JlYXRlIGtleW1hcCBjb3BpZXNcbiAgICAgICAgICAgICAgLy8gZm9yIGVhY2ggY29udGV4dCBleGNlcHQgdGhlIG9uZSBiZWluZyBjbGVhcmVkLlxuICAgICAgICAgICAgICB2YXIgY29udGV4dHMgPSBbJ25vcm1hbCcsICdpbnNlcnQnLCAndmlzdWFsJ107XG4gICAgICAgICAgICAgIGZvciAodmFyIGogaW4gY29udGV4dHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoY29udGV4dHNbal0gIT09IGN0eCkge1xuICAgICAgICAgICAgICAgICAgdmFyIG5ld01hcHBpbmcgPSBPYmplY3QuYXNzaWduKHt9LCBtYXBwaW5nKTtcbiAgICAgICAgICAgICAgICAgIG5ld01hcHBpbmcuY29udGV4dCA9IGNvbnRleHRzW2pdO1xuICAgICAgICAgICAgICAgICAgdGhpcy5fbWFwQ29tbWFuZChuZXdNYXBwaW5nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGxhbmdtYXA6IHVwZGF0ZUxhbmdtYXAsXG4gICAgdmltS2V5RnJvbUV2ZW50OiB2aW1LZXlGcm9tRXZlbnQsXG4gICAgLy8gVE9ETzogRXhwb3NlIHNldE9wdGlvbiBhbmQgZ2V0T3B0aW9uIGFzIGluc3RhbmNlIG1ldGhvZHMuIE5lZWQgdG8gZGVjaWRlIGhvdyB0byBuYW1lc3BhY2VcbiAgICAvLyB0aGVtLCBvciBzb21laG93IG1ha2UgdGhlbSB3b3JrIHdpdGggdGhlIGV4aXN0aW5nIENvZGVNaXJyb3Igc2V0T3B0aW9uL2dldE9wdGlvbiBBUEkuXG4gICAgc2V0T3B0aW9uOiBzZXRPcHRpb24sXG4gICAgZ2V0T3B0aW9uOiBnZXRPcHRpb24sXG4gICAgZGVmaW5lT3B0aW9uOiBkZWZpbmVPcHRpb24sXG4gICAgLyoqQHR5cGUgeyhuYW1lOiBzdHJpbmcsIHByZWZpeDogc3RyaW5nfHVuZGVmaW5lZCwgZnVuYzogRXhGbikgPT4gdm9pZH0gKi9cbiAgICBkZWZpbmVFeDogZnVuY3Rpb24obmFtZSwgcHJlZml4LCBmdW5jKXtcbiAgICAgIGlmICghcHJlZml4KSB7XG4gICAgICAgIHByZWZpeCA9IG5hbWU7XG4gICAgICB9IGVsc2UgaWYgKG5hbWUuaW5kZXhPZihwcmVmaXgpICE9PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignKFZpbS5kZWZpbmVFeCkgXCInK3ByZWZpeCsnXCIgaXMgbm90IGEgcHJlZml4IG9mIFwiJytuYW1lKydcIiwgY29tbWFuZCBub3QgcmVnaXN0ZXJlZCcpO1xuICAgICAgfVxuICAgICAgZXhDb21tYW5kc1tuYW1lXT1mdW5jO1xuICAgICAgZXhDb21tYW5kRGlzcGF0Y2hlci5jb21tYW5kTWFwX1twcmVmaXhdPXtuYW1lOm5hbWUsIHNob3J0TmFtZTpwcmVmaXgsIHR5cGU6J2FwaSd9O1xuICAgIH0sXG4gICAgLyoqQHR5cGUgeyhjbTogQ29kZU1pcnJvciwga2V5OiBzdHJpbmcsIG9yaWdpbjogc3RyaW5nKSA9PiB1bmRlZmluZWQgfCBib29sZWFufSAqL1xuICAgIGhhbmRsZUtleTogZnVuY3Rpb24gKGNtLCBrZXksIG9yaWdpbikge1xuICAgICAgdmFyIGNvbW1hbmQgPSB0aGlzLmZpbmRLZXkoY20sIGtleSwgb3JpZ2luKTtcbiAgICAgIGlmICh0eXBlb2YgY29tbWFuZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gY29tbWFuZCgpO1xuICAgICAgfVxuICAgIH0sXG4gICAgbXVsdGlTZWxlY3RIYW5kbGVLZXk6IG11bHRpU2VsZWN0SGFuZGxlS2V5LFxuXG4gICAgLyoqXG4gICAgICogVGhpcyBpcyB0aGUgb3V0ZXJtb3N0IGZ1bmN0aW9uIGNhbGxlZCBieSBDb2RlTWlycm9yLCBhZnRlciBrZXlzIGhhdmVcbiAgICAgKiBiZWVuIG1hcHBlZCB0byB0aGVpciBWaW0gZXF1aXZhbGVudHMuXG4gICAgICpcbiAgICAgKiBGaW5kcyBhIGNvbW1hbmQgYmFzZWQgb24gdGhlIGtleSAoYW5kIGNhY2hlZCBrZXlzIGlmIHRoZXJlIGlzIGFcbiAgICAgKiBtdWx0aS1rZXkgc2VxdWVuY2UpLiBSZXR1cm5zIGB1bmRlZmluZWRgIGlmIG5vIGtleSBpcyBtYXRjaGVkLCBhIG5vb3BcbiAgICAgKiBmdW5jdGlvbiBpZiBhIHBhcnRpYWwgbWF0Y2ggaXMgZm91bmQgKG11bHRpLWtleSksIGFuZCBhIGZ1bmN0aW9uIHRvXG4gICAgICogZXhlY3V0ZSB0aGUgYm91bmQgY29tbWFuZCBpZiBhIGEga2V5IGlzIG1hdGNoZWQuIFRoZSBmdW5jdGlvbiBhbHdheXNcbiAgICAgKiByZXR1cm5zIHRydWUuXG4gICAgICovXG4gICAgLyoqQHR5cGUgeyhjbV86IENvZGVNaXJyb3IsIGtleTogc3RyaW5nLCBvcmlnaW4/OiBzdHJpbmd8IHVuZGVmaW5lZCkgPT4gKCgpID0+IGJvb2xlYW58dW5kZWZpbmVkKSB8IHVuZGVmaW5lZH0gKi9cbiAgICBmaW5kS2V5OiBmdW5jdGlvbihjbV8sIGtleSwgb3JpZ2luKSB7XG4gICAgICB2YXIgdmltID0gbWF5YmVJbml0VmltU3RhdGUoY21fKTtcbiAgICAgIHZhciBjbSA9IC8qKkB0eXBlIHtDb2RlTWlycm9yVn0qLyhjbV8pO1xuXG4gICAgICBmdW5jdGlvbiBoYW5kbGVNYWNyb1JlY29yZGluZygpIHtcbiAgICAgICAgdmFyIG1hY3JvTW9kZVN0YXRlID0gdmltR2xvYmFsU3RhdGUubWFjcm9Nb2RlU3RhdGU7XG4gICAgICAgIGlmIChtYWNyb01vZGVTdGF0ZS5pc1JlY29yZGluZykge1xuICAgICAgICAgIGlmIChrZXkgPT0gJ3EnKSB7XG4gICAgICAgICAgICBtYWNyb01vZGVTdGF0ZS5leGl0TWFjcm9SZWNvcmRNb2RlKCk7XG4gICAgICAgICAgICBjbGVhcklucHV0U3RhdGUoY20pO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChvcmlnaW4gIT0gJ21hcHBpbmcnKSB7XG4gICAgICAgICAgICBsb2dLZXkobWFjcm9Nb2RlU3RhdGUsIGtleSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBoYW5kbGVFc2MoKSB7XG4gICAgICAgIGlmIChrZXkgPT0gJzxFc2M+Jykge1xuICAgICAgICAgIGlmICh2aW0udmlzdWFsTW9kZSkge1xuICAgICAgICAgICAgLy8gR2V0IGJhY2sgdG8gbm9ybWFsIG1vZGUuXG4gICAgICAgICAgICBleGl0VmlzdWFsTW9kZShjbSk7XG4gICAgICAgICAgfSBlbHNlIGlmICh2aW0uaW5zZXJ0TW9kZSkge1xuICAgICAgICAgICAgLy8gR2V0IGJhY2sgdG8gbm9ybWFsIG1vZGUuXG4gICAgICAgICAgICBleGl0SW5zZXJ0TW9kZShjbSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFdlJ3JlIGFscmVhZHkgaW4gbm9ybWFsIG1vZGUuIExldCAnPEVzYz4nIGJlIGhhbmRsZWQgbm9ybWFsbHkuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGNsZWFySW5wdXRTdGF0ZShjbSk7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gaGFuZGxlS2V5SW5zZXJ0TW9kZSgpIHtcbiAgICAgICAgaWYgKGhhbmRsZUVzYygpKSB7IHJldHVybiB0cnVlOyB9XG4gICAgICAgIHZpbS5pbnB1dFN0YXRlLmtleUJ1ZmZlci5wdXNoKGtleSk7XG4gICAgICAgIHZhciBrZXlzID0gdmltLmlucHV0U3RhdGUua2V5QnVmZmVyLmpvaW4oXCJcIik7XG4gICAgICAgIHZhciBrZXlzQXJlQ2hhcnMgPSBrZXkubGVuZ3RoID09IDE7XG4gICAgICAgIHZhciBtYXRjaCA9IGNvbW1hbmREaXNwYXRjaGVyLm1hdGNoQ29tbWFuZChrZXlzLCBkZWZhdWx0S2V5bWFwLCB2aW0uaW5wdXRTdGF0ZSwgJ2luc2VydCcpO1xuICAgICAgICB2YXIgY2hhbmdlUXVldWUgPSB2aW0uaW5wdXRTdGF0ZS5jaGFuZ2VRdWV1ZTtcblxuICAgICAgICBpZiAobWF0Y2gudHlwZSA9PSAnbm9uZScpIHsgY2xlYXJJbnB1dFN0YXRlKGNtKTsgcmV0dXJuIGZhbHNlOyB9XG4gICAgICAgIGVsc2UgaWYgKG1hdGNoLnR5cGUgPT0gJ3BhcnRpYWwnKSB7XG4gICAgICAgICAgaWYgKG1hdGNoLmV4cGVjdExpdGVyYWxOZXh0KSB2aW0uZXhwZWN0TGl0ZXJhbE5leHQgPSB0cnVlO1xuICAgICAgICAgIGlmIChsYXN0SW5zZXJ0TW9kZUtleVRpbWVyKSB7IHdpbmRvdy5jbGVhclRpbWVvdXQobGFzdEluc2VydE1vZGVLZXlUaW1lcik7IH1cbiAgICAgICAgICBsYXN0SW5zZXJ0TW9kZUtleVRpbWVyID0ga2V5c0FyZUNoYXJzICYmIHdpbmRvdy5zZXRUaW1lb3V0KFxuICAgICAgICAgICAgZnVuY3Rpb24oKSB7IGlmICh2aW0uaW5zZXJ0TW9kZSAmJiB2aW0uaW5wdXRTdGF0ZS5rZXlCdWZmZXIubGVuZ3RoKSB7IGNsZWFySW5wdXRTdGF0ZShjbSk7IH0gfSxcbiAgICAgICAgICAgIGdldE9wdGlvbignaW5zZXJ0TW9kZUVzY0tleXNUaW1lb3V0JykpO1xuICAgICAgICAgIGlmIChrZXlzQXJlQ2hhcnMpIHtcbiAgICAgICAgICAgIHZhciBzZWxlY3Rpb25zID0gY20ubGlzdFNlbGVjdGlvbnMoKTtcbiAgICAgICAgICAgIGlmICghY2hhbmdlUXVldWUgfHwgY2hhbmdlUXVldWUucmVtb3ZlZC5sZW5ndGggIT0gc2VsZWN0aW9ucy5sZW5ndGgpXG4gICAgICAgICAgICAgIGNoYW5nZVF1ZXVlID0gdmltLmlucHV0U3RhdGUuY2hhbmdlUXVldWUgPSBuZXcgQ2hhbmdlUXVldWU7XG4gICAgICAgICAgICBjaGFuZ2VRdWV1ZS5pbnNlcnRlZCArPSBrZXk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlbGVjdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgdmFyIGZyb20gPSBjdXJzb3JNaW4oc2VsZWN0aW9uc1tpXS5hbmNob3IsIHNlbGVjdGlvbnNbaV0uaGVhZCk7XG4gICAgICAgICAgICAgIHZhciB0byA9IGN1cnNvck1heChzZWxlY3Rpb25zW2ldLmFuY2hvciwgc2VsZWN0aW9uc1tpXS5oZWFkKTtcbiAgICAgICAgICAgICAgdmFyIHRleHQgPSBjbS5nZXRSYW5nZShmcm9tLCBjbS5zdGF0ZS5vdmVyd3JpdGUgPyBvZmZzZXRDdXJzb3IodG8sIDAsIDEpIDogdG8pO1xuICAgICAgICAgICAgICBjaGFuZ2VRdWV1ZS5yZW1vdmVkW2ldID0gKGNoYW5nZVF1ZXVlLnJlbW92ZWRbaV0gfHwgXCJcIikgKyB0ZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gIWtleXNBcmVDaGFycztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChtYXRjaC50eXBlID09ICdmdWxsJykge1xuICAgICAgICAgIHZpbS5pbnB1dFN0YXRlLmtleUJ1ZmZlci5sZW5ndGggPSAwO1xuICAgICAgICB9XG4gICAgICAgIHZpbS5leHBlY3RMaXRlcmFsTmV4dCA9IGZhbHNlO1xuXG4gICAgICAgIGlmIChsYXN0SW5zZXJ0TW9kZUtleVRpbWVyKSB7IHdpbmRvdy5jbGVhclRpbWVvdXQobGFzdEluc2VydE1vZGVLZXlUaW1lcik7IH1cbiAgICAgICAgaWYgKG1hdGNoLmNvbW1hbmQgJiYgY2hhbmdlUXVldWUpIHtcbiAgICAgICAgICB2YXIgc2VsZWN0aW9ucyA9IGNtLmxpc3RTZWxlY3Rpb25zKCk7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWxlY3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgaGVyZSA9IHNlbGVjdGlvbnNbaV0uaGVhZDtcbiAgICAgICAgICAgIGNtLnJlcGxhY2VSYW5nZShjaGFuZ2VRdWV1ZS5yZW1vdmVkW2ldIHx8IFwiXCIsIFxuICAgICAgICAgICAgICBvZmZzZXRDdXJzb3IoaGVyZSwgMCwgLWNoYW5nZVF1ZXVlLmluc2VydGVkLmxlbmd0aCksIGhlcmUsICcraW5wdXQnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmltR2xvYmFsU3RhdGUubWFjcm9Nb2RlU3RhdGUubGFzdEluc2VydE1vZGVDaGFuZ2VzLmNoYW5nZXMucG9wKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFtYXRjaC5jb21tYW5kKSBjbGVhcklucHV0U3RhdGUoY20pO1xuICAgICAgICByZXR1cm4gbWF0Y2guY29tbWFuZDtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gaGFuZGxlS2V5Tm9uSW5zZXJ0TW9kZSgpIHtcbiAgICAgICAgaWYgKGhhbmRsZU1hY3JvUmVjb3JkaW5nKCkgfHwgaGFuZGxlRXNjKCkpIHsgcmV0dXJuIHRydWU7IH1cblxuICAgICAgICB2aW0uaW5wdXRTdGF0ZS5rZXlCdWZmZXIucHVzaChrZXkpO1xuICAgICAgICB2YXIga2V5cyA9IHZpbS5pbnB1dFN0YXRlLmtleUJ1ZmZlci5qb2luKFwiXCIpO1xuICAgICAgICBpZiAoL15bMS05XVxcZCokLy50ZXN0KGtleXMpKSB7IHJldHVybiB0cnVlOyB9XG5cbiAgICAgICAgdmFyIGtleXNNYXRjaGVyID0gL14oXFxkKikoLiopJC8uZXhlYyhrZXlzKTtcbiAgICAgICAgaWYgKCFrZXlzTWF0Y2hlcikgeyBjbGVhcklucHV0U3RhdGUoY20pOyByZXR1cm4gZmFsc2U7IH1cbiAgICAgICAgdmFyIGNvbnRleHQgPSB2aW0udmlzdWFsTW9kZSA/ICd2aXN1YWwnIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnbm9ybWFsJztcbiAgICAgICAgdmFyIG1haW5LZXkgPSBrZXlzTWF0Y2hlclsyXSB8fCBrZXlzTWF0Y2hlclsxXTtcbiAgICAgICAgaWYgKHZpbS5pbnB1dFN0YXRlLm9wZXJhdG9yU2hvcnRjdXQgJiYgdmltLmlucHV0U3RhdGUub3BlcmF0b3JTaG9ydGN1dC5zbGljZSgtMSkgPT0gbWFpbktleSkge1xuICAgICAgICAgIC8vIG11bHRpa2V5IG9wZXJhdG9ycyBhY3QgbGluZXdpc2UgYnkgcmVwZWF0aW5nIG9ubHkgdGhlIGxhc3QgY2hhcmFjdGVyXG4gICAgICAgICAgbWFpbktleSA9IHZpbS5pbnB1dFN0YXRlLm9wZXJhdG9yU2hvcnRjdXQ7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG1hdGNoID0gY29tbWFuZERpc3BhdGNoZXIubWF0Y2hDb21tYW5kKG1haW5LZXksIGRlZmF1bHRLZXltYXAsIHZpbS5pbnB1dFN0YXRlLCBjb250ZXh0KTtcbiAgICAgICAgaWYgKG1hdGNoLnR5cGUgPT0gJ25vbmUnKSB7IGNsZWFySW5wdXRTdGF0ZShjbSk7IHJldHVybiBmYWxzZTsgfVxuICAgICAgICBlbHNlIGlmIChtYXRjaC50eXBlID09ICdwYXJ0aWFsJykge1xuICAgICAgICAgIGlmIChtYXRjaC5leHBlY3RMaXRlcmFsTmV4dCkgdmltLmV4cGVjdExpdGVyYWxOZXh0ID0gdHJ1ZTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChtYXRjaC50eXBlID09ICdjbGVhcicpIHsgY2xlYXJJbnB1dFN0YXRlKGNtKTsgcmV0dXJuIHRydWU7IH1cbiAgICAgICAgdmltLmV4cGVjdExpdGVyYWxOZXh0ID0gZmFsc2U7XG5cbiAgICAgICAgdmltLmlucHV0U3RhdGUua2V5QnVmZmVyLmxlbmd0aCA9IDA7XG4gICAgICAgIGtleXNNYXRjaGVyID0gL14oXFxkKikoLiopJC8uZXhlYyhrZXlzKTtcbiAgICAgICAgaWYgKGtleXNNYXRjaGVyICYmIGtleXNNYXRjaGVyWzFdICYmIGtleXNNYXRjaGVyWzFdICE9ICcwJykge1xuICAgICAgICAgIHZpbS5pbnB1dFN0YXRlLnB1c2hSZXBlYXREaWdpdChrZXlzTWF0Y2hlclsxXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1hdGNoLmNvbW1hbmQ7XG4gICAgICB9XG5cbiAgICAgIHZhciBjb21tYW5kID0gdmltLmluc2VydE1vZGVcbiAgICAgICAgPyBoYW5kbGVLZXlJbnNlcnRNb2RlKClcbiAgICAgICAgOiBoYW5kbGVLZXlOb25JbnNlcnRNb2RlKCk7XG5cbiAgICAgIGlmIChjb21tYW5kID09PSBmYWxzZSkge1xuICAgICAgICByZXR1cm4gIXZpbS5pbnNlcnRNb2RlICYmIChrZXkubGVuZ3RoID09PSAxIHx8IChDTS5pc01hYyAmJiAvPEEtLj4vLnRlc3Qoa2V5KSkpPyBmdW5jdGlvbigpIHsgcmV0dXJuIHRydWU7IH0gOiB1bmRlZmluZWQ7XG4gICAgICB9IGVsc2UgaWYgKGNvbW1hbmQgPT09IHRydWUpIHtcbiAgICAgICAgLy8gVE9ETzogTG9vayBpbnRvIHVzaW5nIENvZGVNaXJyb3IncyBtdWx0aS1rZXkgaGFuZGxpbmcuXG4gICAgICAgIC8vIFJldHVybiBuby1vcCBzaW5jZSB3ZSBhcmUgY2FjaGluZyB0aGUga2V5LiBDb3VudHMgYXMgaGFuZGxlZCwgYnV0XG4gICAgICAgIC8vIGRvbid0IHdhbnQgYWN0IG9uIGl0IGp1c3QgeWV0LlxuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7IHJldHVybiB0cnVlOyB9O1xuICAgICAgfSBlbHNlIGlmIChjb21tYW5kKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gY20ub3BlcmF0aW9uKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgY20uY3VyT3AuaXNWaW1PcCA9IHRydWU7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBpZiAodHlwZW9mIGNvbW1hbmQgIT0gJ29iamVjdCcpIHJldHVybjtcbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIGlmIChjb21tYW5kLnR5cGUgPT0gJ2tleVRvS2V5Jykge1xuICAgICAgICAgICAgICAgIGRvS2V5VG9LZXkoY20sIGNvbW1hbmQudG9LZXlzLCBjb21tYW5kKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb21tYW5kRGlzcGF0Y2hlci5wcm9jZXNzQ29tbWFuZChjbSwgdmltLCBjb21tYW5kKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAvLyBjbGVhciBWSU0gc3RhdGUgaW4gY2FzZSBpdCdzIGluIGEgYmFkIHN0YXRlLlxuICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAgIGNtLnN0YXRlLnZpbSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgbWF5YmVJbml0VmltU3RhdGUoY20pO1xuICAgICAgICAgICAgICBpZiAoIXZpbUFwaS5zdXBwcmVzc0Vycm9yTG9nZ2luZykge1xuICAgICAgICAgICAgICAgIGNvbnNvbGVbJ2xvZyddKGUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9LFxuICAgIC8qKkB0eXBlIHsoY206IENvZGVNaXJyb3JWLCBpbnB1dDogc3RyaW5nKT0+dm9pZH0gKi9cbiAgICBoYW5kbGVFeDogZnVuY3Rpb24oY20sIGlucHV0KSB7XG4gICAgICBleENvbW1hbmREaXNwYXRjaGVyLnByb2Nlc3NDb21tYW5kKGNtLCBpbnB1dCk7XG4gICAgfSxcblxuICAgIGRlZmluZU1vdGlvbjogZGVmaW5lTW90aW9uLFxuICAgIGRlZmluZUFjdGlvbjogZGVmaW5lQWN0aW9uLFxuICAgIGRlZmluZU9wZXJhdG9yOiBkZWZpbmVPcGVyYXRvcixcbiAgICBtYXBDb21tYW5kOiBtYXBDb21tYW5kLFxuICAgIF9tYXBDb21tYW5kOiBfbWFwQ29tbWFuZCxcblxuICAgIGRlZmluZVJlZ2lzdGVyOiBkZWZpbmVSZWdpc3RlcixcblxuICAgIGV4aXRWaXN1YWxNb2RlOiBleGl0VmlzdWFsTW9kZSxcbiAgICBleGl0SW5zZXJ0TW9kZTogZXhpdEluc2VydE1vZGVcbiAgfTtcblxuICB2YXIga2V5VG9LZXlTdGFjayA9IFtdO1xuICB2YXIgbm9yZW1hcCA9IGZhbHNlO1xuICAvKipAdHlwZSB7dW5kZWZpbmVkIHwgbnVsbCB8IGltcG9ydChcIi4vdHlwZXNcIikuUHJvbXB0T3B0aW9uc30gKi9cbiAgdmFyIHZpcnR1YWxQcm9tcHQ7XG4gIC8qKlxuICAgKiBAYXJnIHtzdHJpbmd9IGtleVxuICAgKi9cbiAgZnVuY3Rpb24gc2VuZEtleVRvUHJvbXB0KGtleSkge1xuICAgIGlmICghdmlydHVhbFByb21wdCkgdGhyb3cgbmV3IEVycm9yKCdObyBwcm9tcHQgdG8gc2VuZCBrZXkgdG8nKTtcbiAgICBpZiAoa2V5WzBdID09IFwiPFwiKSB7XG4gICAgICB2YXIgbG93ZXJLZXkgPSBrZXkudG9Mb3dlckNhc2UoKS5zbGljZSgxLCAtMSk7XG4gICAgICB2YXIgcGFydHMgPSBsb3dlcktleS5zcGxpdCgnLScpO1xuICAgICAgbG93ZXJLZXkgPSBwYXJ0cy5wb3AoKSB8fCAnJztcbiAgICAgIGlmIChsb3dlcktleSA9PSAnbHQnKSBrZXkgPSAnPCc7XG4gICAgICBlbHNlIGlmIChsb3dlcktleSA9PSAnc3BhY2UnKSBrZXkgPSAnICc7XG4gICAgICBlbHNlIGlmIChsb3dlcktleSA9PSAnY3InKSBrZXkgPSAnXFxuJztcbiAgICAgIGVsc2UgaWYgKHZpbVRvQ21LZXlNYXBbbG93ZXJLZXldKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHZpcnR1YWxQcm9tcHQudmFsdWUgfHwgXCJcIjtcbiAgICAgICAgdmFyIGV2ZW50ID0gIHtcbiAgICAgICAgICBrZXk6IHZpbVRvQ21LZXlNYXBbbG93ZXJLZXldLFxuICAgICAgICAgIHRhcmdldDoge1xuICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgc2VsZWN0aW9uRW5kOiB2YWx1ZS5sZW5ndGgsXG4gICAgICAgICAgICBzZWxlY3Rpb25TdGFydDogdmFsdWUubGVuZ3RoXG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBpZiAodmlydHVhbFByb21wdC5vbktleURvd24pIHtcbiAgICAgICAgICB2aXJ0dWFsUHJvbXB0Lm9uS2V5RG93bihldmVudCwgdmlydHVhbFByb21wdC52YWx1ZSwgY2xvc2UpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2aXJ0dWFsUHJvbXB0ICYmIHZpcnR1YWxQcm9tcHQub25LZXlVcCkge1xuICAgICAgICAgIHZpcnR1YWxQcm9tcHQub25LZXlVcChldmVudCwgdmlydHVhbFByb21wdC52YWx1ZSwgY2xvc2UpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGtleSA9PSAnXFxuJykge1xuICAgICAgdmFyIHByb21wdCA9IHZpcnR1YWxQcm9tcHQ7XG4gICAgICB2aXJ0dWFsUHJvbXB0ID0gbnVsbDtcbiAgICAgIHByb21wdC5vbkNsb3NlICYmIHByb21wdC5vbkNsb3NlKHByb21wdC52YWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZpcnR1YWxQcm9tcHQudmFsdWUgPSAodmlydHVhbFByb21wdC52YWx1ZSB8fCAnJykgKyBrZXk7XG4gICAgfVxuXG4gICAgLyoqIEBwYXJhbSB7c3RyaW5nIHwgdW5kZWZpbmVkfSB2YWx1ZSAqL1xuICAgIGZ1bmN0aW9uIGNsb3NlKHZhbHVlKSB7XG4gICAgICBpZiAoIXZpcnR1YWxQcm9tcHQpIHJldHVybjtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycpIHsgdmlydHVhbFByb21wdC52YWx1ZSA9IHZhbHVlOyB9XG4gICAgICBlbHNlIHsgdmlydHVhbFByb21wdCA9IG51bGw7IH1cbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEBhcmcge0NvZGVNaXJyb3JWfSBjbVxuICAgKiBAYXJnIHtzdHJpbmd9IGtleXNcbiAgICogQGFyZyB7dmltS2V5fGltcG9ydChcIi4vdHlwZXNcIikuZXhDb21tYW5kRGVmaW5pdGlvbnx7bm9yZW1hcD86IGJvb2xlYW59fSBbZnJvbUtleV1cbiAgICovXG4gIGZ1bmN0aW9uIGRvS2V5VG9LZXkoY20sIGtleXMsIGZyb21LZXkpIHtcbiAgICB2YXIgbm9yZW1hcEJlZm9yZSA9IG5vcmVtYXA7XG4gICAgLy8gcHJldmVudCBpbmZpbml0ZSByZWN1cnNpb24uXG4gICAgaWYgKGZyb21LZXkpIHtcbiAgICAgIGlmIChrZXlUb0tleVN0YWNrLmluZGV4T2YoZnJvbUtleSkgIT0gLTEpIHJldHVybjtcbiAgICAgIGtleVRvS2V5U3RhY2sucHVzaChmcm9tS2V5KTtcbiAgICAgIG5vcmVtYXAgPSBmcm9tS2V5Lm5vcmVtYXAgIT0gZmFsc2U7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIHZhciB2aW0gPSBtYXliZUluaXRWaW1TdGF0ZShjbSk7XG4gICAgICB2YXIga2V5UmUgPSAvPCg/OltDU01BXS0pKlxcdys+fC4vZ2k7XG5cbiAgICAgIHZhciBtYXRjaDtcbiAgICAgIC8vIFB1bGwgb2ZmIG9uZSBjb21tYW5kIGtleSwgd2hpY2ggaXMgZWl0aGVyIGEgc2luZ2xlIGNoYXJhY3RlclxuICAgICAgLy8gb3IgYSBzcGVjaWFsIHNlcXVlbmNlIHdyYXBwZWQgaW4gJzwnIGFuZCAnPicsIGUuZy4gJzxTcGFjZT4nLlxuICAgICAgd2hpbGUgKChtYXRjaCA9IGtleVJlLmV4ZWMoa2V5cykpKSB7XG4gICAgICAgIHZhciBrZXkgPSBtYXRjaFswXTtcbiAgICAgICAgdmFyIHdhc0luc2VydCA9IHZpbS5pbnNlcnRNb2RlO1xuICAgICAgICBpZiAodmlydHVhbFByb21wdCkge1xuICAgICAgICAgIHNlbmRLZXlUb1Byb21wdChrZXkpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJlc3VsdCA9IHZpbUFwaS5oYW5kbGVLZXkoY20sIGtleSwgJ21hcHBpbmcnKTtcblxuICAgICAgICBpZiAoIXJlc3VsdCAmJiB3YXNJbnNlcnQgJiYgdmltLmluc2VydE1vZGUpIHtcbiAgICAgICAgICBpZiAoa2V5WzBdID09IFwiPFwiKSB7XG4gICAgICAgICAgICB2YXIgbG93ZXJLZXkgPSBrZXkudG9Mb3dlckNhc2UoKS5zbGljZSgxLCAtMSk7XG4gICAgICAgICAgICB2YXIgcGFydHMgPSBsb3dlcktleS5zcGxpdCgnLScpO1xuICAgICAgICAgICAgbG93ZXJLZXkgPSBwYXJ0cy5wb3AoKSB8fCAnJztcbiAgICAgICAgICAgIGlmIChsb3dlcktleSA9PSAnbHQnKSBrZXkgPSAnPCc7XG4gICAgICAgICAgICBlbHNlIGlmIChsb3dlcktleSA9PSAnc3BhY2UnKSBrZXkgPSAnICc7XG4gICAgICAgICAgICBlbHNlIGlmIChsb3dlcktleSA9PSAnY3InKSBrZXkgPSAnXFxuJztcbiAgICAgICAgICAgIGVsc2UgaWYgKHZpbVRvQ21LZXlNYXAuaGFzT3duUHJvcGVydHkobG93ZXJLZXkpKSB7XG4gICAgICAgICAgICAgIC8vIHRvZG8gc3VwcG9ydCBjb2RlbWlycm9yIGtleXMgaW4gaW5zZXJ0bW9kZSB2aW1Ub0NtS2V5TWFwXG4gICAgICAgICAgICAgIGtleSA9IHZpbVRvQ21LZXlNYXBbbG93ZXJLZXldO1xuICAgICAgICAgICAgICBzZW5kQ21LZXkoY20sIGtleSk7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAga2V5ID0ga2V5WzBdO1xuICAgICAgICAgICAgICBrZXlSZS5sYXN0SW5kZXggPSBtYXRjaC5pbmRleCArIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGNtLnJlcGxhY2VTZWxlY3Rpb24oa2V5KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZmluYWxseSB7XG4gICAgICBrZXlUb0tleVN0YWNrLnBvcCgpO1xuICAgICAgbm9yZW1hcCA9IGtleVRvS2V5U3RhY2subGVuZ3RoID8gbm9yZW1hcEJlZm9yZSA6IGZhbHNlO1xuICAgICAgaWYgKCFrZXlUb0tleVN0YWNrLmxlbmd0aCAmJiB2aXJ0dWFsUHJvbXB0KSB7XG4gICAgICAgIHZhciBwcm9tcHRPcHRpb25zID0gdmlydHVhbFByb21wdDtcbiAgICAgICAgdmlydHVhbFByb21wdCA9IG51bGw7XG4gICAgICAgIHNob3dQcm9tcHQoY20sIHByb21wdE9wdGlvbnMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKkB0eXBle1JlY29yZDxzdHJpbmcsIHN0cmluZz59ICovXG4gIHZhciBzcGVjaWFsS2V5ID0ge1xuICAgIFJldHVybjogJ0NSJywgQmFja3NwYWNlOiAnQlMnLCAnRGVsZXRlJzogJ0RlbCcsIEVzY2FwZTogJ0VzYycsIEluc2VydDogJ0lucycsXG4gICAgQXJyb3dMZWZ0OiAnTGVmdCcsIEFycm93UmlnaHQ6ICdSaWdodCcsIEFycm93VXA6ICdVcCcsIEFycm93RG93bjogJ0Rvd24nLFxuICAgIEVudGVyOiAnQ1InLCAnICc6ICdTcGFjZSdcbiAgfTtcbiAgdmFyIGlnbm9yZWRLZXlzID0geyBTaGlmdDogMSwgQWx0OiAxLCBDb21tYW5kOiAxLCBDb250cm9sOiAxLFxuICAgIENhcHNMb2NrOiAxLCBBbHRHcmFwaDogMSwgRGVhZDogMSwgVW5pZGVudGlmaWVkOiAxIH07XG5cbiAgdmFyIHZpbVRvQ21LZXlNYXAgPSB7fTtcbiAgJ0xlZnR8UmlnaHR8VXB8RG93bnxFbmR8SG9tZScuc3BsaXQoJ3wnKS5jb25jYXQoT2JqZWN0LmtleXMoc3BlY2lhbEtleSkpLmZvckVhY2goZnVuY3Rpb24oeCkge1xuICAgIHZpbVRvQ21LZXlNYXBbKHNwZWNpYWxLZXlbeF0gfHwgJycpLnRvTG93ZXJDYXNlKCldXG4gICAgICAgID0gdmltVG9DbUtleU1hcFt4LnRvTG93ZXJDYXNlKCldID0geDtcbiAgfSk7XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7S2V5Ym9hcmRFdmVudH0gZVxuICAgKiBAcGFyYW0ge3ZpbVN0YXRlfSBbdmltXVxuICAgKi9cbiAgZnVuY3Rpb24gdmltS2V5RnJvbUV2ZW50KGUsIHZpbSkge1xuICAgIHZhciBrZXkgPSBlLmtleTtcbiAgICBpZiAoaWdub3JlZEtleXNba2V5XSkgcmV0dXJuO1xuICAgIGlmIChrZXkubGVuZ3RoID4gMSAmJiBrZXlbMF0gPT0gXCJuXCIpIHtcbiAgICAgIGtleSA9IGtleS5yZXBsYWNlKFwiTnVtcGFkXCIsIFwiXCIpO1xuICAgIH1cbiAgICBrZXkgPSBzcGVjaWFsS2V5W2tleV0gfHwga2V5O1xuXG4gICAgdmFyIG5hbWUgPSAnJztcbiAgICBpZiAoZS5jdHJsS2V5KSB7IG5hbWUgKz0gJ0MtJzsgfVxuICAgIGlmIChlLmFsdEtleSkgeyBuYW1lICs9ICdBLSc7IH1cbiAgICBpZiAoZS5tZXRhS2V5KSB7IG5hbWUgKz0gJ00tJzsgfVxuICAgIC8vIG9uIG1hYyBtYW55IGNoYXJhY3RlcnMgYXJlIGVudGVyZWQgYXMgb3B0aW9uLSBjb21ib3NcbiAgICAvLyAoZS5nLiBvbiBzd2lzcyBrZXlib2FyZCB7IGlzIG9wdGlvbi04KVxuICAgIC8vIHNvIHdlIGlnbm9yZSBsb25lbHkgQS0gbW9kaWZpZXIgZm9yIGtleXByZXNzIGV2ZW50IG9uIG1hY1xuICAgIGlmIChDTS5pc01hYyAmJiBuYW1lID09IFwiQS1cIiAmJiBrZXkubGVuZ3RoID09IDEpIHtcbiAgICAgIG5hbWUgPSBuYW1lLnNsaWNlKDIpO1xuICAgIH1cbiAgICBpZiAoKG5hbWUgfHwga2V5Lmxlbmd0aCA+IDEpICYmIGUuc2hpZnRLZXkpIHsgbmFtZSArPSAnUy0nOyB9XG5cbiAgICBpZiAodmltICYmICF2aW0uZXhwZWN0TGl0ZXJhbE5leHQgJiYga2V5Lmxlbmd0aCA9PSAxKSB7XG4gICAgICBpZiAobGFuZ21hcC5rZXltYXAgJiYga2V5IGluIGxhbmdtYXAua2V5bWFwKSB7XG4gICAgICAgIGlmIChsYW5nbWFwLnJlbWFwQ3RybCAhPSBmYWxzZSB8fCAhbmFtZSlcbiAgICAgICAgICBrZXkgPSBsYW5nbWFwLmtleW1hcFtrZXldO1xuICAgICAgfSBlbHNlIGlmIChrZXkuY2hhckNvZGVBdCgwKSA+IDEyOCkge1xuICAgICAgICBpZiAoIXVzZWRLZXlzW2tleV0pIHtcbiAgICAgICAgICB2YXIgY29kZSA9IGUuY29kZT8uc2xpY2UoLTEpIHx8IFwiXCI7XG4gICAgICAgICAgaWYgKCFlLnNoaWZ0S2V5KSBjb2RlID0gY29kZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgIGlmIChjb2RlKSB7XG4gICAgICAgICAgICBrZXkgPSBjb2RlO1xuICAgICAgICAgICAgLy8gYWxzbyByZXN0b3JlIEEtIGZvciBtYWNcbiAgICAgICAgICAgIGlmICghbmFtZSAmJiBlLmFsdEtleSkgbmFtZSA9ICdBLSc7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgbmFtZSArPSBrZXk7XG4gICAgaWYgKG5hbWUubGVuZ3RoID4gMSkgeyBuYW1lID0gJzwnICsgbmFtZSArICc+JzsgfVxuICAgIHJldHVybiBuYW1lO1xuICB9XG4gIC8vIGxhbmdtYXAgc3VwcG9ydFxuICBmdW5jdGlvbiB1cGRhdGVMYW5nbWFwKGxhbmdtYXBTdHJpbmcsIHJlbWFwQ3RybCkge1xuICAgIGlmIChsYW5nbWFwLnN0cmluZyAhPT0gbGFuZ21hcFN0cmluZykge1xuICAgICAgbGFuZ21hcCA9IHBhcnNlTGFuZ21hcChsYW5nbWFwU3RyaW5nKTtcbiAgICB9XG4gICAgbGFuZ21hcC5yZW1hcEN0cmwgPSByZW1hcEN0cmw7XG4gIH1cbiAgLyoqIFxuICAgKiAgRnJvbSA6aGVscCBsYW5nbWFwXG4gICAqICBUaGUgJ2xhbmdtYXAnIG9wdGlvbiBpcyBhIGxpc3Qgb2YgcGFydHMsIHNlcGFyYXRlZCB3aXRoIGNvbW1hcy4gIEVhY2hcbiAgICogICAgICBwYXJ0IGNhbiBiZSBpbiBvbmUgb2YgdHdvIGZvcm1zOlxuICAgKiAgICAgIDEuICBBIGxpc3Qgb2YgcGFpcnMuICBFYWNoIHBhaXIgaXMgYSBcImZyb21cIiBjaGFyYWN0ZXIgaW1tZWRpYXRlbHlcbiAgICogICAgICAgICAgZm9sbG93ZWQgYnkgdGhlIFwidG9cIiBjaGFyYWN0ZXIuICBFeGFtcGxlczogXCJhQVwiLCBcImFBYkJjQ1wiLlxuICAgKiAgICAgIDIuICBBIGxpc3Qgb2YgXCJmcm9tXCIgY2hhcmFjdGVycywgYSBzZW1pLWNvbG9uIGFuZCBhIGxpc3Qgb2YgXCJ0b1wiXG4gICAqICAgICAgICAgIGNoYXJhY3RlcnMuICBFeGFtcGxlOiBcImFiYztBQkNcIlxuICAgKiBAYXJnIHtzdHJpbmd9IGxhbmdtYXBTdHJpbmdcbiAgICogQHJldHVybnMge3tzdHJpbmc6IHN0cmluZywga2V5bWFwOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+LCByZW1hcEN0cmw/OiBib29sZWFufX1cbiAgICovXG4gIGZ1bmN0aW9uIHBhcnNlTGFuZ21hcChsYW5nbWFwU3RyaW5nKSB7XG4gICAgbGV0IGtleW1hcCA9ICh7fSkvKipAdHlwZSB7UmVjb3JkPHN0cmluZywgc3RyaW5nPn0qLztcbiAgICBpZiAoIWxhbmdtYXBTdHJpbmcpIHJldHVybiB7IGtleW1hcDoga2V5bWFwLCBzdHJpbmc6ICcnIH07XG5cbiAgICAvKiogQGFyZyB7c3RyaW5nfSBsaXN0ICovXG4gICAgZnVuY3Rpb24gZ2V0RXNjYXBlZChsaXN0KSB7XG4gICAgICByZXR1cm4gbGlzdC5zcGxpdCgvXFxcXD8oLikvKS5maWx0ZXIoQm9vbGVhbik7XG4gICAgfVxuICAgIGxhbmdtYXBTdHJpbmcuc3BsaXQoLygoPzpbXlxcXFwsXXxcXFxcLikrKSwvKS5tYXAocGFydCA9PiB7XG4gICAgICBpZiAoIXBhcnQpIHJldHVybjtcbiAgICAgIGNvbnN0IHNlbWljb2xvbiA9IHBhcnQuc3BsaXQoLygoPzpbXlxcXFw7XXxcXFxcLikrKTsvKTtcbiAgICAgIGlmIChzZW1pY29sb24ubGVuZ3RoID09IDMpIHtcbiAgICAgICAgY29uc3QgZnJvbSA9IGdldEVzY2FwZWQoc2VtaWNvbG9uWzFdKTtcbiAgICAgICAgY29uc3QgdG8gPSBnZXRFc2NhcGVkKHNlbWljb2xvblsyXSk7XG4gICAgICAgIGlmIChmcm9tLmxlbmd0aCAhPT0gdG8ubGVuZ3RoKSByZXR1cm47IC8vIHNraXAgb3ZlciBtYWxmb3JtZWQgcGFydFxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZyb20ubGVuZ3RoOyArK2kpIGtleW1hcFtmcm9tW2ldXSA9IHRvW2ldO1xuICAgICAgfSBlbHNlIGlmIChzZW1pY29sb24ubGVuZ3RoID09IDEpIHtcbiAgICAgICAgY29uc3QgcGFpcnMgPSBnZXRFc2NhcGVkKHBhcnQpO1xuICAgICAgICBpZiAocGFpcnMubGVuZ3RoICUgMiAhPT0gMCkgcmV0dXJuOyAvLyBza2lwIG92ZXIgbWFsZm9ybWVkIHBhcnRcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYWlycy5sZW5ndGg7IGkgKz0gMikga2V5bWFwW3BhaXJzW2ldXSA9IHBhaXJzW2kgKyAxXTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiB7IGtleW1hcDoga2V5bWFwLCBzdHJpbmc6IGxhbmdtYXBTdHJpbmcgfTtcbiAgfVxuXG4gIGRlZmluZU9wdGlvbignbGFuZ21hcCcsIHVuZGVmaW5lZCwgJ3N0cmluZycsIFsnbG1hcCddLCBmdW5jdGlvbihuYW1lLCBjbSkge1xuICAgIC8vIFRoZSAnZmlsZXR5cGUnIG9wdGlvbiBwcm94aWVzIHRvIHRoZSBDb2RlTWlycm9yICdtb2RlJyBvcHRpb24uXG4gICAgaWYgKG5hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGxhbmdtYXAuc3RyaW5nO1xuICAgIH0gZWxzZSB7XG4gICAgICB1cGRhdGVMYW5nbWFwKG5hbWUpO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gUmVwcmVzZW50cyB0aGUgY3VycmVudCBpbnB1dCBzdGF0ZS5cbiAgLyoqQGltcGxlbWVudHMge0lucHV0U3RhdGVJbnRlcmZhY2V9ICovXG4gIGNsYXNzIElucHV0U3RhdGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgLyoqQHR5cGV7SW5wdXRTdGF0ZUludGVyZmFjZVtcInByZWZpeFJlcGVhdFwiXX0gKi9cbiAgICAgIHRoaXMucHJlZml4UmVwZWF0ID0gW107XG4gICAgICAvKipAdHlwZXtJbnB1dFN0YXRlSW50ZXJmYWNlW1wibW90aW9uUmVwZWF0XCJdfSAqL1xuICAgICAgdGhpcy5tb3Rpb25SZXBlYXQgPSBbXTtcbiAgICAgIC8qKkB0eXBle0lucHV0U3RhdGVJbnRlcmZhY2VbXCJvcGVyYXRvclwiXX0gKi9cbiAgICAgIHRoaXMub3BlcmF0b3IgPSBudWxsO1xuICAgICAgLyoqQHR5cGV7SW5wdXRTdGF0ZUludGVyZmFjZVtcIm9wZXJhdG9yQXJnc1wiXX0gKi9cbiAgICAgIHRoaXMub3BlcmF0b3JBcmdzID0gbnVsbDtcbiAgICAgIC8qKkB0eXBle0lucHV0U3RhdGVJbnRlcmZhY2VbXCJtb3Rpb25cIl19ICovXG4gICAgICB0aGlzLm1vdGlvbiA9IG51bGw7XG4gICAgICAvKipAdHlwZXtJbnB1dFN0YXRlSW50ZXJmYWNlW1wibW90aW9uQXJnc1wiXX0gKi9cbiAgICAgIHRoaXMubW90aW9uQXJncyA9IG51bGw7XG4gICAgICAvKipAdHlwZXtJbnB1dFN0YXRlSW50ZXJmYWNlW1wia2V5QnVmZmVyXCJdfSAqL1xuICAgICAgdGhpcy5rZXlCdWZmZXIgPSBbXTsgLy8gRm9yIG1hdGNoaW5nIG11bHRpLWtleSBjb21tYW5kcy5cbiAgICAgIC8qKkB0eXBle0lucHV0U3RhdGVJbnRlcmZhY2VbXCJyZWdpc3Rlck5hbWVcIl19ICovXG4gICAgICB0aGlzLnJlZ2lzdGVyTmFtZSA9IHVuZGVmaW5lZDsgLy8gRGVmYXVsdHMgdG8gdGhlIHVubmFtZWQgcmVnaXN0ZXIuXG4gICAgICAvKipAdHlwZXtJbnB1dFN0YXRlSW50ZXJmYWNlW1wiY2hhbmdlUXVldWVcIl19ICovXG4gICAgICB0aGlzLmNoYW5nZVF1ZXVlID0gbnVsbDsgLy8gRm9yIHJlc3RvcmluZyB0ZXh0IHVzZWQgYnkgaW5zZXJ0IG1vZGUga2V5YmluZGluZ3NcbiAgICB9XG4gICAgLyoqIEBwYXJhbSB7c3RyaW5nfSBuICovXG4gICAgcHVzaFJlcGVhdERpZ2l0KG4pIHtcbiAgICAgIGlmICghdGhpcy5vcGVyYXRvcikge1xuICAgICAgICB0aGlzLnByZWZpeFJlcGVhdCA9IHRoaXMucHJlZml4UmVwZWF0LmNvbmNhdChuKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMubW90aW9uUmVwZWF0ID0gdGhpcy5tb3Rpb25SZXBlYXQuY29uY2F0KG4pO1xuICAgICAgfVxuICAgIH1cbiAgICBnZXRSZXBlYXQoKSB7XG4gICAgICB2YXIgcmVwZWF0ID0gMDtcbiAgICAgIGlmICh0aGlzLnByZWZpeFJlcGVhdC5sZW5ndGggPiAwIHx8IHRoaXMubW90aW9uUmVwZWF0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgcmVwZWF0ID0gMTtcbiAgICAgICAgaWYgKHRoaXMucHJlZml4UmVwZWF0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICByZXBlYXQgKj0gcGFyc2VJbnQodGhpcy5wcmVmaXhSZXBlYXQuam9pbignJyksIDEwKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5tb3Rpb25SZXBlYXQubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHJlcGVhdCAqPSBwYXJzZUludCh0aGlzLm1vdGlvblJlcGVhdC5qb2luKCcnKSwgMTApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVwZWF0O1xuICAgIH1cbiAgfVxuXG4gIC8qKiBAYXJnIHtDb2RlTWlycm9yVn0gY20gIEBhcmcge3N0cmluZ30gW3JlYXNvbl0gKi9cbiAgZnVuY3Rpb24gY2xlYXJJbnB1dFN0YXRlKGNtLCByZWFzb24pIHtcbiAgICBjbS5zdGF0ZS52aW0uaW5wdXRTdGF0ZSA9IG5ldyBJbnB1dFN0YXRlKCk7XG4gICAgY20uc3RhdGUudmltLmV4cGVjdExpdGVyYWxOZXh0ID0gZmFsc2U7XG4gICAgQ00uc2lnbmFsKGNtLCAndmltLWNvbW1hbmQtZG9uZScsIHJlYXNvbik7XG4gIH1cblxuICBmdW5jdGlvbiBDaGFuZ2VRdWV1ZSgpIHtcbiAgICB0aGlzLnJlbW92ZWQgPSBbXTtcbiAgICB0aGlzLmluc2VydGVkID0gXCJcIjtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWdpc3RlciBzdG9yZXMgaW5mb3JtYXRpb24gYWJvdXQgY29weSBhbmQgcGFzdGUgcmVnaXN0ZXJzLiAgQmVzaWRlc1xuICAgKiB0ZXh0LCBhIHJlZ2lzdGVyIG11c3Qgc3RvcmUgd2hldGhlciBpdCBpcyBsaW5ld2lzZSAoaS5lLiwgd2hlbiBpdCBpc1xuICAgKiBwYXN0ZWQsIHNob3VsZCBpdCBpbnNlcnQgaXRzZWxmIGludG8gYSBuZXcgbGluZSwgb3Igc2hvdWxkIHRoZSB0ZXh0IGJlXG4gICAqIGluc2VydGVkIGF0IHRoZSBjdXJzb3IgcG9zaXRpb24uKVxuICAgKi9cbiAgY2xhc3MgUmVnaXN0ZXIge1xuICAgIC8qKiBAYXJnIHtzdHJpbmd9IFt0ZXh0XSBAYXJnIHtib29sZWFufSBbbGluZXdpc2VdIEBhcmcge2Jvb2xlYW4gfSBbYmxvY2t3aXNlXSAqL1xuICAgIGNvbnN0cnVjdG9yKHRleHQsIGxpbmV3aXNlLCBibG9ja3dpc2UpIHtcbiAgICAgIHRoaXMuY2xlYXIoKTtcbiAgICAgIHRoaXMua2V5QnVmZmVyID0gW3RleHQgfHwgJyddO1xuICAgICAgLyoqIEB0eXBlIHtJbnNlcnRNb2RlQ2hhbmdlc1tdfSAqL1xuICAgICAgdGhpcy5pbnNlcnRNb2RlQ2hhbmdlcyA9IFtdO1xuICAgICAgLyoqIEB0eXBlIHtzdHJpbmdbXX0qL1xuICAgICAgdGhpcy5zZWFyY2hRdWVyaWVzID0gW107XG4gICAgICB0aGlzLmxpbmV3aXNlID0gISFsaW5ld2lzZTtcbiAgICAgIHRoaXMuYmxvY2t3aXNlID0gISFibG9ja3dpc2U7XG4gICAgfVxuICAgIC8qKiBAYXJnIHtzdHJpbmd9IFt0ZXh0XSBAYXJnIHtib29sZWFufSBbbGluZXdpc2VdIEBhcmcge2Jvb2xlYW4gfSBbYmxvY2t3aXNlXSAqL1xuICAgIHNldFRleHQodGV4dCwgbGluZXdpc2UsIGJsb2Nrd2lzZSkge1xuICAgICAgdGhpcy5rZXlCdWZmZXIgPSBbdGV4dCB8fCAnJ107XG4gICAgICB0aGlzLmxpbmV3aXNlID0gISFsaW5ld2lzZTtcbiAgICAgIHRoaXMuYmxvY2t3aXNlID0gISFibG9ja3dpc2U7XG4gICAgfVxuICAgIC8qKiBAYXJnIHtzdHJpbmd9IHRleHQgQGFyZyB7Ym9vbGVhbn0gW2xpbmV3aXNlXSAqL1xuICAgIHB1c2hUZXh0KHRleHQsIGxpbmV3aXNlKSB7XG4gICAgICAvLyBpZiB0aGlzIHJlZ2lzdGVyIGhhcyBldmVyIGJlZW4gc2V0IHRvIGxpbmV3aXNlLCB1c2UgbGluZXdpc2UuXG4gICAgICBpZiAobGluZXdpc2UpIHtcbiAgICAgICAgaWYgKCF0aGlzLmxpbmV3aXNlKSB7XG4gICAgICAgICAgdGhpcy5rZXlCdWZmZXIucHVzaCgnXFxuJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5saW5ld2lzZSA9IHRydWU7XG4gICAgICB9XG4gICAgICB0aGlzLmtleUJ1ZmZlci5wdXNoKHRleHQpO1xuICAgIH1cbiAgICAvKiogQGFyZyB7SW5zZXJ0TW9kZUNoYW5nZXN9IGNoYW5nZXMgKi9cbiAgICBwdXNoSW5zZXJ0TW9kZUNoYW5nZXMoY2hhbmdlcykge1xuICAgICAgdGhpcy5pbnNlcnRNb2RlQ2hhbmdlcy5wdXNoKGNyZWF0ZUluc2VydE1vZGVDaGFuZ2VzKGNoYW5nZXMpKTtcbiAgICB9XG4gICAgLyoqIEBhcmcge3N0cmluZ30gcXVlcnkgKi9cbiAgICBwdXNoU2VhcmNoUXVlcnkocXVlcnkpIHtcbiAgICAgIHRoaXMuc2VhcmNoUXVlcmllcy5wdXNoKHF1ZXJ5KTtcbiAgICB9XG4gICAgY2xlYXIoKSB7XG4gICAgICB0aGlzLmtleUJ1ZmZlciA9IFtdO1xuICAgICAgdGhpcy5pbnNlcnRNb2RlQ2hhbmdlcyA9IFtdO1xuICAgICAgdGhpcy5zZWFyY2hRdWVyaWVzID0gW107XG4gICAgICB0aGlzLmxpbmV3aXNlID0gZmFsc2U7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgcmV0dXJuIHRoaXMua2V5QnVmZmVyLmpvaW4oJycpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBEZWZpbmVzIGFuIGV4dGVybmFsIHJlZ2lzdGVyLlxuICAgKlxuICAgKiBUaGUgbmFtZSBzaG91bGQgYmUgYSBzaW5nbGUgY2hhcmFjdGVyIHRoYXQgd2lsbCBiZSB1c2VkIHRvIHJlZmVyZW5jZSB0aGUgcmVnaXN0ZXIuXG4gICAqIFRoZSByZWdpc3RlciBzaG91bGQgc3VwcG9ydCBzZXRUZXh0LCBwdXNoVGV4dCwgY2xlYXIsIGFuZCB0b1N0cmluZygpLiBTZWUgUmVnaXN0ZXJcbiAgICogZm9yIGEgcmVmZXJlbmNlIGltcGxlbWVudGF0aW9uLlxuICAgKiBAYXJnIHtzdHJpbmd9IG5hbWVcbiAgICogQGFyZyB7UmVnaXN0ZXJ9IHJlZ2lzdGVyXG4gICAqL1xuICBmdW5jdGlvbiBkZWZpbmVSZWdpc3RlcihuYW1lLCByZWdpc3Rlcikge1xuICAgIHZhciByZWdpc3RlcnMgPSB2aW1HbG9iYWxTdGF0ZS5yZWdpc3RlckNvbnRyb2xsZXIucmVnaXN0ZXJzO1xuICAgIGlmICghbmFtZSB8fCBuYW1lLmxlbmd0aCAhPSAxKSB7XG4gICAgICB0aHJvdyBFcnJvcignUmVnaXN0ZXIgbmFtZSBtdXN0IGJlIDEgY2hhcmFjdGVyJyk7XG4gICAgfVxuICAgIGlmIChyZWdpc3RlcnNbbmFtZV0pIHtcbiAgICAgIHRocm93IEVycm9yKCdSZWdpc3RlciBhbHJlYWR5IGRlZmluZWQgJyArIG5hbWUpO1xuICAgIH1cbiAgICByZWdpc3RlcnNbbmFtZV0gPSByZWdpc3RlcjtcbiAgICB2YWxpZFJlZ2lzdGVycy5wdXNoKG5hbWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIHZpbSByZWdpc3RlcnMgYWxsb3cgeW91IHRvIGtlZXAgbWFueSBpbmRlcGVuZGVudCBjb3B5IGFuZCBwYXN0ZSBidWZmZXJzLlxuICAgKiBTZWUgaHR0cDovL3VzZXZpbS5jb20vMjAxMi8wNC8xMy9yZWdpc3RlcnMvIGZvciBhbiBpbnRyb2R1Y3Rpb24uXG4gICAqXG4gICAqIFJlZ2lzdGVyQ29udHJvbGxlciBrZWVwcyB0aGUgc3RhdGUgb2YgYWxsIHRoZSByZWdpc3RlcnMuICBBbiBpbml0aWFsXG4gICAqIHN0YXRlIG1heSBiZSBwYXNzZWQgaW4uICBUaGUgdW5uYW1lZCByZWdpc3RlciAnXCInIHdpbGwgYWx3YXlzIGJlXG4gICAqIG92ZXJyaWRkZW4uXG4gICAqL1xuICBjbGFzcyBSZWdpc3RlckNvbnRyb2xsZXIge1xuICAgIC8qKiBAYXJnIHtPYmplY3Q8c3RyaW5nLCBSZWdpc3Rlcj59IHJlZ2lzdGVycyAqL1xuICAgIGNvbnN0cnVjdG9yKHJlZ2lzdGVycykge1xuICAgICAgdGhpcy5yZWdpc3RlcnMgPSByZWdpc3RlcnM7XG4gICAgICB0aGlzLnVubmFtZWRSZWdpc3RlciA9IHJlZ2lzdGVyc1snXCInXSA9IG5ldyBSZWdpc3RlcigpO1xuICAgICAgcmVnaXN0ZXJzWycuJ10gPSBuZXcgUmVnaXN0ZXIoKTtcbiAgICAgIHJlZ2lzdGVyc1snOiddID0gbmV3IFJlZ2lzdGVyKCk7XG4gICAgICByZWdpc3RlcnNbJy8nXSA9IG5ldyBSZWdpc3RlcigpO1xuICAgICAgcmVnaXN0ZXJzWycrJ10gPSBuZXcgUmVnaXN0ZXIoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmcgfCBudWxsIHwgdW5kZWZpbmVkfSByZWdpc3Rlck5hbWVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gb3BlcmF0b3JcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2xpbmV3aXNlXVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Jsb2Nrd2lzZV1cbiAgICAgKi9cbiAgICBwdXNoVGV4dChyZWdpc3Rlck5hbWUsIG9wZXJhdG9yLCB0ZXh0LCBsaW5ld2lzZSwgYmxvY2t3aXNlKSB7XG4gICAgICAvLyBUaGUgYmxhY2sgaG9sZSByZWdpc3RlciwgXCJfLCBtZWFucyBkZWxldGUveWFuayB0byBub3doZXJlLlxuICAgICAgaWYgKHJlZ2lzdGVyTmFtZSA9PT0gJ18nKSByZXR1cm47XG4gICAgICBpZiAobGluZXdpc2UgJiYgdGV4dC5jaGFyQXQodGV4dC5sZW5ndGggLSAxKSAhPT0gJ1xcbicpIHtcbiAgICAgICAgdGV4dCArPSAnXFxuJztcbiAgICAgIH1cbiAgICAgIC8vIExvd2VyY2FzZSBhbmQgdXBwZXJjYXNlIHJlZ2lzdGVycyByZWZlciB0byB0aGUgc2FtZSByZWdpc3Rlci5cbiAgICAgIC8vIFVwcGVyY2FzZSBqdXN0IG1lYW5zIGFwcGVuZC5cbiAgICAgIHZhciByZWdpc3RlciA9IHRoaXMuaXNWYWxpZFJlZ2lzdGVyKHJlZ2lzdGVyTmFtZSkgP1xuICAgICAgICAgIHRoaXMuZ2V0UmVnaXN0ZXIocmVnaXN0ZXJOYW1lKSA6IG51bGw7XG4gICAgICAvLyBpZiBubyByZWdpc3Rlci9hbiBpbnZhbGlkIHJlZ2lzdGVyIHdhcyBzcGVjaWZpZWQsIHRoaW5ncyBnbyB0byB0aGVcbiAgICAgIC8vIGRlZmF1bHQgcmVnaXN0ZXJzXG4gICAgICBpZiAoIXJlZ2lzdGVyIHx8ICFyZWdpc3Rlck5hbWUpIHtcbiAgICAgICAgc3dpdGNoIChvcGVyYXRvcikge1xuICAgICAgICAgIGNhc2UgJ3lhbmsnOlxuICAgICAgICAgICAgLy8gVGhlIDAgcmVnaXN0ZXIgY29udGFpbnMgdGhlIHRleHQgZnJvbSB0aGUgbW9zdCByZWNlbnQgeWFuay5cbiAgICAgICAgICAgIHRoaXMucmVnaXN0ZXJzWycwJ10gPSBuZXcgUmVnaXN0ZXIodGV4dCwgbGluZXdpc2UsIGJsb2Nrd2lzZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdkZWxldGUnOlxuICAgICAgICAgIGNhc2UgJ2NoYW5nZSc6XG4gICAgICAgICAgICBpZiAodGV4dC5pbmRleE9mKCdcXG4nKSA9PSAtMSkge1xuICAgICAgICAgICAgICAvLyBEZWxldGUgbGVzcyB0aGFuIDEgbGluZS4gVXBkYXRlIHRoZSBzbWFsbCBkZWxldGUgcmVnaXN0ZXIuXG4gICAgICAgICAgICAgIHRoaXMucmVnaXN0ZXJzWyctJ10gPSBuZXcgUmVnaXN0ZXIodGV4dCwgbGluZXdpc2UpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gU2hpZnQgZG93biB0aGUgY29udGVudHMgb2YgdGhlIG51bWJlcmVkIHJlZ2lzdGVycyBhbmQgcHV0IHRoZVxuICAgICAgICAgICAgICAvLyBkZWxldGVkIHRleHQgaW50byByZWdpc3RlciAxLlxuICAgICAgICAgICAgICB0aGlzLnNoaWZ0TnVtZXJpY1JlZ2lzdGVyc18oKTtcbiAgICAgICAgICAgICAgdGhpcy5yZWdpc3RlcnNbJzEnXSA9IG5ldyBSZWdpc3Rlcih0ZXh0LCBsaW5ld2lzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICAvLyBNYWtlIHN1cmUgdGhlIHVubmFtZWQgcmVnaXN0ZXIgaXMgc2V0IHRvIHdoYXQganVzdCBoYXBwZW5lZFxuICAgICAgICB0aGlzLnVubmFtZWRSZWdpc3Rlci5zZXRUZXh0KHRleHQsIGxpbmV3aXNlLCBibG9ja3dpc2UpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIElmIHdlJ3ZlIGdvdHRlbiB0byB0aGlzIHBvaW50LCB3ZSd2ZSBhY3R1YWxseSBzcGVjaWZpZWQgYSByZWdpc3RlclxuICAgICAgdmFyIGFwcGVuZCA9IGlzVXBwZXJDYXNlKHJlZ2lzdGVyTmFtZSk7XG4gICAgICBpZiAoYXBwZW5kKSB7XG4gICAgICAgIHJlZ2lzdGVyLnB1c2hUZXh0KHRleHQsIGxpbmV3aXNlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlZ2lzdGVyLnNldFRleHQodGV4dCwgbGluZXdpc2UsIGJsb2Nrd2lzZSk7XG4gICAgICB9XG4gICAgICBpZiAocmVnaXN0ZXJOYW1lID09PSAnKycpIHtcbiAgICAgICAgbmF2aWdhdG9yLmNsaXBib2FyZC53cml0ZVRleHQodGV4dCk7XG4gICAgICB9XG4gICAgICAvLyBUaGUgdW5uYW1lZCByZWdpc3RlciBhbHdheXMgaGFzIHRoZSBzYW1lIHZhbHVlIGFzIHRoZSBsYXN0IHVzZWRcbiAgICAgIC8vIHJlZ2lzdGVyLlxuICAgICAgdGhpcy51bm5hbWVkUmVnaXN0ZXIuc2V0VGV4dChyZWdpc3Rlci50b1N0cmluZygpLCBsaW5ld2lzZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHJlZ2lzdGVyIG5hbWVkIEBuYW1lLiAgSWYgb25lIG9mIEBuYW1lIGRvZXNuJ3QgYWxyZWFkeSBleGlzdCxcbiAgICAgKiBjcmVhdGUgaXQuICBJZiBAbmFtZSBpcyBpbnZhbGlkLCByZXR1cm4gdGhlIHVubmFtZWRSZWdpc3Rlci5cbiAgICAgKiBAYXJnIHtzdHJpbmd9IFtuYW1lXVxuICAgICAqL1xuICAgIGdldFJlZ2lzdGVyKG5hbWUpIHtcbiAgICAgIGlmICghdGhpcy5pc1ZhbGlkUmVnaXN0ZXIobmFtZSkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudW5uYW1lZFJlZ2lzdGVyO1xuICAgICAgfVxuICAgICAgbmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgIGlmICghdGhpcy5yZWdpc3RlcnNbbmFtZV0pIHtcbiAgICAgICAgdGhpcy5yZWdpc3RlcnNbbmFtZV0gPSBuZXcgUmVnaXN0ZXIoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLnJlZ2lzdGVyc1tuYW1lXTtcbiAgICB9XG4gICAgLyoqQHR5cGUge3sobmFtZTogYW55KTogbmFtZSBpcyBzdHJpbmd9fSAqL1xuICAgIGlzVmFsaWRSZWdpc3RlcihuYW1lKSB7XG4gICAgICByZXR1cm4gbmFtZSAmJiAoaW5BcnJheShuYW1lLCB2YWxpZFJlZ2lzdGVycykgfHwgbGF0aW5DaGFyUmVnZXgudGVzdChuYW1lKSk7XG4gICAgfVxuICAgIHNoaWZ0TnVtZXJpY1JlZ2lzdGVyc18oKSB7XG4gICAgICBmb3IgKHZhciBpID0gOTsgaSA+PSAyOyBpLS0pIHtcbiAgICAgICAgdGhpcy5yZWdpc3RlcnNbaV0gPSB0aGlzLmdldFJlZ2lzdGVyKCcnICsgKGkgLSAxKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGNsYXNzIEhpc3RvcnlDb250cm9sbGVyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgIC8qKkB0eXBlIHtzdHJpbmdbXX0gKi9cbiAgICAgIHRoaXMuaGlzdG9yeUJ1ZmZlciA9IFtdO1xuICAgICAgdGhpcy5pdGVyYXRvciA9IDA7XG4gICAgICB0aGlzLmluaXRpYWxQcmVmaXggPSBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiB0aGUgaW5wdXQgYXJndW1lbnQgaGVyZSBhY3RzIGEgdXNlciBlbnRlcmVkIHByZWZpeCBmb3IgYSBzbWFsbCB0aW1lXG4gICAgICogdW50aWwgd2Ugc3RhcnQgYXV0b2NvbXBsZXRpb24gaW4gd2hpY2ggY2FzZSBpdCBpcyB0aGUgYXV0b2NvbXBsZXRlZC5cbiAgICAgKiBAYXJnIHtzdHJpbmd9IGlucHV0XG4gICAgICogQGFyZyB7Ym9vbGVhbn0gdXBcbiAgICAgKi9cbiAgICBuZXh0TWF0Y2goaW5wdXQsIHVwKSB7XG4gICAgICB2YXIgaGlzdG9yeUJ1ZmZlciA9IHRoaXMuaGlzdG9yeUJ1ZmZlcjtcbiAgICAgIHZhciBkaXIgPSB1cCA/IC0xIDogMTtcbiAgICAgIGlmICh0aGlzLmluaXRpYWxQcmVmaXggPT09IG51bGwpIHRoaXMuaW5pdGlhbFByZWZpeCA9IGlucHV0O1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMuaXRlcmF0b3IgKyBkaXI7IHVwID8gaSA+PSAwIDogaSA8IGhpc3RvcnlCdWZmZXIubGVuZ3RoOyBpICs9IGRpcikge1xuICAgICAgICB2YXIgZWxlbWVudCA9IGhpc3RvcnlCdWZmZXJbaV07XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDw9IGVsZW1lbnQubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICBpZiAodGhpcy5pbml0aWFsUHJlZml4ID09IGVsZW1lbnQuc3Vic3RyaW5nKDAsIGopKSB7XG4gICAgICAgICAgICB0aGlzLml0ZXJhdG9yID0gaTtcbiAgICAgICAgICAgIHJldHVybiBlbGVtZW50O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gc2hvdWxkIHJldHVybiB0aGUgdXNlciBpbnB1dCBpbiBjYXNlIHdlIHJlYWNoIHRoZSBlbmQgb2YgYnVmZmVyLlxuICAgICAgaWYgKGkgPj0gaGlzdG9yeUJ1ZmZlci5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy5pdGVyYXRvciA9IGhpc3RvcnlCdWZmZXIubGVuZ3RoO1xuICAgICAgICByZXR1cm4gdGhpcy5pbml0aWFsUHJlZml4O1xuICAgICAgfVxuICAgICAgLy8gcmV0dXJuIHRoZSBsYXN0IGF1dG9jb21wbGV0ZWQgcXVlcnkgb3IgZXhDb21tYW5kIGFzIGl0IGlzLlxuICAgICAgaWYgKGkgPCAwKSByZXR1cm4gaW5wdXQ7XG4gICAgfVxuICAgIC8qKiBAYXJnIHtzdHJpbmd9IGlucHV0ICovXG4gICAgcHVzaElucHV0KGlucHV0KSB7XG4gICAgICB2YXIgaW5kZXggPSB0aGlzLmhpc3RvcnlCdWZmZXIuaW5kZXhPZihpbnB1dCk7XG4gICAgICBpZiAoaW5kZXggPiAtMSkgdGhpcy5oaXN0b3J5QnVmZmVyLnNwbGljZShpbmRleCwgMSk7XG4gICAgICBpZiAoaW5wdXQubGVuZ3RoKSB0aGlzLmhpc3RvcnlCdWZmZXIucHVzaChpbnB1dCk7XG4gICAgfVxuICAgIHJlc2V0KCkge1xuICAgICAgdGhpcy5pbml0aWFsUHJlZml4ID0gbnVsbDtcbiAgICAgIHRoaXMuaXRlcmF0b3IgPSB0aGlzLmhpc3RvcnlCdWZmZXIubGVuZ3RoO1xuICAgIH1cbiAgfVxuICB2YXIgY29tbWFuZERpc3BhdGNoZXIgPSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleXNcbiAgICAgKiBAcGFyYW0ge3ZpbUtleVtdfSBrZXlNYXBcbiAgICAgKiBAcGFyYW0ge0lucHV0U3RhdGVJbnRlcmZhY2V9IGlucHV0U3RhdGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29udGV4dFxuICAgICAqL1xuICAgIG1hdGNoQ29tbWFuZDogZnVuY3Rpb24oa2V5cywga2V5TWFwLCBpbnB1dFN0YXRlLCBjb250ZXh0KSB7XG4gICAgICB2YXIgbWF0Y2hlcyA9IGNvbW1hbmRNYXRjaGVzKGtleXMsIGtleU1hcCwgY29udGV4dCwgaW5wdXRTdGF0ZSk7XG4gICAgICB2YXIgYmVzdE1hdGNoID0gbWF0Y2hlcy5mdWxsWzBdO1xuICAgICAgaWYgKCFiZXN0TWF0Y2gpIHtcbiAgICAgICAgaWYgKG1hdGNoZXMucGFydGlhbC5sZW5ndGgpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogJ3BhcnRpYWwnLFxuICAgICAgICAgICAgZXhwZWN0TGl0ZXJhbE5leHQ6IG1hdGNoZXMucGFydGlhbC5sZW5ndGggPT0gMSAmJiBtYXRjaGVzLnBhcnRpYWxbMF0ua2V5cy5zbGljZSgtMTEpID09ICc8Y2hhcmFjdGVyPicgLy8gbGFuZ21hcCBsaXRlcmFsIGxvZ2ljXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge3R5cGU6ICdub25lJ307XG4gICAgICB9XG4gICAgICBpZiAoYmVzdE1hdGNoLmtleXMuc2xpY2UoLTExKSA9PSAnPGNoYXJhY3Rlcj4nIHx8IGJlc3RNYXRjaC5rZXlzLnNsaWNlKC0xMCkgPT0gJzxyZWdpc3Rlcj4nKSB7XG4gICAgICAgIHZhciBjaGFyYWN0ZXIgPSBsYXN0Q2hhcihrZXlzKTtcbiAgICAgICAgaWYgKCFjaGFyYWN0ZXIgfHwgY2hhcmFjdGVyLmxlbmd0aCA+IDEpIHJldHVybiB7dHlwZTogJ2NsZWFyJ307XG4gICAgICAgIGlucHV0U3RhdGUuc2VsZWN0ZWRDaGFyYWN0ZXIgPSBjaGFyYWN0ZXI7XG4gICAgICB9XG4gICAgICByZXR1cm4ge3R5cGU6ICdmdWxsJywgY29tbWFuZDogYmVzdE1hdGNofTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEBhcmcge0NvZGVNaXJyb3JWfSBjbVxuICAgICAqIEBhcmcge3ZpbVN0YXRlfSB2aW1cbiAgICAgKiBAYXJnIHt2aW1LZXl9IGNvbW1hbmRcbiAgICAgKi9cbiAgICBwcm9jZXNzQ29tbWFuZDogZnVuY3Rpb24oY20sIHZpbSwgY29tbWFuZCkge1xuICAgICAgdmltLmlucHV0U3RhdGUucmVwZWF0T3ZlcnJpZGUgPSBjb21tYW5kLnJlcGVhdE92ZXJyaWRlO1xuICAgICAgc3dpdGNoIChjb21tYW5kLnR5cGUpIHtcbiAgICAgICAgY2FzZSAnbW90aW9uJzpcbiAgICAgICAgICB0aGlzLnByb2Nlc3NNb3Rpb24oY20sIHZpbSwgY29tbWFuZCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ29wZXJhdG9yJzpcbiAgICAgICAgICB0aGlzLnByb2Nlc3NPcGVyYXRvcihjbSwgdmltLCBjb21tYW5kKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnb3BlcmF0b3JNb3Rpb24nOlxuICAgICAgICAgIHRoaXMucHJvY2Vzc09wZXJhdG9yTW90aW9uKGNtLCB2aW0sIGNvbW1hbmQpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdhY3Rpb24nOlxuICAgICAgICAgIHRoaXMucHJvY2Vzc0FjdGlvbihjbSwgdmltLCBjb21tYW5kKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnc2VhcmNoJzpcbiAgICAgICAgICB0aGlzLnByb2Nlc3NTZWFyY2goY20sIHZpbSwgY29tbWFuZCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2V4JzpcbiAgICAgICAgY2FzZSAna2V5VG9FeCc6XG4gICAgICAgICAgdGhpcy5wcm9jZXNzRXgoY20sIHZpbSwgY29tbWFuZCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBAYXJnIHtDb2RlTWlycm9yVn0gY21cbiAgICAgKiBAYXJnIHt2aW1TdGF0ZX0gdmltXG4gICAgICogQGFyZyB7aW1wb3J0KFwiLi90eXBlc1wiKS5tb3Rpb25Db21tYW5kfGltcG9ydChcIi4vdHlwZXNcIikub3BlcmF0b3JNb3Rpb25Db21tYW5kfSBjb21tYW5kXG4gICAgICovXG4gICAgcHJvY2Vzc01vdGlvbjogZnVuY3Rpb24oY20sIHZpbSwgY29tbWFuZCkge1xuICAgICAgdmltLmlucHV0U3RhdGUubW90aW9uID0gY29tbWFuZC5tb3Rpb247XG4gICAgICB2aW0uaW5wdXRTdGF0ZS5tb3Rpb25BcmdzID0gLyoqQHR5cGUge01vdGlvbkFyZ3N9Ki8oY29weUFyZ3MoY29tbWFuZC5tb3Rpb25BcmdzKSk7XG4gICAgICB0aGlzLmV2YWxJbnB1dChjbSwgdmltKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEBhcmcge0NvZGVNaXJyb3JWfSBjbVxuICAgICAqIEBhcmcge3ZpbVN0YXRlfSB2aW1cbiAgICAgKiBAYXJnIHtpbXBvcnQoXCIuL3R5cGVzXCIpLm9wZXJhdG9yQ29tbWFuZHxpbXBvcnQoXCIuL3R5cGVzXCIpLm9wZXJhdG9yTW90aW9uQ29tbWFuZH0gY29tbWFuZFxuICAgICAqL1xuICAgIHByb2Nlc3NPcGVyYXRvcjogZnVuY3Rpb24oY20sIHZpbSwgY29tbWFuZCkge1xuICAgICAgdmFyIGlucHV0U3RhdGUgPSB2aW0uaW5wdXRTdGF0ZTtcbiAgICAgIGlmIChpbnB1dFN0YXRlLm9wZXJhdG9yKSB7XG4gICAgICAgIGlmIChpbnB1dFN0YXRlLm9wZXJhdG9yID09IGNvbW1hbmQub3BlcmF0b3IpIHtcbiAgICAgICAgICAvLyBUeXBpbmcgYW4gb3BlcmF0b3IgdHdpY2UgbGlrZSAnZGQnIG1ha2VzIHRoZSBvcGVyYXRvciBvcGVyYXRlXG4gICAgICAgICAgLy8gbGluZXdpc2VcbiAgICAgICAgICBpbnB1dFN0YXRlLm1vdGlvbiA9ICdleHBhbmRUb0xpbmUnO1xuICAgICAgICAgIGlucHV0U3RhdGUubW90aW9uQXJncyA9IHsgbGluZXdpc2U6IHRydWUsIHJlcGVhdDogMSB9O1xuICAgICAgICAgIHRoaXMuZXZhbElucHV0KGNtLCB2aW0pO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyAyIGRpZmZlcmVudCBvcGVyYXRvcnMgaW4gYSByb3cgZG9lc24ndCBtYWtlIHNlbnNlLlxuICAgICAgICAgIGNsZWFySW5wdXRTdGF0ZShjbSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlucHV0U3RhdGUub3BlcmF0b3IgPSBjb21tYW5kLm9wZXJhdG9yO1xuICAgICAgaW5wdXRTdGF0ZS5vcGVyYXRvckFyZ3MgPSBjb3B5QXJncyhjb21tYW5kLm9wZXJhdG9yQXJncyk7XG4gICAgICBpZiAoY29tbWFuZC5rZXlzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgaW5wdXRTdGF0ZS5vcGVyYXRvclNob3J0Y3V0ID0gY29tbWFuZC5rZXlzO1xuICAgICAgfVxuICAgICAgaWYgKGNvbW1hbmQuZXhpdFZpc3VhbEJsb2NrKSB7XG4gICAgICAgICAgdmltLnZpc3VhbEJsb2NrID0gZmFsc2U7XG4gICAgICAgICAgdXBkYXRlQ21TZWxlY3Rpb24oY20pO1xuICAgICAgfVxuICAgICAgaWYgKHZpbS52aXN1YWxNb2RlKSB7XG4gICAgICAgIC8vIE9wZXJhdGluZyBvbiBhIHNlbGVjdGlvbiBpbiB2aXN1YWwgbW9kZS4gV2UgZG9uJ3QgbmVlZCBhIG1vdGlvbi5cbiAgICAgICAgdGhpcy5ldmFsSW5wdXQoY20sIHZpbSk7XG4gICAgICB9XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBAYXJnIHtDb2RlTWlycm9yVn0gY21cbiAgICAgKiBAYXJnIHt2aW1TdGF0ZX0gdmltXG4gICAgICogQGFyZyB7aW1wb3J0KFwiLi90eXBlc1wiKS5vcGVyYXRvck1vdGlvbkNvbW1hbmR9IGNvbW1hbmRcbiAgICAgKi9cbiAgICBwcm9jZXNzT3BlcmF0b3JNb3Rpb246IGZ1bmN0aW9uKGNtLCB2aW0sIGNvbW1hbmQpIHtcbiAgICAgIHZhciB2aXN1YWxNb2RlID0gdmltLnZpc3VhbE1vZGU7XG4gICAgICB2YXIgb3BlcmF0b3JNb3Rpb25BcmdzID0gY29weUFyZ3MoY29tbWFuZC5vcGVyYXRvck1vdGlvbkFyZ3MpO1xuICAgICAgaWYgKG9wZXJhdG9yTW90aW9uQXJncykge1xuICAgICAgICAvLyBPcGVyYXRvciBtb3Rpb25zIG1heSBoYXZlIHNwZWNpYWwgYmVoYXZpb3IgaW4gdmlzdWFsIG1vZGUuXG4gICAgICAgIGlmICh2aXN1YWxNb2RlICYmIG9wZXJhdG9yTW90aW9uQXJncy52aXN1YWxMaW5lKSB7XG4gICAgICAgICAgdmltLnZpc3VhbExpbmUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLnByb2Nlc3NPcGVyYXRvcihjbSwgdmltLCBjb21tYW5kKTtcbiAgICAgIGlmICghdmlzdWFsTW9kZSkge1xuICAgICAgICB0aGlzLnByb2Nlc3NNb3Rpb24oY20sIHZpbSwgY29tbWFuZCk7XG4gICAgICB9XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBAYXJnIHtDb2RlTWlycm9yVn0gY21cbiAgICAgKiBAYXJnIHt2aW1TdGF0ZX0gdmltXG4gICAgICogQGFyZyB7aW1wb3J0KFwiLi90eXBlc1wiKS5hY3Rpb25Db21tYW5kfSBjb21tYW5kXG4gICAgICovXG4gICAgcHJvY2Vzc0FjdGlvbjogZnVuY3Rpb24oY20sIHZpbSwgY29tbWFuZCkge1xuICAgICAgdmFyIGlucHV0U3RhdGUgPSB2aW0uaW5wdXRTdGF0ZTtcbiAgICAgIHZhciByZXBlYXQgPSBpbnB1dFN0YXRlLmdldFJlcGVhdCgpO1xuICAgICAgdmFyIHJlcGVhdElzRXhwbGljaXQgPSAhIXJlcGVhdDtcbiAgICAgIHZhciBhY3Rpb25BcmdzID0gLyoqQHR5cGUge0FjdGlvbkFyZ3N9Ki8oY29weUFyZ3MoY29tbWFuZC5hY3Rpb25BcmdzKSB8fCB7cmVwZWF0OiAxfSk7XG4gICAgICBpZiAoaW5wdXRTdGF0ZS5zZWxlY3RlZENoYXJhY3Rlcikge1xuICAgICAgICBhY3Rpb25BcmdzLnNlbGVjdGVkQ2hhcmFjdGVyID0gaW5wdXRTdGF0ZS5zZWxlY3RlZENoYXJhY3RlcjtcbiAgICAgIH1cbiAgICAgIC8vIEFjdGlvbnMgbWF5IG9yIG1heSBub3QgaGF2ZSBtb3Rpb25zIGFuZCBvcGVyYXRvcnMuIERvIHRoZXNlIGZpcnN0LlxuICAgICAgaWYgKGNvbW1hbmQub3BlcmF0b3IpIHtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICB0aGlzLnByb2Nlc3NPcGVyYXRvcihjbSwgdmltLCBjb21tYW5kKTtcbiAgICAgIH1cbiAgICAgIGlmIChjb21tYW5kLm1vdGlvbikge1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIHRoaXMucHJvY2Vzc01vdGlvbihjbSwgdmltLCBjb21tYW5kKTtcbiAgICAgIH1cbiAgICAgIGlmIChjb21tYW5kLm1vdGlvbiB8fCBjb21tYW5kLm9wZXJhdG9yKSB7XG4gICAgICAgIHRoaXMuZXZhbElucHV0KGNtLCB2aW0pO1xuICAgICAgfVxuICAgICAgYWN0aW9uQXJncy5yZXBlYXQgPSByZXBlYXQgfHwgMTtcbiAgICAgIGFjdGlvbkFyZ3MucmVwZWF0SXNFeHBsaWNpdCA9IHJlcGVhdElzRXhwbGljaXQ7XG4gICAgICBhY3Rpb25BcmdzLnJlZ2lzdGVyTmFtZSA9IGlucHV0U3RhdGUucmVnaXN0ZXJOYW1lO1xuICAgICAgY2xlYXJJbnB1dFN0YXRlKGNtKTtcbiAgICAgIHZpbS5sYXN0TW90aW9uID0gbnVsbDtcbiAgICAgIGlmIChjb21tYW5kLmlzRWRpdCkge1xuICAgICAgICB0aGlzLnJlY29yZExhc3RFZGl0KHZpbSwgaW5wdXRTdGF0ZSwgY29tbWFuZCk7XG4gICAgICB9XG4gICAgICBhY3Rpb25zW2NvbW1hbmQuYWN0aW9uXShjbSwgYWN0aW9uQXJncywgdmltKTtcbiAgICB9LFxuICAgIC8qKiBAYXJnIHtDb2RlTWlycm9yVn0gY20gQGFyZyB7dmltU3RhdGV9IHZpbSBAYXJnIHtpbXBvcnQoXCIuL3R5cGVzXCIpLnNlYXJjaENvbW1hbmR9IGNvbW1hbmQqL1xuICAgIHByb2Nlc3NTZWFyY2g6IGZ1bmN0aW9uKGNtLCB2aW0sIGNvbW1hbmQpIHtcbiAgICAgIGlmICghY20uZ2V0U2VhcmNoQ3Vyc29yKSB7XG4gICAgICAgIC8vIFNlYXJjaCBkZXBlbmRzIG9uIFNlYXJjaEN1cnNvci5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIGZvcndhcmQgPSBjb21tYW5kLnNlYXJjaEFyZ3MuZm9yd2FyZDtcbiAgICAgIHZhciB3aG9sZVdvcmRPbmx5ID0gY29tbWFuZC5zZWFyY2hBcmdzLndob2xlV29yZE9ubHk7XG4gICAgICBnZXRTZWFyY2hTdGF0ZShjbSkuc2V0UmV2ZXJzZWQoIWZvcndhcmQpO1xuICAgICAgdmFyIHByb21wdFByZWZpeCA9IChmb3J3YXJkKSA/ICcvJyA6ICc/JztcbiAgICAgIHZhciBvcmlnaW5hbFF1ZXJ5ID0gZ2V0U2VhcmNoU3RhdGUoY20pLmdldFF1ZXJ5KCk7XG4gICAgICB2YXIgb3JpZ2luYWxTY3JvbGxQb3MgPSBjbS5nZXRTY3JvbGxJbmZvKCk7XG4gICAgICB2YXIgbGFzdFF1ZXJ5ID0gXCJcIjtcbiAgICAgIC8qKiBAYXJnIHtzdHJpbmd9IHF1ZXJ5ICBAYXJnIHtib29sZWFufSBpZ25vcmVDYXNlICBAYXJnIHtib29sZWFufSBzbWFydENhc2UgKi9cbiAgICAgIGZ1bmN0aW9uIGhhbmRsZVF1ZXJ5KHF1ZXJ5LCBpZ25vcmVDYXNlLCBzbWFydENhc2UpIHtcbiAgICAgICAgdmltR2xvYmFsU3RhdGUuc2VhcmNoSGlzdG9yeUNvbnRyb2xsZXIucHVzaElucHV0KHF1ZXJ5KTtcbiAgICAgICAgdmltR2xvYmFsU3RhdGUuc2VhcmNoSGlzdG9yeUNvbnRyb2xsZXIucmVzZXQoKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB1cGRhdGVTZWFyY2hRdWVyeShjbSwgcXVlcnksIGlnbm9yZUNhc2UsIHNtYXJ0Q2FzZSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBzaG93Q29uZmlybShjbSwgJ0ludmFsaWQgcmVnZXg6ICcgKyBxdWVyeSk7XG4gICAgICAgICAgY2xlYXJJbnB1dFN0YXRlKGNtKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29tbWFuZERpc3BhdGNoZXIucHJvY2Vzc01vdGlvbihjbSwgdmltLCB7XG4gICAgICAgICAga2V5czogJycsXG4gICAgICAgICAgdHlwZTogJ21vdGlvbicsXG4gICAgICAgICAgbW90aW9uOiAnZmluZE5leHQnLFxuICAgICAgICAgIG1vdGlvbkFyZ3M6IHsgZm9yd2FyZDogdHJ1ZSwgdG9KdW1wbGlzdDogY29tbWFuZC5zZWFyY2hBcmdzLnRvSnVtcGxpc3QgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIC8qKiBAYXJnIHtzdHJpbmd9IHF1ZXJ5ICovXG4gICAgICBmdW5jdGlvbiBvblByb21wdENsb3NlKHF1ZXJ5KSB7XG4gICAgICAgIGNtLnNjcm9sbFRvKG9yaWdpbmFsU2Nyb2xsUG9zLmxlZnQsIG9yaWdpbmFsU2Nyb2xsUG9zLnRvcCk7XG4gICAgICAgIGhhbmRsZVF1ZXJ5KHF1ZXJ5LCB0cnVlIC8qKiBpZ25vcmVDYXNlICovLCB0cnVlIC8qKiBzbWFydENhc2UgKi8pO1xuICAgICAgICB2YXIgbWFjcm9Nb2RlU3RhdGUgPSB2aW1HbG9iYWxTdGF0ZS5tYWNyb01vZGVTdGF0ZTtcbiAgICAgICAgaWYgKG1hY3JvTW9kZVN0YXRlLmlzUmVjb3JkaW5nKSB7XG4gICAgICAgICAgbG9nU2VhcmNoUXVlcnkobWFjcm9Nb2RlU3RhdGUsIHF1ZXJ5KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZnVuY3Rpb24gcGNyZUxhYmVsKCkge1xuICAgICAgICByZXR1cm4gZ2V0T3B0aW9uKCdwY3JlJykgPyAnKEphdmFTY3JpcHQgcmVnZXhwOiBzZXQgcGNyZSknIDogJyhWaW0gcmVnZXhwOiBzZXQgbm9wY3JlKSdcbiAgICAgIH1cbiAgICAgIC8qKiBcbiAgICAgICAqIEBhcmcge0tleWJvYXJkRXZlbnQme3RhcmdldDpIVE1MSW5wdXRFbGVtZW50fX0gZSBcbiAgICAgICAqIEBhcmcge2FueX0gcXVlcnkgXG4gICAgICAgKiBAYXJnIHsoYXJnMDogYW55KSA9PiB2b2lkfSBjbG9zZSBcbiAgICAgICAqL1xuICAgICAgZnVuY3Rpb24gb25Qcm9tcHRLZXlVcChlLCBxdWVyeSwgY2xvc2UpIHtcbiAgICAgICAgdmFyIGtleU5hbWUgPSB2aW1LZXlGcm9tRXZlbnQoZSksIHVwLCBvZmZzZXQ7XG4gICAgICAgIGlmIChrZXlOYW1lID09ICc8VXA+JyB8fCBrZXlOYW1lID09ICc8RG93bj4nKSB7XG4gICAgICAgICAgdXAgPSBrZXlOYW1lID09ICc8VXA+JyA/IHRydWUgOiBmYWxzZTtcbiAgICAgICAgICBvZmZzZXQgPSBlLnRhcmdldCA/IGUudGFyZ2V0LnNlbGVjdGlvbkVuZCA6IDA7XG4gICAgICAgICAgcXVlcnkgPSB2aW1HbG9iYWxTdGF0ZS5zZWFyY2hIaXN0b3J5Q29udHJvbGxlci5uZXh0TWF0Y2gocXVlcnksIHVwKSB8fCAnJztcbiAgICAgICAgICBjbG9zZShxdWVyeSk7XG4gICAgICAgICAgaWYgKG9mZnNldCAmJiBlLnRhcmdldCkgZS50YXJnZXQuc2VsZWN0aW9uRW5kID0gZS50YXJnZXQuc2VsZWN0aW9uU3RhcnQgPSBNYXRoLm1pbihvZmZzZXQsIGUudGFyZ2V0LnZhbHVlLmxlbmd0aCk7XG4gICAgICAgIH0gZWxzZSBpZiAoa2V5TmFtZSAmJiBrZXlOYW1lICE9ICc8TGVmdD4nICYmIGtleU5hbWUgIT0gJzxSaWdodD4nKSB7XG4gICAgICAgICAgdmltR2xvYmFsU3RhdGUuc2VhcmNoSGlzdG9yeUNvbnRyb2xsZXIucmVzZXQoKTtcbiAgICAgICAgfVxuICAgICAgICBsYXN0UXVlcnkgPSBxdWVyeTtcbiAgICAgICAgb25DaGFuZ2UoKTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIG9uQ2hhbmdlKCkge1xuICAgICAgICB2YXIgcGFyc2VkUXVlcnk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcGFyc2VkUXVlcnkgPSB1cGRhdGVTZWFyY2hRdWVyeShjbSwgbGFzdFF1ZXJ5LFxuICAgICAgICAgICAgICB0cnVlIC8qKiBpZ25vcmVDYXNlICovLCB0cnVlIC8qKiBzbWFydENhc2UgKi8pO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgLy8gU3dhbGxvdyBiYWQgcmVnZXhlcyBmb3IgaW5jcmVtZW50YWwgc2VhcmNoLlxuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJzZWRRdWVyeSkge1xuICAgICAgICAgIGNtLnNjcm9sbEludG9WaWV3KGZpbmROZXh0KGNtLCAhZm9yd2FyZCwgcGFyc2VkUXVlcnkpLCAzMCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2xlYXJTZWFyY2hIaWdobGlnaHQoY20pO1xuICAgICAgICAgIGNtLnNjcm9sbFRvKG9yaWdpbmFsU2Nyb2xsUG9zLmxlZnQsIG9yaWdpbmFsU2Nyb2xsUG9zLnRvcCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8qKiBAYXJnIHtLZXlib2FyZEV2ZW50fSBlICBAYXJnIHtzdHJpbmd9IHF1ZXJ5ICBAYXJnIHsoYXJnMD86IHN0cmluZykgPT4gdm9pZH0gY2xvc2UgKi9cbiAgICAgIGZ1bmN0aW9uIG9uUHJvbXB0S2V5RG93bihlLCBxdWVyeSwgY2xvc2UpIHtcbiAgICAgICAgdmFyIGtleU5hbWUgPSB2aW1LZXlGcm9tRXZlbnQoZSk7XG4gICAgICAgIGlmIChrZXlOYW1lID09ICc8RXNjPicgfHwga2V5TmFtZSA9PSAnPEMtYz4nIHx8IGtleU5hbWUgPT0gJzxDLVs+JyB8fFxuICAgICAgICAgICAgKGtleU5hbWUgPT0gJzxCUz4nICYmIHF1ZXJ5ID09ICcnKSkge1xuICAgICAgICAgIHZpbUdsb2JhbFN0YXRlLnNlYXJjaEhpc3RvcnlDb250cm9sbGVyLnB1c2hJbnB1dChxdWVyeSk7XG4gICAgICAgICAgdmltR2xvYmFsU3RhdGUuc2VhcmNoSGlzdG9yeUNvbnRyb2xsZXIucmVzZXQoKTtcbiAgICAgICAgICB1cGRhdGVTZWFyY2hRdWVyeShjbSwgb3JpZ2luYWxRdWVyeT8uc291cmNlIHx8IFwiXCIpO1xuICAgICAgICAgIGNsZWFyU2VhcmNoSGlnaGxpZ2h0KGNtKTtcbiAgICAgICAgICBjbS5zY3JvbGxUbyhvcmlnaW5hbFNjcm9sbFBvcy5sZWZ0LCBvcmlnaW5hbFNjcm9sbFBvcy50b3ApO1xuICAgICAgICAgIENNLmVfc3RvcChlKTtcbiAgICAgICAgICBjbGVhcklucHV0U3RhdGUoY20pO1xuICAgICAgICAgIGNsb3NlKCk7XG4gICAgICAgICAgY20uZm9jdXMoKTtcbiAgICAgICAgfSBlbHNlIGlmIChrZXlOYW1lID09ICc8VXA+JyB8fCBrZXlOYW1lID09ICc8RG93bj4nKSB7XG4gICAgICAgICAgQ00uZV9zdG9wKGUpO1xuICAgICAgICB9IGVsc2UgaWYgKGtleU5hbWUgPT0gJzxDLXU+Jykge1xuICAgICAgICAgIC8vIEN0cmwtVSBjbGVhcnMgaW5wdXQuXG4gICAgICAgICAgQ00uZV9zdG9wKGUpO1xuICAgICAgICAgIGNsb3NlKCcnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgc3dpdGNoIChjb21tYW5kLnNlYXJjaEFyZ3MucXVlcnlTcmMpIHtcbiAgICAgICAgY2FzZSAncHJvbXB0JzpcbiAgICAgICAgICB2YXIgbWFjcm9Nb2RlU3RhdGUgPSB2aW1HbG9iYWxTdGF0ZS5tYWNyb01vZGVTdGF0ZTtcbiAgICAgICAgICBpZiAobWFjcm9Nb2RlU3RhdGUuaXNQbGF5aW5nKSB7XG4gICAgICAgICAgICBsZXQgcXVlcnkgPSBtYWNyb01vZGVTdGF0ZS5yZXBsYXlTZWFyY2hRdWVyaWVzLnNoaWZ0KCk7XG4gICAgICAgICAgICBoYW5kbGVRdWVyeShxdWVyeSB8fCAnJywgdHJ1ZSAvKiogaWdub3JlQ2FzZSAqLywgZmFsc2UgLyoqIHNtYXJ0Q2FzZSAqLyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNob3dQcm9tcHQoY20sIHtcbiAgICAgICAgICAgICAgICBvbkNsb3NlOiBvblByb21wdENsb3NlLFxuICAgICAgICAgICAgICAgIHByZWZpeDogcHJvbXB0UHJlZml4LFxuICAgICAgICAgICAgICAgIGRlc2M6IGRvbShcbiAgICAgICAgICAgICAgICAgICdzcGFuJyxcbiAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgJGN1cnNvcjogJ3BvaW50ZXInLCBcbiAgICAgICAgICAgICAgICAgICAgb25tb3VzZWRvd246IGZ1bmN0aW9uKC8qKiBAdHlwZSB7TW91c2VFdmVudH0gKi8gZSkge1xuICAgICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICBzZXRPcHRpb24oJ3BjcmUnLCAhZ2V0T3B0aW9uKCdwY3JlJykpO1xuICAgICAgICAgICAgICAgICAgICAgIHRoaXMudGV4dENvbnRlbnQgPSBwY3JlTGFiZWwoKTtcbiAgICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgcGNyZUxhYmVsKClcbiAgICAgICAgICAgICAgICApLCAgXG4gICAgICAgICAgICAgICAgb25LZXlVcDogb25Qcm9tcHRLZXlVcCxcbiAgICAgICAgICAgICAgICBvbktleURvd246IG9uUHJvbXB0S2V5RG93blxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICd3b3JkVW5kZXJDdXJzb3InOlxuICAgICAgICAgIHZhciB3b3JkID0gZXhwYW5kV29yZFVuZGVyQ3Vyc29yKGNtLCB7bm9TeW1ib2w6IHRydWV9KTtcbiAgICAgICAgICB2YXIgaXNLZXl3b3JkID0gdHJ1ZTtcbiAgICAgICAgICBpZiAoIXdvcmQpIHtcbiAgICAgICAgICAgIHdvcmQgPSBleHBhbmRXb3JkVW5kZXJDdXJzb3IoY20sIHtub1N5bWJvbDogZmFsc2V9KTtcbiAgICAgICAgICAgIGlzS2V5d29yZCA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIXdvcmQpIHtcbiAgICAgICAgICAgIHNob3dDb25maXJtKGNtLCAnTm8gd29yZCB1bmRlciBjdXJzb3InKTtcbiAgICAgICAgICAgIGNsZWFySW5wdXRTdGF0ZShjbSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGxldCBxdWVyeSA9IGNtLmdldExpbmUod29yZC5zdGFydC5saW5lKS5zdWJzdHJpbmcod29yZC5zdGFydC5jaCxcbiAgICAgICAgICAgICAgd29yZC5lbmQuY2gpO1xuICAgICAgICAgIGlmIChpc0tleXdvcmQgJiYgd2hvbGVXb3JkT25seSkge1xuICAgICAgICAgICAgICBxdWVyeSA9ICdcXFxcYicgKyBxdWVyeSArICdcXFxcYic7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHF1ZXJ5ID0gZXNjYXBlUmVnZXgocXVlcnkpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIGNhY2hlZEN1cnNvciBpcyB1c2VkIHRvIHNhdmUgdGhlIG9sZCBwb3NpdGlvbiBvZiB0aGUgY3Vyc29yXG4gICAgICAgICAgLy8gd2hlbiAqIG9yICMgY2F1c2VzIHZpbSB0byBzZWVrIGZvciB0aGUgbmVhcmVzdCB3b3JkIGFuZCBzaGlmdFxuICAgICAgICAgIC8vIHRoZSBjdXJzb3IgYmVmb3JlIGVudGVyaW5nIHRoZSBtb3Rpb24uXG4gICAgICAgICAgdmltR2xvYmFsU3RhdGUuanVtcExpc3QuY2FjaGVkQ3Vyc29yID0gY20uZ2V0Q3Vyc29yKCk7XG4gICAgICAgICAgY20uc2V0Q3Vyc29yKHdvcmQuc3RhcnQpO1xuXG4gICAgICAgICAgaGFuZGxlUXVlcnkocXVlcnksIHRydWUgLyoqIGlnbm9yZUNhc2UgKi8sIGZhbHNlIC8qKiBzbWFydENhc2UgKi8pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH0sXG4gICAgLyoqXG4gICAgICogQGFyZyB7Q29kZU1pcnJvclZ9IGNtXG4gICAgICogQGFyZyB7dmltU3RhdGV9IHZpbVxuICAgICAqIEBhcmcge2ltcG9ydChcIi4vdHlwZXNcIikuZXhDb21tYW5kIHwgaW1wb3J0KFwiLi90eXBlc1wiKS5rZXlUb0V4Q29tbWFuZH0gY29tbWFuZFxuICAgICAqL1xuICAgIHByb2Nlc3NFeDogZnVuY3Rpb24oY20sIHZpbSwgY29tbWFuZCkge1xuICAgICAgLyoqQGFyZyB7c3RyaW5nfSBpbnB1dCovXG4gICAgICBmdW5jdGlvbiBvblByb21wdENsb3NlKGlucHV0KSB7XG4gICAgICAgIC8vIEdpdmUgdGhlIHByb21wdCBzb21lIHRpbWUgdG8gY2xvc2Ugc28gdGhhdCBpZiBwcm9jZXNzQ29tbWFuZCBzaG93c1xuICAgICAgICAvLyBhbiBlcnJvciwgdGhlIGVsZW1lbnRzIGRvbid0IG92ZXJsYXAuXG4gICAgICAgIHZpbUdsb2JhbFN0YXRlLmV4Q29tbWFuZEhpc3RvcnlDb250cm9sbGVyLnB1c2hJbnB1dChpbnB1dCk7XG4gICAgICAgIHZpbUdsb2JhbFN0YXRlLmV4Q29tbWFuZEhpc3RvcnlDb250cm9sbGVyLnJlc2V0KCk7XG4gICAgICAgIGV4Q29tbWFuZERpc3BhdGNoZXIucHJvY2Vzc0NvbW1hbmQoY20sIGlucHV0KTtcbiAgICAgICAgaWYgKGNtLnN0YXRlLnZpbSkgY2xlYXJJbnB1dFN0YXRlKGNtKTtcbiAgICAgICAgY2xlYXJTZWFyY2hIaWdobGlnaHQoY20pO1xuICAgICAgfVxuICAgICAgLyoqXG4gICAgICAgKiBAYXJnIHtLZXlib2FyZEV2ZW50Jnt0YXJnZXQ6SFRNTElucHV0RWxlbWVudH19IGVcbiAgICAgICAqIEBhcmcge3N0cmluZ30gaW5wdXRcbiAgICAgICAqIEBhcmcgeyhhcmcwPzogc3RyaW5nKSA9PiB2b2lkfSBjbG9zZVxuICAgICAgICovXG4gICAgICBmdW5jdGlvbiBvblByb21wdEtleURvd24oZSwgaW5wdXQsIGNsb3NlKSB7XG4gICAgICAgIHZhciBrZXlOYW1lID0gdmltS2V5RnJvbUV2ZW50KGUpLCB1cCwgb2Zmc2V0O1xuICAgICAgICBpZiAoa2V5TmFtZSA9PSAnPEVzYz4nIHx8IGtleU5hbWUgPT0gJzxDLWM+JyB8fCBrZXlOYW1lID09ICc8Qy1bPicgfHxcbiAgICAgICAgICAgIChrZXlOYW1lID09ICc8QlM+JyAmJiBpbnB1dCA9PSAnJykpIHtcbiAgICAgICAgICB2aW1HbG9iYWxTdGF0ZS5leENvbW1hbmRIaXN0b3J5Q29udHJvbGxlci5wdXNoSW5wdXQoaW5wdXQpO1xuICAgICAgICAgIHZpbUdsb2JhbFN0YXRlLmV4Q29tbWFuZEhpc3RvcnlDb250cm9sbGVyLnJlc2V0KCk7XG4gICAgICAgICAgQ00uZV9zdG9wKGUpO1xuICAgICAgICAgIGNsZWFySW5wdXRTdGF0ZShjbSk7XG4gICAgICAgICAgY2xlYXJTZWFyY2hIaWdobGlnaHQoY20pO1xuICAgICAgICAgIGNsb3NlKCk7XG4gICAgICAgICAgY20uZm9jdXMoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoa2V5TmFtZSA9PSAnPFVwPicgfHwga2V5TmFtZSA9PSAnPERvd24+Jykge1xuICAgICAgICAgIENNLmVfc3RvcChlKTtcbiAgICAgICAgICB1cCA9IGtleU5hbWUgPT0gJzxVcD4nID8gdHJ1ZSA6IGZhbHNlO1xuICAgICAgICAgIG9mZnNldCA9IGUudGFyZ2V0ID8gZS50YXJnZXQuc2VsZWN0aW9uRW5kIDogMDtcbiAgICAgICAgICBpbnB1dCA9IHZpbUdsb2JhbFN0YXRlLmV4Q29tbWFuZEhpc3RvcnlDb250cm9sbGVyLm5leHRNYXRjaChpbnB1dCwgdXApIHx8ICcnO1xuICAgICAgICAgIGNsb3NlKGlucHV0KTtcbiAgICAgICAgICBpZiAob2Zmc2V0ICYmIGUudGFyZ2V0KSBlLnRhcmdldC5zZWxlY3Rpb25FbmQgPSBlLnRhcmdldC5zZWxlY3Rpb25TdGFydCA9IE1hdGgubWluKG9mZnNldCwgZS50YXJnZXQudmFsdWUubGVuZ3RoKTtcbiAgICAgICAgfSBlbHNlIGlmIChrZXlOYW1lID09ICc8Qy11PicpIHtcbiAgICAgICAgICAvLyBDdHJsLVUgY2xlYXJzIGlucHV0LlxuICAgICAgICAgIENNLmVfc3RvcChlKTtcbiAgICAgICAgICBjbG9zZSgnJyk7XG4gICAgICAgIH0gZWxzZSBpZiAoa2V5TmFtZSAmJiBrZXlOYW1lICE9ICc8TGVmdD4nICYmIGtleU5hbWUgIT0gJzxSaWdodD4nKSB7XG4gICAgICAgICAgICB2aW1HbG9iYWxTdGF0ZS5leENvbW1hbmRIaXN0b3J5Q29udHJvbGxlci5yZXNldCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvKipcbiAgICAgICAqIEBhcmcge0tleWJvYXJkRXZlbnQme3RhcmdldDpIVE1MSW5wdXRFbGVtZW50fX0gZVxuICAgICAgICogQGFyZyB7YW55fSBxdWVyeVxuICAgICAgICovXG4gICAgICBmdW5jdGlvbiBvblByb21wdEtleVVwKGUsIHF1ZXJ5KSB7XG4gICAgICAgIHZhciBpbnB1dFN0cmVhbSA9IG5ldyBDTS5TdHJpbmdTdHJlYW0ocXVlcnkpO1xuICAgICAgICB2YXIgcGFyYW1zID0gLyoqQHR5cGV7aW1wb3J0KFwiLi90eXBlc1wiKS5leENvbW1hbmRBcmdzfSovKHt9KTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBleENvbW1hbmREaXNwYXRjaGVyLnBhcnNlSW5wdXRfKGNtLCBpbnB1dFN0cmVhbSwgcGFyYW1zKTtcbiAgICAgICAgICBpZiAocGFyYW1zLmNvbW1hbmROYW1lICE9IFwic1wiKSB7XG4gICAgICAgICAgICBjbGVhclNlYXJjaEhpZ2hsaWdodChjbSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBjb21tYW5kID0gZXhDb21tYW5kRGlzcGF0Y2hlci5tYXRjaENvbW1hbmRfKHBhcmFtcy5jb21tYW5kTmFtZSk7XG4gICAgICAgICAgaWYgKCFjb21tYW5kKSByZXR1cm47XG4gICAgICAgICAgZXhDb21tYW5kRGlzcGF0Y2hlci5wYXJzZUNvbW1hbmRBcmdzXyhpbnB1dFN0cmVhbSwgcGFyYW1zLCBjb21tYW5kKTtcbiAgICAgICAgICBpZiAoIXBhcmFtcy5hcmdTdHJpbmcpIHJldHVybjtcbiAgICAgICAgICB2YXIgcmVnZXggPSBwYXJzZVF1ZXJ5KHBhcmFtcy5hcmdTdHJpbmcuc2xpY2UoMSksIHRydWUsIHRydWUpO1xuICAgICAgICAgIGlmIChyZWdleCkgaGlnaGxpZ2h0U2VhcmNoTWF0Y2hlcyhjbSwgcmVnZXgpO1xuICAgICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGNvbW1hbmQudHlwZSA9PSAna2V5VG9FeCcpIHtcbiAgICAgICAgLy8gSGFuZGxlIHVzZXIgZGVmaW5lZCBFeCB0byBFeCBtYXBwaW5nc1xuICAgICAgICBleENvbW1hbmREaXNwYXRjaGVyLnByb2Nlc3NDb21tYW5kKGNtLCBjb21tYW5kLmV4QXJncy5pbnB1dCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvKipAdHlwZXtpbXBvcnQoXCIuL3R5cGVzXCIpLlByb21wdE9wdGlvbnN9ICovXG4gICAgICAgIHZhciBwcm9tcHRPcHRpb25zID0ge1xuICAgICAgICAgIG9uQ2xvc2U6IG9uUHJvbXB0Q2xvc2UsXG4gICAgICAgICAgb25LZXlEb3duOiBvblByb21wdEtleURvd24sXG4gICAgICAgICAgb25LZXlVcDogb25Qcm9tcHRLZXlVcCxcbiAgICAgICAgICBwcmVmaXg6ICc6JyxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHZpbS52aXN1YWxNb2RlKSB7XG4gICAgICAgICAgcHJvbXB0T3B0aW9ucy52YWx1ZSA9ICdcXCc8LFxcJz4nO1xuICAgICAgICAgIHByb21wdE9wdGlvbnMuc2VsZWN0VmFsdWVPbk9wZW4gPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBzaG93UHJvbXB0KGNtLCBwcm9tcHRPcHRpb25zKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIC8qKkBhcmcge0NvZGVNaXJyb3JWfSBjbSAgIEBhcmcge3ZpbVN0YXRlfSB2aW0gKi9cbiAgICBldmFsSW5wdXQ6IGZ1bmN0aW9uKGNtLCB2aW0pIHtcbiAgICAgIC8vIElmIHRoZSBtb3Rpb24gY29tbWFuZCBpcyBzZXQsIGV4ZWN1dGUgYm90aCB0aGUgb3BlcmF0b3IgYW5kIG1vdGlvbi5cbiAgICAgIC8vIE90aGVyd2lzZSByZXR1cm4uXG4gICAgICB2YXIgaW5wdXRTdGF0ZSA9IHZpbS5pbnB1dFN0YXRlO1xuICAgICAgdmFyIG1vdGlvbiA9IGlucHV0U3RhdGUubW90aW9uO1xuICAgICAgLyoqIEB0eXBlIHtNb3Rpb25BcmdzfSovXG4gICAgICB2YXIgbW90aW9uQXJncyA9IGlucHV0U3RhdGUubW90aW9uQXJncyB8fCB7IHJlcGVhdDogMX07XG4gICAgICB2YXIgb3BlcmF0b3IgPSBpbnB1dFN0YXRlLm9wZXJhdG9yO1xuICAgICAgLyoqIEB0eXBlIHtPcGVyYXRvckFyZ3N9Ki9cbiAgICAgIHZhciBvcGVyYXRvckFyZ3MgPSBpbnB1dFN0YXRlLm9wZXJhdG9yQXJncyB8fCB7fTtcbiAgICAgIHZhciByZWdpc3Rlck5hbWUgPSBpbnB1dFN0YXRlLnJlZ2lzdGVyTmFtZTtcbiAgICAgIHZhciBzZWwgPSB2aW0uc2VsO1xuICAgICAgLy8gVE9ETzogTWFrZSBzdXJlIGNtIGFuZCB2aW0gc2VsZWN0aW9ucyBhcmUgaWRlbnRpY2FsIG91dHNpZGUgdmlzdWFsIG1vZGUuXG4gICAgICB2YXIgb3JpZ0hlYWQgPSBjb3B5Q3Vyc29yKHZpbS52aXN1YWxNb2RlID8gY2xpcEN1cnNvclRvQ29udGVudChjbSwgc2VsLmhlYWQpOiBjbS5nZXRDdXJzb3IoJ2hlYWQnKSk7XG4gICAgICB2YXIgb3JpZ0FuY2hvciA9IGNvcHlDdXJzb3IodmltLnZpc3VhbE1vZGUgPyBjbGlwQ3Vyc29yVG9Db250ZW50KGNtLCBzZWwuYW5jaG9yKSA6IGNtLmdldEN1cnNvcignYW5jaG9yJykpO1xuICAgICAgdmFyIG9sZEhlYWQgPSBjb3B5Q3Vyc29yKG9yaWdIZWFkKTtcbiAgICAgIHZhciBvbGRBbmNob3IgPSBjb3B5Q3Vyc29yKG9yaWdBbmNob3IpO1xuICAgICAgdmFyIG5ld0hlYWQsIG5ld0FuY2hvcjtcbiAgICAgIHZhciByZXBlYXQ7XG4gICAgICBpZiAob3BlcmF0b3IpIHtcbiAgICAgICAgdGhpcy5yZWNvcmRMYXN0RWRpdCh2aW0sIGlucHV0U3RhdGUpO1xuICAgICAgfVxuICAgICAgaWYgKGlucHV0U3RhdGUucmVwZWF0T3ZlcnJpZGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyBJZiByZXBlYXRPdmVycmlkZSBpcyBzcGVjaWZpZWQsIHRoYXQgdGFrZXMgcHJlY2VkZW5jZSBvdmVyIHRoZVxuICAgICAgICAvLyBpbnB1dCBzdGF0ZSdzIHJlcGVhdC4gVXNlZCBieSBFeCBtb2RlIGFuZCBjYW4gYmUgdXNlciBkZWZpbmVkLlxuICAgICAgICByZXBlYXQgPSBpbnB1dFN0YXRlLnJlcGVhdE92ZXJyaWRlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVwZWF0ID0gaW5wdXRTdGF0ZS5nZXRSZXBlYXQoKTtcbiAgICAgIH1cbiAgICAgIGlmIChyZXBlYXQgPiAwICYmIG1vdGlvbkFyZ3MuZXhwbGljaXRSZXBlYXQpIHtcbiAgICAgICAgbW90aW9uQXJncy5yZXBlYXRJc0V4cGxpY2l0ID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAobW90aW9uQXJncy5ub1JlcGVhdCB8fFxuICAgICAgICAgICghbW90aW9uQXJncy5leHBsaWNpdFJlcGVhdCAmJiByZXBlYXQgPT09IDApKSB7XG4gICAgICAgIHJlcGVhdCA9IDE7XG4gICAgICAgIG1vdGlvbkFyZ3MucmVwZWF0SXNFeHBsaWNpdCA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKGlucHV0U3RhdGUuc2VsZWN0ZWRDaGFyYWN0ZXIpIHtcbiAgICAgICAgLy8gSWYgdGhlcmUgaXMgYSBjaGFyYWN0ZXIgaW5wdXQsIHN0aWNrIGl0IGluIGFsbCBvZiB0aGUgYXJnIGFycmF5cy5cbiAgICAgICAgbW90aW9uQXJncy5zZWxlY3RlZENoYXJhY3RlciA9IG9wZXJhdG9yQXJncy5zZWxlY3RlZENoYXJhY3RlciA9XG4gICAgICAgICAgICBpbnB1dFN0YXRlLnNlbGVjdGVkQ2hhcmFjdGVyO1xuICAgICAgfVxuICAgICAgbW90aW9uQXJncy5yZXBlYXQgPSByZXBlYXQ7XG4gICAgICBjbGVhcklucHV0U3RhdGUoY20pO1xuICAgICAgaWYgKG1vdGlvbikge1xuICAgICAgICB2YXIgbW90aW9uUmVzdWx0ID0gbW90aW9uc1ttb3Rpb25dKGNtLCBvcmlnSGVhZCwgbW90aW9uQXJncywgdmltLCBpbnB1dFN0YXRlKTtcbiAgICAgICAgdmltLmxhc3RNb3Rpb24gPSBtb3Rpb25zW21vdGlvbl07XG4gICAgICAgIGlmICghbW90aW9uUmVzdWx0KSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtb3Rpb25BcmdzLnRvSnVtcGxpc3QpIHtcbiAgICAgICAgICB2YXIganVtcExpc3QgPSB2aW1HbG9iYWxTdGF0ZS5qdW1wTGlzdDtcbiAgICAgICAgICAvLyBpZiB0aGUgY3VycmVudCBtb3Rpb24gaXMgIyBvciAqLCB1c2UgY2FjaGVkQ3Vyc29yXG4gICAgICAgICAgdmFyIGNhY2hlZEN1cnNvciA9IGp1bXBMaXN0LmNhY2hlZEN1cnNvcjtcbiAgICAgICAgICBpZiAoY2FjaGVkQ3Vyc29yKSB7XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICByZWNvcmRKdW1wUG9zaXRpb24oY20sIGNhY2hlZEN1cnNvciwgbW90aW9uUmVzdWx0KTtcbiAgICAgICAgICAgIGRlbGV0ZSBqdW1wTGlzdC5jYWNoZWRDdXJzb3I7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIHJlY29yZEp1bXBQb3NpdGlvbihjbSwgb3JpZ0hlYWQsIG1vdGlvblJlc3VsdCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChtb3Rpb25SZXN1bHQgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgIG5ld0FuY2hvciA9IG1vdGlvblJlc3VsdFswXTtcbiAgICAgICAgICBuZXdIZWFkID0gbW90aW9uUmVzdWx0WzFdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5ld0hlYWQgPSBtb3Rpb25SZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVE9ETzogSGFuZGxlIG51bGwgcmV0dXJucyBmcm9tIG1vdGlvbiBjb21tYW5kcyBiZXR0ZXIuXG4gICAgICAgIGlmICghbmV3SGVhZCkge1xuICAgICAgICAgIG5ld0hlYWQgPSBjb3B5Q3Vyc29yKG9yaWdIZWFkKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmltLnZpc3VhbE1vZGUpIHtcbiAgICAgICAgICBpZiAoISh2aW0udmlzdWFsQmxvY2sgJiYgbmV3SGVhZC5jaCA9PT0gSW5maW5pdHkpKSB7XG4gICAgICAgICAgICBuZXdIZWFkID0gY2xpcEN1cnNvclRvQ29udGVudChjbSwgbmV3SGVhZCwgb2xkSGVhZCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChuZXdBbmNob3IpIHtcbiAgICAgICAgICAgIG5ld0FuY2hvciA9IGNsaXBDdXJzb3JUb0NvbnRlbnQoY20sIG5ld0FuY2hvcik7XG4gICAgICAgICAgfVxuICAgICAgICAgIG5ld0FuY2hvciA9IG5ld0FuY2hvciB8fCBvbGRBbmNob3I7XG4gICAgICAgICAgc2VsLmFuY2hvciA9IG5ld0FuY2hvcjtcbiAgICAgICAgICBzZWwuaGVhZCA9IG5ld0hlYWQ7XG4gICAgICAgICAgdXBkYXRlQ21TZWxlY3Rpb24oY20pO1xuICAgICAgICAgIHVwZGF0ZU1hcmsoY20sIHZpbSwgJzwnLFxuICAgICAgICAgICAgICBjdXJzb3JJc0JlZm9yZShuZXdBbmNob3IsIG5ld0hlYWQpID8gbmV3QW5jaG9yXG4gICAgICAgICAgICAgICAgICA6IG5ld0hlYWQpO1xuICAgICAgICAgIHVwZGF0ZU1hcmsoY20sIHZpbSwgJz4nLFxuICAgICAgICAgICAgICBjdXJzb3JJc0JlZm9yZShuZXdBbmNob3IsIG5ld0hlYWQpID8gbmV3SGVhZFxuICAgICAgICAgICAgICAgICAgOiBuZXdBbmNob3IpO1xuICAgICAgICB9IGVsc2UgaWYgKCFvcGVyYXRvcikge1xuICAgICAgICAgIG5ld0hlYWQgPSBjbGlwQ3Vyc29yVG9Db250ZW50KGNtLCBuZXdIZWFkLCBvbGRIZWFkKTtcbiAgICAgICAgICBjbS5zZXRDdXJzb3IobmV3SGVhZC5saW5lLCBuZXdIZWFkLmNoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG9wZXJhdG9yKSB7XG4gICAgICAgIGlmIChvcGVyYXRvckFyZ3MubGFzdFNlbCkge1xuICAgICAgICAgIC8vIFJlcGxheWluZyBhIHZpc3VhbCBtb2RlIG9wZXJhdGlvblxuICAgICAgICAgIG5ld0FuY2hvciA9IG9sZEFuY2hvcjtcbiAgICAgICAgICB2YXIgbGFzdFNlbCA9IG9wZXJhdG9yQXJncy5sYXN0U2VsO1xuICAgICAgICAgIHZhciBsaW5lT2Zmc2V0ID0gTWF0aC5hYnMobGFzdFNlbC5oZWFkLmxpbmUgLSBsYXN0U2VsLmFuY2hvci5saW5lKTtcbiAgICAgICAgICB2YXIgY2hPZmZzZXQgPSBNYXRoLmFicyhsYXN0U2VsLmhlYWQuY2ggLSBsYXN0U2VsLmFuY2hvci5jaCk7XG4gICAgICAgICAgaWYgKGxhc3RTZWwudmlzdWFsTGluZSkge1xuICAgICAgICAgICAgLy8gTGluZXdpc2UgVmlzdWFsIG1vZGU6IFRoZSBzYW1lIG51bWJlciBvZiBsaW5lcy5cbiAgICAgICAgICAgIG5ld0hlYWQgPSBuZXcgUG9zKG9sZEFuY2hvci5saW5lICsgbGluZU9mZnNldCwgb2xkQW5jaG9yLmNoKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGxhc3RTZWwudmlzdWFsQmxvY2spIHtcbiAgICAgICAgICAgIC8vIEJsb2Nrd2lzZSBWaXN1YWwgbW9kZTogVGhlIHNhbWUgbnVtYmVyIG9mIGxpbmVzIGFuZCBjb2x1bW5zLlxuICAgICAgICAgICAgbmV3SGVhZCA9IG5ldyBQb3Mob2xkQW5jaG9yLmxpbmUgKyBsaW5lT2Zmc2V0LCBvbGRBbmNob3IuY2ggKyBjaE9mZnNldCk7XG4gICAgICAgICAgfSBlbHNlIGlmIChsYXN0U2VsLmhlYWQubGluZSA9PSBsYXN0U2VsLmFuY2hvci5saW5lKSB7XG4gICAgICAgICAgICAvLyBOb3JtYWwgVmlzdWFsIG1vZGUgd2l0aGluIG9uZSBsaW5lOiBUaGUgc2FtZSBudW1iZXIgb2YgY2hhcmFjdGVycy5cbiAgICAgICAgICAgIG5ld0hlYWQgPSBuZXcgUG9zKG9sZEFuY2hvci5saW5lLCBvbGRBbmNob3IuY2ggKyBjaE9mZnNldCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIE5vcm1hbCBWaXN1YWwgbW9kZSB3aXRoIHNldmVyYWwgbGluZXM6IFRoZSBzYW1lIG51bWJlciBvZiBsaW5lcywgaW4gdGhlXG4gICAgICAgICAgICAvLyBsYXN0IGxpbmUgdGhlIHNhbWUgbnVtYmVyIG9mIGNoYXJhY3RlcnMgYXMgaW4gdGhlIGxhc3QgbGluZSB0aGUgbGFzdCB0aW1lLlxuICAgICAgICAgICAgbmV3SGVhZCA9IG5ldyBQb3Mob2xkQW5jaG9yLmxpbmUgKyBsaW5lT2Zmc2V0LCBvbGRBbmNob3IuY2gpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2aW0udmlzdWFsTW9kZSA9IHRydWU7XG4gICAgICAgICAgdmltLnZpc3VhbExpbmUgPSBsYXN0U2VsLnZpc3VhbExpbmU7XG4gICAgICAgICAgdmltLnZpc3VhbEJsb2NrID0gbGFzdFNlbC52aXN1YWxCbG9jaztcbiAgICAgICAgICBzZWwgPSB2aW0uc2VsID0ge1xuICAgICAgICAgICAgYW5jaG9yOiBuZXdBbmNob3IsXG4gICAgICAgICAgICBoZWFkOiBuZXdIZWFkXG4gICAgICAgICAgfTtcbiAgICAgICAgICB1cGRhdGVDbVNlbGVjdGlvbihjbSk7XG4gICAgICAgIH0gZWxzZSBpZiAodmltLnZpc3VhbE1vZGUpIHtcbiAgICAgICAgICBvcGVyYXRvckFyZ3MubGFzdFNlbCA9IHtcbiAgICAgICAgICAgIGFuY2hvcjogY29weUN1cnNvcihzZWwuYW5jaG9yKSxcbiAgICAgICAgICAgIGhlYWQ6IGNvcHlDdXJzb3Ioc2VsLmhlYWQpLFxuICAgICAgICAgICAgdmlzdWFsQmxvY2s6IHZpbS52aXN1YWxCbG9jayxcbiAgICAgICAgICAgIHZpc3VhbExpbmU6IHZpbS52aXN1YWxMaW5lXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY3VyU3RhcnQsIGN1ckVuZCwgbGluZXdpc2U7XG4gICAgICAgIC8qKiBAdHlwZSB7J2Jsb2NrJ3wnbGluZSd8J2NoYXInfSovIHZhciBtb2RlO1xuICAgICAgICB2YXIgY21TZWw7XG4gICAgICAgIGlmICh2aW0udmlzdWFsTW9kZSkge1xuICAgICAgICAgIC8vIEluaXQgdmlzdWFsIG9wXG4gICAgICAgICAgY3VyU3RhcnQgPSBjdXJzb3JNaW4oc2VsLmhlYWQsIHNlbC5hbmNob3IpO1xuICAgICAgICAgIGN1ckVuZCA9IGN1cnNvck1heChzZWwuaGVhZCwgc2VsLmFuY2hvcik7XG4gICAgICAgICAgbGluZXdpc2UgPSB2aW0udmlzdWFsTGluZSB8fCBvcGVyYXRvckFyZ3MubGluZXdpc2U7XG4gICAgICAgICAgbW9kZSA9IHZpbS52aXN1YWxCbG9jayA/ICdibG9jaycgOlxuICAgICAgICAgICAgICAgICAgbGluZXdpc2UgPyAnbGluZScgOlxuICAgICAgICAgICAgICAgICAgJ2NoYXInO1xuICAgICAgICAgIHZhciBuZXdQb3NpdGlvbnMgPSB1cGRhdGVTZWxlY3Rpb25Gb3JTdXJyb2dhdGVDaGFyYWN0ZXJzKGNtLCBjdXJTdGFydCwgY3VyRW5kKTtcbiAgICAgICAgICBjbVNlbCA9IG1ha2VDbVNlbGVjdGlvbihjbSwge1xuICAgICAgICAgICAgYW5jaG9yOiBuZXdQb3NpdGlvbnMuc3RhcnQsXG4gICAgICAgICAgICBoZWFkOiBuZXdQb3NpdGlvbnMuZW5kXG4gICAgICAgICAgfSwgbW9kZSk7XG4gICAgICAgICAgaWYgKGxpbmV3aXNlKSB7XG4gICAgICAgICAgICB2YXIgcmFuZ2VzID0gY21TZWwucmFuZ2VzO1xuICAgICAgICAgICAgaWYgKG1vZGUgPT0gJ2Jsb2NrJykge1xuICAgICAgICAgICAgICAvLyBMaW5ld2lzZSBvcGVyYXRvcnMgaW4gdmlzdWFsIGJsb2NrIG1vZGUgZXh0ZW5kIHRvIGVuZCBvZiBsaW5lXG4gICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmFuZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcmFuZ2VzW2ldLmhlYWQuY2ggPSBsaW5lTGVuZ3RoKGNtLCByYW5nZXNbaV0uaGVhZC5saW5lKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChtb2RlID09ICdsaW5lJykge1xuICAgICAgICAgICAgICByYW5nZXNbMF0uaGVhZCA9IG5ldyBQb3MocmFuZ2VzWzBdLmhlYWQubGluZSArIDEsIDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBJbml0IG1vdGlvbiBvcFxuICAgICAgICAgIGN1clN0YXJ0ID0gY29weUN1cnNvcihuZXdBbmNob3IgfHwgb2xkQW5jaG9yKTtcbiAgICAgICAgICBjdXJFbmQgPSBjb3B5Q3Vyc29yKG5ld0hlYWQgfHwgb2xkSGVhZCk7XG4gICAgICAgICAgaWYgKGN1cnNvcklzQmVmb3JlKGN1ckVuZCwgY3VyU3RhcnQpKSB7XG4gICAgICAgICAgICB2YXIgdG1wID0gY3VyU3RhcnQ7XG4gICAgICAgICAgICBjdXJTdGFydCA9IGN1ckVuZDtcbiAgICAgICAgICAgIGN1ckVuZCA9IHRtcDtcbiAgICAgICAgICB9XG4gICAgICAgICAgbGluZXdpc2UgPSBtb3Rpb25BcmdzLmxpbmV3aXNlIHx8IG9wZXJhdG9yQXJncy5saW5ld2lzZTtcbiAgICAgICAgICBpZiAobGluZXdpc2UpIHtcbiAgICAgICAgICAgIC8vIEV4cGFuZCBzZWxlY3Rpb24gdG8gZW50aXJlIGxpbmUuXG4gICAgICAgICAgICBleHBhbmRTZWxlY3Rpb25Ub0xpbmUoY20sIGN1clN0YXJ0LCBjdXJFbmQpO1xuICAgICAgICAgIH0gZWxzZSBpZiAobW90aW9uQXJncy5mb3J3YXJkKSB7XG4gICAgICAgICAgICAvLyBDbGlwIHRvIHRyYWlsaW5nIG5ld2xpbmVzIG9ubHkgaWYgdGhlIG1vdGlvbiBnb2VzIGZvcndhcmQuXG4gICAgICAgICAgICBjbGlwVG9MaW5lKGNtLCBjdXJTdGFydCwgY3VyRW5kKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbW9kZSA9ICdjaGFyJztcbiAgICAgICAgICB2YXIgZXhjbHVzaXZlID0gIW1vdGlvbkFyZ3MuaW5jbHVzaXZlIHx8IGxpbmV3aXNlO1xuICAgICAgICAgIHZhciBuZXdQb3NpdGlvbnMgPSB1cGRhdGVTZWxlY3Rpb25Gb3JTdXJyb2dhdGVDaGFyYWN0ZXJzKGNtLCBjdXJTdGFydCwgY3VyRW5kKTtcbiAgICAgICAgICBjbVNlbCA9IG1ha2VDbVNlbGVjdGlvbihjbSwge1xuICAgICAgICAgICAgYW5jaG9yOiBuZXdQb3NpdGlvbnMuc3RhcnQsXG4gICAgICAgICAgICBoZWFkOiBuZXdQb3NpdGlvbnMuZW5kXG4gICAgICAgICAgfSwgbW9kZSwgZXhjbHVzaXZlKTtcbiAgICAgICAgfVxuICAgICAgICBjbS5zZXRTZWxlY3Rpb25zKGNtU2VsLnJhbmdlcywgY21TZWwucHJpbWFyeSk7XG4gICAgICAgIHZpbS5sYXN0TW90aW9uID0gbnVsbDtcbiAgICAgICAgb3BlcmF0b3JBcmdzLnJlcGVhdCA9IHJlcGVhdDsgLy8gRm9yIGluZGVudCBpbiB2aXN1YWwgbW9kZS5cbiAgICAgICAgb3BlcmF0b3JBcmdzLnJlZ2lzdGVyTmFtZSA9IHJlZ2lzdGVyTmFtZTtcbiAgICAgICAgLy8gS2VlcCB0cmFjayBvZiBsaW5ld2lzZSBhcyBpdCBhZmZlY3RzIGhvdyBwYXN0ZSBhbmQgY2hhbmdlIGJlaGF2ZS5cbiAgICAgICAgb3BlcmF0b3JBcmdzLmxpbmV3aXNlID0gbGluZXdpc2U7XG4gICAgICAgIHZhciBvcGVyYXRvck1vdmVUbyA9IG9wZXJhdG9yc1tvcGVyYXRvcl0oXG4gICAgICAgICAgY20sIG9wZXJhdG9yQXJncywgY21TZWwucmFuZ2VzLCBvbGRBbmNob3IsIG5ld0hlYWQpO1xuICAgICAgICBpZiAodmltLnZpc3VhbE1vZGUpIHtcbiAgICAgICAgICBleGl0VmlzdWFsTW9kZShjbSwgb3BlcmF0b3JNb3ZlVG8gIT0gbnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wZXJhdG9yTW92ZVRvKSB7XG4gICAgICAgICAgY20uc2V0Q3Vyc29yKG9wZXJhdG9yTW92ZVRvKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgLyoqQGFyZyB7dmltU3RhdGV9IHZpbSAgQGFyZyB7SW5wdXRTdGF0ZUludGVyZmFjZX0gaW5wdXRTdGF0ZSwgQGFyZyB7aW1wb3J0KFwiLi90eXBlc1wiKS5hY3Rpb25Db21tYW5kfSBbYWN0aW9uQ29tbWFuZF0gKi9cbiAgICByZWNvcmRMYXN0RWRpdDogZnVuY3Rpb24odmltLCBpbnB1dFN0YXRlLCBhY3Rpb25Db21tYW5kKSB7XG4gICAgICB2YXIgbWFjcm9Nb2RlU3RhdGUgPSB2aW1HbG9iYWxTdGF0ZS5tYWNyb01vZGVTdGF0ZTtcbiAgICAgIGlmIChtYWNyb01vZGVTdGF0ZS5pc1BsYXlpbmcpIHsgcmV0dXJuOyB9XG4gICAgICB2aW0ubGFzdEVkaXRJbnB1dFN0YXRlID0gaW5wdXRTdGF0ZTtcbiAgICAgIHZpbS5sYXN0RWRpdEFjdGlvbkNvbW1hbmQgPSBhY3Rpb25Db21tYW5kO1xuICAgICAgbWFjcm9Nb2RlU3RhdGUubGFzdEluc2VydE1vZGVDaGFuZ2VzLmNoYW5nZXMgPSBbXTtcbiAgICAgIG1hY3JvTW9kZVN0YXRlLmxhc3RJbnNlcnRNb2RlQ2hhbmdlcy5leHBlY3RDdXJzb3JBY3Rpdml0eUZvckNoYW5nZSA9IGZhbHNlO1xuICAgICAgbWFjcm9Nb2RlU3RhdGUubGFzdEluc2VydE1vZGVDaGFuZ2VzLnZpc3VhbEJsb2NrID0gdmltLnZpc3VhbEJsb2NrID8gdmltLnNlbC5oZWFkLmxpbmUgLSB2aW0uc2VsLmFuY2hvci5saW5lIDogMDtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEFsbCBvZiB0aGUgZnVuY3Rpb25zIGJlbG93IHJldHVybiBDdXJzb3Igb2JqZWN0cy5cbiAgICogQHR5cGUge2ltcG9ydChcIi4vdHlwZXNcIikudmltTW90aW9uc319XG4gICAqL1xuICB2YXIgbW90aW9ucyA9IHtcbiAgICBtb3ZlVG9Ub3BMaW5lOiBmdW5jdGlvbihjbSwgX2hlYWQsIG1vdGlvbkFyZ3MpIHtcbiAgICAgIHZhciBsaW5lID0gZ2V0VXNlclZpc2libGVMaW5lcyhjbSkudG9wICsgbW90aW9uQXJncy5yZXBlYXQgLTE7XG4gICAgICByZXR1cm4gbmV3IFBvcyhsaW5lLCBmaW5kRmlyc3ROb25XaGl0ZVNwYWNlQ2hhcmFjdGVyKGNtLmdldExpbmUobGluZSkpKTtcbiAgICB9LFxuICAgIG1vdmVUb01pZGRsZUxpbmU6IGZ1bmN0aW9uKGNtKSB7XG4gICAgICB2YXIgcmFuZ2UgPSBnZXRVc2VyVmlzaWJsZUxpbmVzKGNtKTtcbiAgICAgIHZhciBsaW5lID0gTWF0aC5mbG9vcigocmFuZ2UudG9wICsgcmFuZ2UuYm90dG9tKSAqIDAuNSk7XG4gICAgICByZXR1cm4gbmV3IFBvcyhsaW5lLCBmaW5kRmlyc3ROb25XaGl0ZVNwYWNlQ2hhcmFjdGVyKGNtLmdldExpbmUobGluZSkpKTtcbiAgICB9LFxuICAgIG1vdmVUb0JvdHRvbUxpbmU6IGZ1bmN0aW9uKGNtLCBfaGVhZCwgbW90aW9uQXJncykge1xuICAgICAgdmFyIGxpbmUgPSBnZXRVc2VyVmlzaWJsZUxpbmVzKGNtKS5ib3R0b20gLSBtb3Rpb25BcmdzLnJlcGVhdCArMTtcbiAgICAgIHJldHVybiBuZXcgUG9zKGxpbmUsIGZpbmRGaXJzdE5vbldoaXRlU3BhY2VDaGFyYWN0ZXIoY20uZ2V0TGluZShsaW5lKSkpO1xuICAgIH0sXG4gICAgZXhwYW5kVG9MaW5lOiBmdW5jdGlvbihfY20sIGhlYWQsIG1vdGlvbkFyZ3MpIHtcbiAgICAgIC8vIEV4cGFuZHMgZm9yd2FyZCB0byBlbmQgb2YgbGluZSwgYW5kIHRoZW4gdG8gbmV4dCBsaW5lIGlmIHJlcGVhdCBpc1xuICAgICAgLy8gPjEuIERvZXMgbm90IGhhbmRsZSBiYWNrd2FyZCBtb3Rpb24hXG4gICAgICB2YXIgY3VyID0gaGVhZDtcbiAgICAgIHJldHVybiBuZXcgUG9zKGN1ci5saW5lICsgbW90aW9uQXJncy5yZXBlYXQgLSAxLCBJbmZpbml0eSk7XG4gICAgfSxcbiAgICBmaW5kTmV4dDogZnVuY3Rpb24oY20sIF9oZWFkLCBtb3Rpb25BcmdzKSB7XG4gICAgICB2YXIgc3RhdGUgPSBnZXRTZWFyY2hTdGF0ZShjbSk7XG4gICAgICB2YXIgcXVlcnkgPSBzdGF0ZS5nZXRRdWVyeSgpO1xuICAgICAgaWYgKCFxdWVyeSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgcHJldiA9ICFtb3Rpb25BcmdzLmZvcndhcmQ7XG4gICAgICAvLyBJZiBzZWFyY2ggaXMgaW5pdGlhdGVkIHdpdGggPyBpbnN0ZWFkIG9mIC8sIG5lZ2F0ZSBkaXJlY3Rpb24uXG4gICAgICBwcmV2ID0gKHN0YXRlLmlzUmV2ZXJzZWQoKSkgPyAhcHJldiA6IHByZXY7XG4gICAgICBoaWdobGlnaHRTZWFyY2hNYXRjaGVzKGNtLCBxdWVyeSk7XG4gICAgICB2YXIgcmVzdWx0ID0gZmluZE5leHQoY20sIHByZXYvKiogcHJldiAqLywgcXVlcnksIG1vdGlvbkFyZ3MucmVwZWF0KTtcbiAgICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgIHNob3dDb25maXJtKGNtLCAnTm8gbWF0Y2ggZm91bmQgJyArIHF1ZXJ5ICtcbiAgICAgICAgICAoZ2V0T3B0aW9uKCdwY3JlJykgPyAnIChzZXQgbm9wY3JlIHRvIHVzZSBWaW0gcmVnZXhwcyknIDogJycpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7IFxuICAgIH0sXG4gICAgLyoqXG4gICAgICogRmluZCBhbmQgc2VsZWN0IHRoZSBuZXh0IG9jY3VycmVuY2Ugb2YgdGhlIHNlYXJjaCBxdWVyeS4gSWYgdGhlIGN1cnNvciBpcyBjdXJyZW50bHlcbiAgICAgKiB3aXRoaW4gYSBtYXRjaCwgdGhlbiBmaW5kIGFuZCBzZWxlY3QgdGhlIGN1cnJlbnQgbWF0Y2guIE90aGVyd2lzZSwgZmluZCB0aGUgbmV4dCBvY2N1cnJlbmNlIGluIHRoZVxuICAgICAqIGFwcHJvcHJpYXRlIGRpcmVjdGlvbi5cbiAgICAgKlxuICAgICAqIFRoaXMgZGlmZmVycyBmcm9tIGBmaW5kTmV4dGAgaW4gdGhlIGZvbGxvd2luZyB3YXlzOlxuICAgICAqXG4gICAgICogMS4gSW5zdGVhZCBvZiBvbmx5IHJldHVybmluZyB0aGUgXCJmcm9tXCIsIHRoaXMgcmV0dXJucyBhIFwiZnJvbVwiLCBcInRvXCIgcmFuZ2UuXG4gICAgICogMi4gSWYgdGhlIGN1cnNvciBpcyBjdXJyZW50bHkgaW5zaWRlIGEgc2VhcmNoIG1hdGNoLCB0aGlzIHNlbGVjdHMgdGhlIGN1cnJlbnQgbWF0Y2hcbiAgICAgKiAgICBpbnN0ZWFkIG9mIHRoZSBuZXh0IG1hdGNoLlxuICAgICAqIDMuIElmIHRoZXJlIGlzIG5vIGFzc29jaWF0ZWQgb3BlcmF0b3IsIHRoaXMgd2lsbCB0dXJuIG9uIHZpc3VhbCBtb2RlLlxuICAgICAqL1xuICAgIGZpbmRBbmRTZWxlY3ROZXh0SW5jbHVzaXZlOiBmdW5jdGlvbihjbSwgX2hlYWQsIG1vdGlvbkFyZ3MsIHZpbSwgcHJldklucHV0U3RhdGUpIHtcbiAgICAgIHZhciBzdGF0ZSA9IGdldFNlYXJjaFN0YXRlKGNtKTtcbiAgICAgIHZhciBxdWVyeSA9IHN0YXRlLmdldFF1ZXJ5KCk7XG5cbiAgICAgIGlmICghcXVlcnkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgcHJldiA9ICFtb3Rpb25BcmdzLmZvcndhcmQ7XG4gICAgICBwcmV2ID0gKHN0YXRlLmlzUmV2ZXJzZWQoKSkgPyAhcHJldiA6IHByZXY7XG5cbiAgICAgIC8vIG5leHQ6IFtmcm9tLCB0b10gfCBudWxsXG4gICAgICB2YXIgbmV4dCA9IGZpbmROZXh0RnJvbUFuZFRvSW5jbHVzaXZlKGNtLCBwcmV2LCBxdWVyeSwgbW90aW9uQXJncy5yZXBlYXQsIHZpbSk7XG5cbiAgICAgIC8vIE5vIG1hdGNoZXMuXG4gICAgICBpZiAoIW5leHQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBJZiB0aGVyZSdzIGFuIG9wZXJhdG9yIHRoYXQgd2lsbCBiZSBleGVjdXRlZCwgcmV0dXJuIHRoZSBzZWxlY3Rpb24uXG4gICAgICBpZiAocHJldklucHV0U3RhdGUub3BlcmF0b3IpIHtcbiAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICB9XG5cbiAgICAgIC8vIEF0IHRoaXMgcG9pbnQsIHdlIGtub3cgdGhhdCB0aGVyZSBpcyBubyBhY2NvbXBhbnlpbmcgb3BlcmF0b3IgLS0gbGV0J3NcbiAgICAgIC8vIGRlYWwgd2l0aCB2aXN1YWwgbW9kZSBpbiBvcmRlciB0byBzZWxlY3QgYW4gYXBwcm9wcmlhdGUgbWF0Y2guXG5cbiAgICAgIHZhciBmcm9tID0gbmV4dFswXTtcbiAgICAgIC8vIEZvciB3aGF0ZXZlciByZWFzb24sIHdoZW4gd2UgdXNlIHRoZSBcInRvXCIgYXMgcmV0dXJuZWQgYnkgc2VhcmNoY3Vyc29yLmpzIGRpcmVjdGx5LFxuICAgICAgLy8gdGhlIHJlc3VsdGluZyBzZWxlY3Rpb24gaXMgZXh0ZW5kZWQgYnkgMSBjaGFyLiBMZXQncyBzaHJpbmsgaXQgc28gdGhhdCBvbmx5IHRoZVxuICAgICAgLy8gbWF0Y2ggaXMgc2VsZWN0ZWQuXG4gICAgICB2YXIgdG8gPSBuZXcgUG9zKG5leHRbMV0ubGluZSwgbmV4dFsxXS5jaCAtIDEpO1xuXG4gICAgICBpZiAodmltLnZpc3VhbE1vZGUpIHtcbiAgICAgICAgLy8gSWYgd2Ugd2VyZSBpbiB2aXN1YWxMaW5lIG9yIHZpc3VhbEJsb2NrIG1vZGUsIGdldCBvdXQgb2YgaXQuXG4gICAgICAgIGlmICh2aW0udmlzdWFsTGluZSB8fCB2aW0udmlzdWFsQmxvY2spIHtcbiAgICAgICAgICB2aW0udmlzdWFsTGluZSA9IGZhbHNlO1xuICAgICAgICAgIHZpbS52aXN1YWxCbG9jayA9IGZhbHNlO1xuICAgICAgICAgIENNLnNpZ25hbChjbSwgXCJ2aW0tbW9kZS1jaGFuZ2VcIiwge21vZGU6IFwidmlzdWFsXCIsIHN1Yk1vZGU6IFwiXCJ9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIHdlJ3JlIGN1cnJlbnRseSBpbiB2aXN1YWwgbW9kZSwgd2Ugc2hvdWxkIGV4dGVuZCB0aGUgc2VsZWN0aW9uIHRvIGluY2x1ZGVcbiAgICAgICAgLy8gdGhlIHNlYXJjaCByZXN1bHQuXG4gICAgICAgIHZhciBhbmNob3IgPSB2aW0uc2VsLmFuY2hvcjtcbiAgICAgICAgaWYgKGFuY2hvcikge1xuICAgICAgICAgIGlmIChzdGF0ZS5pc1JldmVyc2VkKCkpIHtcbiAgICAgICAgICAgIGlmIChtb3Rpb25BcmdzLmZvcndhcmQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIFthbmNob3IsIGZyb21dO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gW2FuY2hvciwgdG9dO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAobW90aW9uQXJncy5mb3J3YXJkKSB7XG4gICAgICAgICAgICAgIHJldHVybiBbYW5jaG9yLCB0b107XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBbYW5jaG9yLCBmcm9tXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIExldCdzIHR1cm4gdmlzdWFsIG1vZGUgb24uXG4gICAgICAgIHZpbS52aXN1YWxNb2RlID0gdHJ1ZTtcbiAgICAgICAgdmltLnZpc3VhbExpbmUgPSBmYWxzZTtcbiAgICAgICAgdmltLnZpc3VhbEJsb2NrID0gZmFsc2U7XG4gICAgICAgIENNLnNpZ25hbChjbSwgXCJ2aW0tbW9kZS1jaGFuZ2VcIiwge21vZGU6IFwidmlzdWFsXCIsIHN1Yk1vZGU6IFwiXCJ9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHByZXYgPyBbdG8sIGZyb21dIDogW2Zyb20sIHRvXTtcbiAgICB9LFxuICAgIGdvVG9NYXJrOiBmdW5jdGlvbihjbSwgX2hlYWQsIG1vdGlvbkFyZ3MsIHZpbSkge1xuICAgICAgdmFyIHBvcyA9IGdldE1hcmtQb3MoY20sIHZpbSwgbW90aW9uQXJncy5zZWxlY3RlZENoYXJhY3RlciB8fCBcIlwiKTtcbiAgICAgIGlmIChwb3MpIHtcbiAgICAgICAgcmV0dXJuIG1vdGlvbkFyZ3MubGluZXdpc2UgPyB7IGxpbmU6IHBvcy5saW5lLCBjaDogZmluZEZpcnN0Tm9uV2hpdGVTcGFjZUNoYXJhY3RlcihjbS5nZXRMaW5lKHBvcy5saW5lKSkgfSA6IHBvcztcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0sXG4gICAgbW92ZVRvT3RoZXJIaWdobGlnaHRlZEVuZDogZnVuY3Rpb24oY20sIF9oZWFkLCBtb3Rpb25BcmdzLCB2aW0pIHtcbiAgICAgIHZhciBzZWwgPSB2aW0uc2VsO1xuICAgICAgaWYgKHZpbS52aXN1YWxCbG9jayAmJiBtb3Rpb25BcmdzLnNhbWVMaW5lKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgY2xpcEN1cnNvclRvQ29udGVudChjbSwgbmV3IFBvcyhzZWwuYW5jaG9yLmxpbmUsIHNlbC5oZWFkLmNoKSksXG4gICAgICAgICAgY2xpcEN1cnNvclRvQ29udGVudChjbSwgbmV3IFBvcyhzZWwuaGVhZC5saW5lLCBzZWwuYW5jaG9yLmNoKSlcbiAgICAgICAgXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAoW3NlbC5oZWFkLCBzZWwuYW5jaG9yXSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBqdW1wVG9NYXJrOiBmdW5jdGlvbihjbSwgaGVhZCwgbW90aW9uQXJncywgdmltKSB7XG4gICAgICB2YXIgYmVzdCA9IGhlYWQ7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1vdGlvbkFyZ3MucmVwZWF0OyBpKyspIHtcbiAgICAgICAgdmFyIGN1cnNvciA9IGJlc3Q7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiB2aW0ubWFya3MpIHtcbiAgICAgICAgICBpZiAoIWlzTG93ZXJDYXNlKGtleSkpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgbWFyayA9IHZpbS5tYXJrc1trZXldLmZpbmQoKTtcbiAgICAgICAgICB2YXIgaXNXcm9uZ0RpcmVjdGlvbiA9IChtb3Rpb25BcmdzLmZvcndhcmQpID9cbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIGN1cnNvcklzQmVmb3JlKG1hcmssIGN1cnNvcikgOiBjdXJzb3JJc0JlZm9yZShjdXJzb3IsIG1hcmspO1xuXG4gICAgICAgICAgaWYgKGlzV3JvbmdEaXJlY3Rpb24pIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgaWYgKG1vdGlvbkFyZ3MubGluZXdpc2UgJiYgKG1hcmsubGluZSA9PSBjdXJzb3IubGluZSkpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBlcXVhbCA9IGN1cnNvckVxdWFsKGN1cnNvciwgYmVzdCk7XG4gICAgICAgICAgdmFyIGJldHdlZW4gPSAobW90aW9uQXJncy5mb3J3YXJkKSA/XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICBjdXJzb3JJc0JldHdlZW4oY3Vyc29yLCBtYXJrLCBiZXN0KSA6XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICBjdXJzb3JJc0JldHdlZW4oYmVzdCwgbWFyaywgY3Vyc29yKTtcblxuICAgICAgICAgIGlmIChlcXVhbCB8fCBiZXR3ZWVuKSB7XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICBiZXN0ID0gbWFyaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKG1vdGlvbkFyZ3MubGluZXdpc2UpIHtcbiAgICAgICAgLy8gVmltIHBsYWNlcyB0aGUgY3Vyc29yIG9uIHRoZSBmaXJzdCBub24td2hpdGVzcGFjZSBjaGFyYWN0ZXIgb2ZcbiAgICAgICAgLy8gdGhlIGxpbmUgaWYgdGhlcmUgaXMgb25lLCBlbHNlIGl0IHBsYWNlcyB0aGUgY3Vyc29yIGF0IHRoZSBlbmRcbiAgICAgICAgLy8gb2YgdGhlIGxpbmUsIHJlZ2FyZGxlc3Mgb2Ygd2hldGhlciBhIG1hcmsgd2FzIGZvdW5kLlxuICAgICAgICBiZXN0ID0gbmV3IFBvcyhiZXN0LmxpbmUsIGZpbmRGaXJzdE5vbldoaXRlU3BhY2VDaGFyYWN0ZXIoY20uZ2V0TGluZShiZXN0LmxpbmUpKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYmVzdDtcbiAgICB9LFxuICAgIG1vdmVCeUNoYXJhY3RlcnM6IGZ1bmN0aW9uKF9jbSwgaGVhZCwgbW90aW9uQXJncykge1xuICAgICAgdmFyIGN1ciA9IGhlYWQ7XG4gICAgICB2YXIgcmVwZWF0ID0gbW90aW9uQXJncy5yZXBlYXQ7XG4gICAgICB2YXIgY2ggPSBtb3Rpb25BcmdzLmZvcndhcmQgPyBjdXIuY2ggKyByZXBlYXQgOiBjdXIuY2ggLSByZXBlYXQ7XG4gICAgICByZXR1cm4gbmV3IFBvcyhjdXIubGluZSwgY2gpO1xuICAgIH0sXG4gICAgbW92ZUJ5TGluZXM6IGZ1bmN0aW9uKGNtLCBoZWFkLCBtb3Rpb25BcmdzLCB2aW0pIHtcbiAgICAgIHZhciBjdXIgPSBoZWFkO1xuICAgICAgdmFyIGVuZENoID0gY3VyLmNoO1xuICAgICAgLy8gRGVwZW5kaW5nIHdoYXQgb3VyIGxhc3QgbW90aW9uIHdhcywgd2UgbWF5IHdhbnQgdG8gZG8gZGlmZmVyZW50XG4gICAgICAvLyB0aGluZ3MuIElmIG91ciBsYXN0IG1vdGlvbiB3YXMgbW92aW5nIHZlcnRpY2FsbHksIHdlIHdhbnQgdG9cbiAgICAgIC8vIHByZXNlcnZlIHRoZSBIUG9zIGZyb20gb3VyIGxhc3QgaG9yaXpvbnRhbCBtb3ZlLiAgSWYgb3VyIGxhc3QgbW90aW9uXG4gICAgICAvLyB3YXMgZ29pbmcgdG8gdGhlIGVuZCBvZiBhIGxpbmUsIG1vdmluZyB2ZXJ0aWNhbGx5IHdlIHNob3VsZCBnbyB0b1xuICAgICAgLy8gdGhlIGVuZCBvZiB0aGUgbGluZSwgZXRjLlxuICAgICAgc3dpdGNoICh2aW0ubGFzdE1vdGlvbikge1xuICAgICAgICBjYXNlIHRoaXMubW92ZUJ5TGluZXM6XG4gICAgICAgIGNhc2UgdGhpcy5tb3ZlQnlEaXNwbGF5TGluZXM6XG4gICAgICAgIGNhc2UgdGhpcy5tb3ZlQnlTY3JvbGw6XG4gICAgICAgIGNhc2UgdGhpcy5tb3ZlVG9Db2x1bW46XG4gICAgICAgIGNhc2UgdGhpcy5tb3ZlVG9Fb2w6XG4gICAgICAgICAgZW5kQ2ggPSB2aW0ubGFzdEhQb3M7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdmltLmxhc3RIUG9zID0gZW5kQ2g7XG4gICAgICB9XG4gICAgICB2YXIgcmVwZWF0ID0gbW90aW9uQXJncy5yZXBlYXQrKG1vdGlvbkFyZ3MucmVwZWF0T2Zmc2V0fHwwKTtcbiAgICAgIHZhciBsaW5lID0gbW90aW9uQXJncy5mb3J3YXJkID8gY3VyLmxpbmUgKyByZXBlYXQgOiBjdXIubGluZSAtIHJlcGVhdDtcbiAgICAgIHZhciBmaXJzdCA9IGNtLmZpcnN0TGluZSgpO1xuICAgICAgdmFyIGxhc3QgPSBjbS5sYXN0TGluZSgpO1xuICAgICAgdmFyIHBvc1YgPSBjbS5maW5kUG9zVihjdXIsIChtb3Rpb25BcmdzLmZvcndhcmQgPyByZXBlYXQgOiAtcmVwZWF0KSwgJ2xpbmUnLCB2aW0ubGFzdEhTUG9zKTtcbiAgICAgIHZhciBoYXNNYXJrZWRUZXh0ID0gbW90aW9uQXJncy5mb3J3YXJkID8gcG9zVi5saW5lID4gbGluZSA6IHBvc1YubGluZSA8IGxpbmU7XG4gICAgICBpZiAoaGFzTWFya2VkVGV4dCkge1xuICAgICAgICBsaW5lID0gcG9zVi5saW5lO1xuICAgICAgICBlbmRDaCA9IHBvc1YuY2g7XG4gICAgICB9XG4gICAgICAvLyBWaW0gZ28gdG8gbGluZSBiZWdpbiBvciBsaW5lIGVuZCB3aGVuIGN1cnNvciBhdCBmaXJzdC9sYXN0IGxpbmUgYW5kXG4gICAgICAvLyBtb3ZlIHRvIHByZXZpb3VzL25leHQgbGluZSBpcyB0cmlnZ2VyZWQuXG4gICAgICBpZiAobGluZSA8IGZpcnN0ICYmIGN1ci5saW5lID09IGZpcnN0KXtcbiAgICAgICAgcmV0dXJuIHRoaXMubW92ZVRvU3RhcnRPZkxpbmUoY20sIGhlYWQsIG1vdGlvbkFyZ3MsIHZpbSk7XG4gICAgICB9IGVsc2UgaWYgKGxpbmUgPiBsYXN0ICYmIGN1ci5saW5lID09IGxhc3Qpe1xuICAgICAgICAgIHJldHVybiBtb3ZlVG9Fb2woY20sIGhlYWQsIG1vdGlvbkFyZ3MsIHZpbSwgdHJ1ZSk7XG4gICAgICB9XG4gICAgICBpZiAobW90aW9uQXJncy50b0ZpcnN0Q2hhcil7XG4gICAgICAgIGVuZENoPWZpbmRGaXJzdE5vbldoaXRlU3BhY2VDaGFyYWN0ZXIoY20uZ2V0TGluZShsaW5lKSk7XG4gICAgICAgIHZpbS5sYXN0SFBvcyA9IGVuZENoO1xuICAgICAgfVxuICAgICAgdmltLmxhc3RIU1BvcyA9IGNtLmNoYXJDb29yZHMobmV3IFBvcyhsaW5lLCBlbmRDaCksJ2RpdicpLmxlZnQ7XG4gICAgICByZXR1cm4gbmV3IFBvcyhsaW5lLCBlbmRDaCk7XG4gICAgfSxcbiAgICBtb3ZlQnlEaXNwbGF5TGluZXM6IGZ1bmN0aW9uKGNtLCBoZWFkLCBtb3Rpb25BcmdzLCB2aW0pIHtcbiAgICAgIHZhciBjdXIgPSBoZWFkO1xuICAgICAgc3dpdGNoICh2aW0ubGFzdE1vdGlvbikge1xuICAgICAgICBjYXNlIHRoaXMubW92ZUJ5RGlzcGxheUxpbmVzOlxuICAgICAgICBjYXNlIHRoaXMubW92ZUJ5U2Nyb2xsOlxuICAgICAgICBjYXNlIHRoaXMubW92ZUJ5TGluZXM6XG4gICAgICAgIGNhc2UgdGhpcy5tb3ZlVG9Db2x1bW46XG4gICAgICAgIGNhc2UgdGhpcy5tb3ZlVG9Fb2w6XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdmltLmxhc3RIU1BvcyA9IGNtLmNoYXJDb29yZHMoY3VyLCdkaXYnKS5sZWZ0O1xuICAgICAgfVxuICAgICAgdmFyIHJlcGVhdCA9IG1vdGlvbkFyZ3MucmVwZWF0O1xuICAgICAgdmFyIHJlcz1jbS5maW5kUG9zVihjdXIsKG1vdGlvbkFyZ3MuZm9yd2FyZCA/IHJlcGVhdCA6IC1yZXBlYXQpLCdsaW5lJyx2aW0ubGFzdEhTUG9zKTtcbiAgICAgIGlmIChyZXMuaGl0U2lkZSkge1xuICAgICAgICBpZiAobW90aW9uQXJncy5mb3J3YXJkKSB7XG4gICAgICAgICAgdmFyIGxhc3RDaGFyQ29vcmRzID0gY20uY2hhckNvb3JkcyhyZXMsICdkaXYnKTtcbiAgICAgICAgICB2YXIgZ29hbENvb3JkcyA9IHsgdG9wOiBsYXN0Q2hhckNvb3Jkcy50b3AgKyA4LCBsZWZ0OiB2aW0ubGFzdEhTUG9zIH07XG4gICAgICAgICAgcmVzID0gY20uY29vcmRzQ2hhcihnb2FsQ29vcmRzLCAnZGl2Jyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHJlc0Nvb3JkcyA9IGNtLmNoYXJDb29yZHMobmV3IFBvcyhjbS5maXJzdExpbmUoKSwgMCksICdkaXYnKTtcbiAgICAgICAgICByZXNDb29yZHMubGVmdCA9IHZpbS5sYXN0SFNQb3M7XG4gICAgICAgICAgcmVzID0gY20uY29vcmRzQ2hhcihyZXNDb29yZHMsICdkaXYnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmltLmxhc3RIUG9zID0gcmVzLmNoO1xuICAgICAgcmV0dXJuIHJlcztcbiAgICB9LFxuICAgIG1vdmVCeVBhZ2U6IGZ1bmN0aW9uKGNtLCBoZWFkLCBtb3Rpb25BcmdzKSB7XG4gICAgICAvLyBDb2RlTWlycm9yIG9ubHkgZXhwb3NlcyBmdW5jdGlvbnMgdGhhdCBtb3ZlIHRoZSBjdXJzb3IgcGFnZSBkb3duLCBzb1xuICAgICAgLy8gZG9pbmcgdGhpcyBiYWQgaGFjayB0byBtb3ZlIHRoZSBjdXJzb3IgYW5kIG1vdmUgaXQgYmFjay4gZXZhbElucHV0XG4gICAgICAvLyB3aWxsIG1vdmUgdGhlIGN1cnNvciB0byB3aGVyZSBpdCBzaG91bGQgYmUgaW4gdGhlIGVuZC5cbiAgICAgIHZhciBjdXJTdGFydCA9IGhlYWQ7XG4gICAgICB2YXIgcmVwZWF0ID0gbW90aW9uQXJncy5yZXBlYXQ7XG4gICAgICByZXR1cm4gY20uZmluZFBvc1YoY3VyU3RhcnQsIChtb3Rpb25BcmdzLmZvcndhcmQgPyByZXBlYXQgOiAtcmVwZWF0KSwgJ3BhZ2UnKTtcbiAgICB9LFxuICAgIG1vdmVCeVBhcmFncmFwaDogZnVuY3Rpb24oY20sIGhlYWQsIG1vdGlvbkFyZ3MpIHtcbiAgICAgIHZhciBkaXIgPSBtb3Rpb25BcmdzLmZvcndhcmQgPyAxIDogLTE7XG4gICAgICByZXR1cm4gZmluZFBhcmFncmFwaChjbSwgaGVhZCwgbW90aW9uQXJncy5yZXBlYXQsIGRpcikuc3RhcnQ7XG4gICAgfSxcbiAgICBtb3ZlQnlTZW50ZW5jZTogZnVuY3Rpb24oY20sIGhlYWQsIG1vdGlvbkFyZ3MpIHtcbiAgICAgIHZhciBkaXIgPSBtb3Rpb25BcmdzLmZvcndhcmQgPyAxIDogLTE7XG4gICAgICByZXR1cm4gZmluZFNlbnRlbmNlKGNtLCBoZWFkLCBtb3Rpb25BcmdzLnJlcGVhdCwgZGlyKTtcbiAgICB9LFxuICAgIG1vdmVCeVNjcm9sbDogZnVuY3Rpb24oY20sIGhlYWQsIG1vdGlvbkFyZ3MsIHZpbSkge1xuICAgICAgdmFyIHNjcm9sbGJveCA9IGNtLmdldFNjcm9sbEluZm8oKTtcbiAgICAgIHZhciBjdXJFbmQgPSBudWxsO1xuICAgICAgdmFyIHJlcGVhdCA9IG1vdGlvbkFyZ3MucmVwZWF0O1xuICAgICAgaWYgKCFyZXBlYXQpIHtcbiAgICAgICAgcmVwZWF0ID0gc2Nyb2xsYm94LmNsaWVudEhlaWdodCAvICgyICogY20uZGVmYXVsdFRleHRIZWlnaHQoKSk7XG4gICAgICB9XG4gICAgICB2YXIgb3JpZyA9IGNtLmNoYXJDb29yZHMoaGVhZCwgJ2xvY2FsJyk7XG4gICAgICBtb3Rpb25BcmdzLnJlcGVhdCA9IHJlcGVhdDtcbiAgICAgIGN1ckVuZCA9IG1vdGlvbnMubW92ZUJ5RGlzcGxheUxpbmVzKGNtLCBoZWFkLCBtb3Rpb25BcmdzLCB2aW0pO1xuICAgICAgaWYgKCFjdXJFbmQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICB2YXIgZGVzdCA9IGNtLmNoYXJDb29yZHMoY3VyRW5kLCAnbG9jYWwnKTtcbiAgICAgIGNtLnNjcm9sbFRvKG51bGwsIHNjcm9sbGJveC50b3AgKyBkZXN0LnRvcCAtIG9yaWcudG9wKTtcbiAgICAgIHJldHVybiBjdXJFbmQ7XG4gICAgfSxcbiAgICBtb3ZlQnlXb3JkczogZnVuY3Rpb24oY20sIGhlYWQsIG1vdGlvbkFyZ3MpIHtcbiAgICAgIHJldHVybiBtb3ZlVG9Xb3JkKGNtLCBoZWFkLCBtb3Rpb25BcmdzLnJlcGVhdCwgISFtb3Rpb25BcmdzLmZvcndhcmQsXG4gICAgICAgICAgISFtb3Rpb25BcmdzLndvcmRFbmQsICEhbW90aW9uQXJncy5iaWdXb3JkKTtcbiAgICB9LFxuICAgIG1vdmVUaWxsQ2hhcmFjdGVyOiBmdW5jdGlvbihjbSwgaGVhZCwgbW90aW9uQXJncykge1xuICAgICAgdmFyIHJlcGVhdCA9IG1vdGlvbkFyZ3MucmVwZWF0O1xuICAgICAgdmFyIGN1ckVuZCA9IG1vdmVUb0NoYXJhY3RlcihjbSwgcmVwZWF0LCBtb3Rpb25BcmdzLmZvcndhcmQsXG4gICAgICAgICAgbW90aW9uQXJncy5zZWxlY3RlZENoYXJhY3RlciwgaGVhZCk7XG4gICAgICB2YXIgaW5jcmVtZW50ID0gbW90aW9uQXJncy5mb3J3YXJkID8gLTEgOiAxO1xuICAgICAgcmVjb3JkTGFzdENoYXJhY3RlclNlYXJjaChpbmNyZW1lbnQsIG1vdGlvbkFyZ3MpO1xuICAgICAgaWYgKCFjdXJFbmQpIHJldHVybiBudWxsO1xuICAgICAgY3VyRW5kLmNoICs9IGluY3JlbWVudDtcbiAgICAgIHJldHVybiBjdXJFbmQ7XG4gICAgfSxcbiAgICBtb3ZlVG9DaGFyYWN0ZXI6IGZ1bmN0aW9uKGNtLCBoZWFkLCBtb3Rpb25BcmdzKSB7XG4gICAgICB2YXIgcmVwZWF0ID0gbW90aW9uQXJncy5yZXBlYXQ7XG4gICAgICByZWNvcmRMYXN0Q2hhcmFjdGVyU2VhcmNoKDAsIG1vdGlvbkFyZ3MpO1xuICAgICAgcmV0dXJuIG1vdmVUb0NoYXJhY3RlcihjbSwgcmVwZWF0LCBtb3Rpb25BcmdzLmZvcndhcmQsXG4gICAgICAgICAgbW90aW9uQXJncy5zZWxlY3RlZENoYXJhY3RlciwgaGVhZCkgfHwgaGVhZDtcbiAgICB9LFxuICAgIG1vdmVUb1N5bWJvbDogZnVuY3Rpb24oY20sIGhlYWQsIG1vdGlvbkFyZ3MpIHtcbiAgICAgIHZhciByZXBlYXQgPSBtb3Rpb25BcmdzLnJlcGVhdDtcbiAgICAgIHJldHVybiBtb3Rpb25BcmdzLnNlbGVjdGVkQ2hhcmFjdGVyXG4gICAgICAgJiYgZmluZFN5bWJvbChjbSwgcmVwZWF0LCBtb3Rpb25BcmdzLmZvcndhcmQsXG4gICAgICAgICAgbW90aW9uQXJncy5zZWxlY3RlZENoYXJhY3RlcikgfHwgaGVhZDtcbiAgICB9LFxuICAgIG1vdmVUb0NvbHVtbjogZnVuY3Rpb24oY20sIGhlYWQsIG1vdGlvbkFyZ3MsIHZpbSkge1xuICAgICAgdmFyIHJlcGVhdCA9IG1vdGlvbkFyZ3MucmVwZWF0O1xuICAgICAgLy8gcmVwZWF0IGlzIGVxdWl2YWxlbnQgdG8gd2hpY2ggY29sdW1uIHdlIHdhbnQgdG8gbW92ZSB0byFcbiAgICAgIHZpbS5sYXN0SFBvcyA9IHJlcGVhdCAtIDE7XG4gICAgICB2aW0ubGFzdEhTUG9zID0gY20uY2hhckNvb3JkcyhoZWFkLCdkaXYnKS5sZWZ0O1xuICAgICAgcmV0dXJuIG1vdmVUb0NvbHVtbihjbSwgcmVwZWF0KTtcbiAgICB9LFxuICAgIG1vdmVUb0VvbDogZnVuY3Rpb24oY20sIGhlYWQsIG1vdGlvbkFyZ3MsIHZpbSkge1xuICAgICAgcmV0dXJuIG1vdmVUb0VvbChjbSwgaGVhZCwgbW90aW9uQXJncywgdmltLCBmYWxzZSk7XG4gICAgfSxcbiAgICBtb3ZlVG9GaXJzdE5vbldoaXRlU3BhY2VDaGFyYWN0ZXI6IGZ1bmN0aW9uKGNtLCBoZWFkKSB7XG4gICAgICAvLyBHbyB0byB0aGUgc3RhcnQgb2YgdGhlIGxpbmUgd2hlcmUgdGhlIHRleHQgYmVnaW5zLCBvciB0aGUgZW5kIGZvclxuICAgICAgLy8gd2hpdGVzcGFjZS1vbmx5IGxpbmVzXG4gICAgICB2YXIgY3Vyc29yID0gaGVhZDtcbiAgICAgIHJldHVybiBuZXcgUG9zKGN1cnNvci5saW5lLFxuICAgICAgICAgICAgICAgICAgZmluZEZpcnN0Tm9uV2hpdGVTcGFjZUNoYXJhY3RlcihjbS5nZXRMaW5lKGN1cnNvci5saW5lKSkpO1xuICAgIH0sXG4gICAgbW92ZVRvTWF0Y2hlZFN5bWJvbDogZnVuY3Rpb24oY20sIGhlYWQpIHtcbiAgICAgIHZhciBjdXJzb3IgPSBoZWFkO1xuICAgICAgdmFyIGxpbmUgPSBjdXJzb3IubGluZTtcbiAgICAgIHZhciBjaCA9IGN1cnNvci5jaDtcbiAgICAgIHZhciBsaW5lVGV4dCA9IGNtLmdldExpbmUobGluZSk7XG4gICAgICB2YXIgc3ltYm9sO1xuICAgICAgZm9yICg7IGNoIDwgbGluZVRleHQubGVuZ3RoOyBjaCsrKSB7XG4gICAgICAgIHN5bWJvbCA9IGxpbmVUZXh0LmNoYXJBdChjaCk7XG4gICAgICAgIGlmIChzeW1ib2wgJiYgaXNNYXRjaGFibGVTeW1ib2woc3ltYm9sKSkge1xuICAgICAgICAgIHZhciBzdHlsZSA9IGNtLmdldFRva2VuVHlwZUF0KG5ldyBQb3MobGluZSwgY2ggKyAxKSk7XG4gICAgICAgICAgaWYgKHN0eWxlICE9PSBcInN0cmluZ1wiICYmIHN0eWxlICE9PSBcImNvbW1lbnRcIikge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoY2ggPCBsaW5lVGV4dC5sZW5ndGgpIHtcbiAgICAgICAgLy8gT25seSBpbmNsdWRlIGFuZ2xlIGJyYWNrZXRzIGluIGFuYWx5c2lzIGlmIHRoZXkgYXJlIGJlaW5nIG1hdGNoZWQuXG4gICAgICAgIHZhciByZSA9IChzeW1ib2wgPT09ICc8JyB8fCBzeW1ib2wgPT09ICc+JykgPyAvWygpe31bXFxdPD5dLyA6IC9bKCl7fVtcXF1dLztcbiAgICAgICAgdmFyIG1hdGNoZWQgPSBjbS5maW5kTWF0Y2hpbmdCcmFja2V0KG5ldyBQb3MobGluZSwgY2gpLCB7YnJhY2tldFJlZ2V4OiByZX0pO1xuICAgICAgICByZXR1cm4gbWF0Y2hlZC50bztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBjdXJzb3I7XG4gICAgICB9XG4gICAgfSxcbiAgICBtb3ZlVG9TdGFydE9mTGluZTogZnVuY3Rpb24oX2NtLCBoZWFkKSB7XG4gICAgICByZXR1cm4gbmV3IFBvcyhoZWFkLmxpbmUsIDApO1xuICAgIH0sXG4gICAgbW92ZVRvTGluZU9yRWRnZU9mRG9jdW1lbnQ6IGZ1bmN0aW9uKGNtLCBfaGVhZCwgbW90aW9uQXJncykge1xuICAgICAgdmFyIGxpbmVOdW0gPSBtb3Rpb25BcmdzLmZvcndhcmQgPyBjbS5sYXN0TGluZSgpIDogY20uZmlyc3RMaW5lKCk7XG4gICAgICBpZiAobW90aW9uQXJncy5yZXBlYXRJc0V4cGxpY2l0KSB7XG4gICAgICAgIGxpbmVOdW0gPSBtb3Rpb25BcmdzLnJlcGVhdCAtIGNtLmdldE9wdGlvbignZmlyc3RMaW5lTnVtYmVyJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IFBvcyhsaW5lTnVtLFxuICAgICAgICAgICAgICAgICAgZmluZEZpcnN0Tm9uV2hpdGVTcGFjZUNoYXJhY3RlcihjbS5nZXRMaW5lKGxpbmVOdW0pKSk7XG4gICAgfSxcbiAgICBtb3ZlVG9TdGFydE9mRGlzcGxheUxpbmU6IGZ1bmN0aW9uKGNtKSB7XG4gICAgICBjbS5leGVjQ29tbWFuZChcImdvTGluZUxlZnRcIik7XG4gICAgICByZXR1cm4gY20uZ2V0Q3Vyc29yKCk7XG4gICAgfSxcbiAgICBtb3ZlVG9FbmRPZkRpc3BsYXlMaW5lOiBmdW5jdGlvbihjbSkge1xuICAgICAgY20uZXhlY0NvbW1hbmQoXCJnb0xpbmVSaWdodFwiKTtcbiAgICAgIHZhciBoZWFkID0gY20uZ2V0Q3Vyc29yKCk7XG4gICAgICBpZiAoaGVhZC5zdGlja3kgPT0gXCJiZWZvcmVcIikgaGVhZC5jaC0tO1xuICAgICAgcmV0dXJuIGhlYWQ7XG4gICAgfSxcbiAgICB0ZXh0T2JqZWN0TWFuaXB1bGF0aW9uOiBmdW5jdGlvbihjbSwgaGVhZCwgbW90aW9uQXJncywgdmltKSB7XG4gICAgICAvLyBUT0RPOiBsb3RzIG9mIHBvc3NpYmxlIGV4Y2VwdGlvbnMgdGhhdCBjYW4gYmUgdGhyb3duIGhlcmUuIFRyeSBkYShcbiAgICAgIC8vICAgICBvdXRzaWRlIG9mIGEgKCkgYmxvY2suXG4gICAgICAvKiogQHR5cGV7T2JqZWN0PHN0cmluZywgc3RyaW5nPn0gKi9cbiAgICAgIHZhciBtaXJyb3JlZFBhaXJzID0geycoJzogJyknLCAnKSc6ICcoJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAneyc6ICd9JywgJ30nOiAneycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ1snOiAnXScsICddJzogJ1snLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICc8JzogJz4nLCAnPic6ICc8J307XG4gICAgICAvKiogQHR5cGV7T2JqZWN0PHN0cmluZywgYm9vbGVhbj59ICovXG4gICAgICB2YXIgc2VsZlBhaXJlZCA9IHsnXFwnJzogdHJ1ZSwgJ1wiJzogdHJ1ZSwgJ2AnOiB0cnVlfTtcblxuICAgICAgdmFyIGNoYXJhY3RlciA9IG1vdGlvbkFyZ3Muc2VsZWN0ZWRDaGFyYWN0ZXIgfHwgXCJcIjtcbiAgICAgIC8vICdiJyByZWZlcnMgdG8gICcoKScgYmxvY2suXG4gICAgICAvLyAnQicgcmVmZXJzIHRvICAne30nIGJsb2NrLlxuICAgICAgaWYgKGNoYXJhY3RlciA9PSAnYicpIHtcbiAgICAgICAgY2hhcmFjdGVyID0gJygnO1xuICAgICAgfSBlbHNlIGlmIChjaGFyYWN0ZXIgPT0gJ0InKSB7XG4gICAgICAgIGNoYXJhY3RlciA9ICd7JztcbiAgICAgIH1cblxuICAgICAgLy8gSW5jbHVzaXZlIGlzIHRoZSBkaWZmZXJlbmNlIGJldHdlZW4gYSBhbmQgaVxuICAgICAgLy8gVE9ETzogSW5zdGVhZCBvZiB1c2luZyB0aGUgYWRkaXRpb25hbCB0ZXh0IG9iamVjdCBtYXAgdG8gcGVyZm9ybSB0ZXh0XG4gICAgICAvLyAgICAgb2JqZWN0IG9wZXJhdGlvbnMsIG1lcmdlIHRoZSBtYXAgaW50byB0aGUgZGVmYXVsdEtleU1hcCBhbmQgdXNlXG4gICAgICAvLyAgICAgbW90aW9uQXJncyB0byBkZWZpbmUgYmVoYXZpb3IuIERlZmluZSBzZXBhcmF0ZSBlbnRyaWVzIGZvciAnYXcnLFxuICAgICAgLy8gICAgICdpdycsICdhWycsICdpWycsIGV0Yy5cbiAgICAgIHZhciBpbmNsdXNpdmUgPSAhbW90aW9uQXJncy50ZXh0T2JqZWN0SW5uZXI7XG5cbiAgICAgIHZhciB0bXAsIG1vdmU7XG4gICAgICBpZiAobWlycm9yZWRQYWlyc1tjaGFyYWN0ZXJdKSB7XG4gICAgICAgIG1vdmUgPSB0cnVlO1xuICAgICAgICB0bXAgPSBzZWxlY3RDb21wYW5pb25PYmplY3QoY20sIGhlYWQsIGNoYXJhY3RlciwgaW5jbHVzaXZlKTtcbiAgICAgICAgaWYgKCF0bXApIHtcbiAgICAgICAgICB2YXIgc2MgPSBjbS5nZXRTZWFyY2hDdXJzb3IobmV3IFJlZ0V4cChcIlxcXFxcIiArIGNoYXJhY3RlciwgXCJnXCIpLCBoZWFkKTtcbiAgICAgICAgICBpZiAoc2MuZmluZCgpKSB7XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICB0bXAgPSBzZWxlY3RDb21wYW5pb25PYmplY3QoY20sIHNjLmZyb20oKSwgY2hhcmFjdGVyLCBpbmNsdXNpdmUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChzZWxmUGFpcmVkW2NoYXJhY3Rlcl0pIHtcbiAgICAgICAgbW92ZSA9IHRydWU7XG4gICAgICAgIHRtcCA9IGZpbmRCZWdpbm5pbmdBbmRFbmQoY20sIGhlYWQsIGNoYXJhY3RlciwgaW5jbHVzaXZlKTtcbiAgICAgIH0gZWxzZSBpZiAoY2hhcmFjdGVyID09PSAnVycgfHwgY2hhcmFjdGVyID09PSAndycpIHtcbiAgICAgICAgdmFyIHJlcGVhdCA9IG1vdGlvbkFyZ3MucmVwZWF0IHx8IDE7XG4gICAgICAgIHdoaWxlIChyZXBlYXQtLSA+IDApIHtcbiAgICAgICAgICB2YXIgcmVwZWF0ZWQgPSBleHBhbmRXb3JkVW5kZXJDdXJzb3IoY20sIHtcbiAgICAgICAgICAgIGluY2x1c2l2ZSxcbiAgICAgICAgICAgIGlubmVyV29yZDogIWluY2x1c2l2ZSxcbiAgICAgICAgICAgIGJpZ1dvcmQ6IGNoYXJhY3RlciA9PT0gJ1cnLFxuICAgICAgICAgICAgbm9TeW1ib2w6IGNoYXJhY3RlciA9PT0gJ1cnLFxuICAgICAgICAgICAgbXVsdGlsaW5lOiB0cnVlXG4gICAgICAgICAgfSwgdG1wICYmIHRtcC5lbmQpO1xuICAgICAgICAgIGlmIChyZXBlYXRlZCkge1xuICAgICAgICAgICAgaWYgKCF0bXApIHRtcCA9IHJlcGVhdGVkO1xuICAgICAgICAgICAgdG1wLmVuZCA9IHJlcGVhdGVkLmVuZDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoY2hhcmFjdGVyID09PSAncCcpIHtcbiAgICAgICAgdG1wID0gZmluZFBhcmFncmFwaChjbSwgaGVhZCwgbW90aW9uQXJncy5yZXBlYXQsIDAsIGluY2x1c2l2ZSk7XG4gICAgICAgIG1vdGlvbkFyZ3MubGluZXdpc2UgPSB0cnVlO1xuICAgICAgICBpZiAodmltLnZpc3VhbE1vZGUpIHtcbiAgICAgICAgICBpZiAoIXZpbS52aXN1YWxMaW5lKSB7IHZpbS52aXN1YWxMaW5lID0gdHJ1ZTsgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBvcGVyYXRvckFyZ3MgPSB2aW0uaW5wdXRTdGF0ZS5vcGVyYXRvckFyZ3M7XG4gICAgICAgICAgaWYgKG9wZXJhdG9yQXJncykgeyBvcGVyYXRvckFyZ3MubGluZXdpc2UgPSB0cnVlOyB9XG4gICAgICAgICAgdG1wLmVuZC5saW5lLS07XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoY2hhcmFjdGVyID09PSAndCcpIHtcbiAgICAgICAgdG1wID0gZXhwYW5kVGFnVW5kZXJDdXJzb3IoY20sIGhlYWQsIGluY2x1c2l2ZSk7XG4gICAgICB9IGVsc2UgaWYgKGNoYXJhY3RlciA9PT0gJ3MnKSB7XG4gICAgICAgIC8vIGFjY291bnQgZm9yIGN1cnNvciBvbiBlbmQgb2Ygc2VudGVuY2Ugc3ltYm9sXG4gICAgICAgIHZhciBjb250ZW50ID0gY20uZ2V0TGluZShoZWFkLmxpbmUpO1xuICAgICAgICBpZiAoaGVhZC5jaCA+IDAgJiYgaXNFbmRPZlNlbnRlbmNlU3ltYm9sKGNvbnRlbnRbaGVhZC5jaF0pKSB7XG4gICAgICAgICAgaGVhZC5jaCAtPSAxO1xuICAgICAgICB9XG4gICAgICAgIHZhciBlbmQgPSBnZXRTZW50ZW5jZShjbSwgaGVhZCwgbW90aW9uQXJncy5yZXBlYXQsIDEsIGluY2x1c2l2ZSk7XG4gICAgICAgIHZhciBzdGFydCA9IGdldFNlbnRlbmNlKGNtLCBoZWFkLCBtb3Rpb25BcmdzLnJlcGVhdCwgLTEsIGluY2x1c2l2ZSk7XG4gICAgICAgIC8vIGNsb3NlciB2aW0gYmVoYXZpb3VyLCAnYScgb25seSB0YWtlcyB0aGUgc3BhY2UgYWZ0ZXIgdGhlIHNlbnRlbmNlIGlmIHRoZXJlIGlzIG9uZSBiZWZvcmUgYW5kIGFmdGVyXG4gICAgICAgIGlmIChpc1doaXRlU3BhY2VTdHJpbmcoY20uZ2V0TGluZShzdGFydC5saW5lKVtzdGFydC5jaF0pXG4gICAgICAgICAgICAmJiBpc1doaXRlU3BhY2VTdHJpbmcoY20uZ2V0TGluZShlbmQubGluZSlbZW5kLmNoIC0xXSkpIHtcbiAgICAgICAgICBzdGFydCA9IHtsaW5lOiBzdGFydC5saW5lLCBjaDogc3RhcnQuY2ggKyAxfTtcbiAgICAgICAgfVxuICAgICAgICB0bXAgPSB7c3RhcnQ6IHN0YXJ0LCBlbmQ6IGVuZH07XG4gICAgICB9XG5cbiAgICAgIGlmICghdG1wKSB7XG4gICAgICAgIC8vIE5vIHZhbGlkIHRleHQgb2JqZWN0LCBkb24ndCBtb3ZlLlxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgaWYgKCFjbS5zdGF0ZS52aW0udmlzdWFsTW9kZSkge1xuICAgICAgICByZXR1cm4gW3RtcC5zdGFydCwgdG1wLmVuZF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZXhwYW5kU2VsZWN0aW9uKGNtLCB0bXAuc3RhcnQsIHRtcC5lbmQsIG1vdmUpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICByZXBlYXRMYXN0Q2hhcmFjdGVyU2VhcmNoOiBmdW5jdGlvbihjbSwgaGVhZCwgbW90aW9uQXJncykge1xuICAgICAgdmFyIGxhc3RTZWFyY2ggPSB2aW1HbG9iYWxTdGF0ZS5sYXN0Q2hhcmFjdGVyU2VhcmNoO1xuICAgICAgdmFyIHJlcGVhdCA9IG1vdGlvbkFyZ3MucmVwZWF0O1xuICAgICAgdmFyIGZvcndhcmQgPSBtb3Rpb25BcmdzLmZvcndhcmQgPT09IGxhc3RTZWFyY2guZm9yd2FyZDtcbiAgICAgIHZhciBpbmNyZW1lbnQgPSAobGFzdFNlYXJjaC5pbmNyZW1lbnQgPyAxIDogMCkgKiAoZm9yd2FyZCA/IC0xIDogMSk7XG4gICAgICBjbS5tb3ZlSCgtaW5jcmVtZW50LCAnY2hhcicpO1xuICAgICAgbW90aW9uQXJncy5pbmNsdXNpdmUgPSBmb3J3YXJkID8gdHJ1ZSA6IGZhbHNlO1xuICAgICAgdmFyIGN1ckVuZCA9IG1vdmVUb0NoYXJhY3RlcihjbSwgcmVwZWF0LCBmb3J3YXJkLCBsYXN0U2VhcmNoLnNlbGVjdGVkQ2hhcmFjdGVyKTtcbiAgICAgIGlmICghY3VyRW5kKSB7XG4gICAgICAgIGNtLm1vdmVIKGluY3JlbWVudCwgJ2NoYXInKTtcbiAgICAgICAgcmV0dXJuIGhlYWQ7XG4gICAgICB9XG4gICAgICBjdXJFbmQuY2ggKz0gaW5jcmVtZW50O1xuICAgICAgcmV0dXJuIGN1ckVuZDtcbiAgICB9XG4gIH07XG5cbiAgLyoqIEBhcmcge3N0cmluZ30gbmFtZSAgQGFyZyB7aW1wb3J0KFwiLi90eXBlc1wiKS5Nb3Rpb25Gbn0gZm4gKi9cbiAgZnVuY3Rpb24gZGVmaW5lTW90aW9uKG5hbWUsIGZuKSB7XG4gICAgbW90aW9uc1tuYW1lXSA9IGZuO1xuICB9XG5cbiAgLyoqIEBhcmcge3N0cmluZ30gdmFsIEBhcmcge251bWJlcn0gdGltZXMgKi9cbiAgZnVuY3Rpb24gZmlsbEFycmF5KHZhbCwgdGltZXMpIHtcbiAgICB2YXIgYXJyID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aW1lczsgaSsrKSB7XG4gICAgICBhcnIucHVzaCh2YWwpO1xuICAgIH1cbiAgICByZXR1cm4gYXJyO1xuICB9XG4gIC8qKlxuICAgKiBBbiBvcGVyYXRvciBhY3RzIG9uIGEgdGV4dCBzZWxlY3Rpb24uIEl0IHJlY2VpdmVzIHRoZSBsaXN0IG9mIHNlbGVjdGlvbnNcbiAgICogYXMgaW5wdXQuIFRoZSBjb3JyZXNwb25kaW5nIENvZGVNaXJyb3Igc2VsZWN0aW9uIGlzIGd1YXJhbnRlZWQgdG9cbiAgICogbWF0Y2ggdGhlIGlucHV0IHNlbGVjdGlvbi5cbiAgICovXG4gIC8qKiBAdHlwZSB7aW1wb3J0KFwiLi90eXBlc1wiKS52aW1PcGVyYXRvcnN9ICovXG4gIHZhciBvcGVyYXRvcnMgPSB7XG4gICAgY2hhbmdlOiBmdW5jdGlvbihjbSwgYXJncywgcmFuZ2VzKSB7XG4gICAgICB2YXIgZmluYWxIZWFkLCB0ZXh0O1xuICAgICAgdmFyIHZpbSA9IGNtLnN0YXRlLnZpbTtcbiAgICAgIHZhciBhbmNob3IgPSByYW5nZXNbMF0uYW5jaG9yLFxuICAgICAgICAgIGhlYWQgPSByYW5nZXNbMF0uaGVhZDtcbiAgICAgIGlmICghdmltLnZpc3VhbE1vZGUpIHtcbiAgICAgICAgdGV4dCA9IGNtLmdldFJhbmdlKGFuY2hvciwgaGVhZCk7XG4gICAgICAgIHZhciBsYXN0U3RhdGUgPSB2aW0ubGFzdEVkaXRJbnB1dFN0YXRlO1xuICAgICAgICBpZiAobGFzdFN0YXRlPy5tb3Rpb24gPT0gXCJtb3ZlQnlXb3Jkc1wiICYmICFpc1doaXRlU3BhY2VTdHJpbmcodGV4dCkpIHtcbiAgICAgICAgICAvLyBFeGNsdWRlIHRyYWlsaW5nIHdoaXRlc3BhY2UgaWYgdGhlIHJhbmdlIGlzIG5vdCBhbGwgd2hpdGVzcGFjZS5cbiAgICAgICAgICB2YXIgbWF0Y2ggPSAoL1xccyskLykuZXhlYyh0ZXh0KTtcbiAgICAgICAgICBpZiAobWF0Y2ggJiYgbGFzdFN0YXRlLm1vdGlvbkFyZ3MgJiYgbGFzdFN0YXRlLm1vdGlvbkFyZ3MuZm9yd2FyZCkge1xuICAgICAgICAgICAgaGVhZCA9IG9mZnNldEN1cnNvcihoZWFkLCAwLCAtIG1hdGNoWzBdLmxlbmd0aCk7XG4gICAgICAgICAgICB0ZXh0ID0gdGV4dC5zbGljZSgwLCAtIG1hdGNoWzBdLmxlbmd0aCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChhcmdzLmxpbmV3aXNlKSB7XG4gICAgICAgICAgYW5jaG9yID0gbmV3IFBvcyhhbmNob3IubGluZSwgZmluZEZpcnN0Tm9uV2hpdGVTcGFjZUNoYXJhY3RlcihjbS5nZXRMaW5lKGFuY2hvci5saW5lKSkpO1xuICAgICAgICAgIGlmIChoZWFkLmxpbmUgPiBhbmNob3IubGluZSkge1xuICAgICAgICAgICAgaGVhZCA9IG5ldyBQb3MoaGVhZC5saW5lIC0gMSwgTnVtYmVyLk1BWF9WQUxVRSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNtLnJlcGxhY2VSYW5nZSgnJywgYW5jaG9yLCBoZWFkKTtcbiAgICAgICAgZmluYWxIZWFkID0gYW5jaG9yO1xuICAgICAgfSBlbHNlIGlmIChhcmdzLmZ1bGxMaW5lKSB7XG4gICAgICAgICAgaGVhZC5jaCA9IE51bWJlci5NQVhfVkFMVUU7XG4gICAgICAgICAgaGVhZC5saW5lLS07XG4gICAgICAgICAgY20uc2V0U2VsZWN0aW9uKGFuY2hvciwgaGVhZCk7XG4gICAgICAgICAgdGV4dCA9IGNtLmdldFNlbGVjdGlvbigpO1xuICAgICAgICAgIGNtLnJlcGxhY2VTZWxlY3Rpb24oXCJcIik7XG4gICAgICAgICAgZmluYWxIZWFkID0gYW5jaG9yO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGV4dCA9IGNtLmdldFNlbGVjdGlvbigpO1xuICAgICAgICB2YXIgcmVwbGFjZW1lbnQgPSBmaWxsQXJyYXkoJycsIHJhbmdlcy5sZW5ndGgpO1xuICAgICAgICBjbS5yZXBsYWNlU2VsZWN0aW9ucyhyZXBsYWNlbWVudCk7XG4gICAgICAgIGZpbmFsSGVhZCA9IGN1cnNvck1pbihyYW5nZXNbMF0uaGVhZCwgcmFuZ2VzWzBdLmFuY2hvcik7XG4gICAgICB9XG4gICAgICB2aW1HbG9iYWxTdGF0ZS5yZWdpc3RlckNvbnRyb2xsZXIucHVzaFRleHQoXG4gICAgICAgICAgYXJncy5yZWdpc3Rlck5hbWUsICdjaGFuZ2UnLCB0ZXh0LFxuICAgICAgICAgIGFyZ3MubGluZXdpc2UsIHJhbmdlcy5sZW5ndGggPiAxKTtcbiAgICAgIGFjdGlvbnMuZW50ZXJJbnNlcnRNb2RlKGNtLCB7aGVhZDogZmluYWxIZWFkfSwgY20uc3RhdGUudmltKTtcbiAgICB9LFxuICAgIGRlbGV0ZTogZnVuY3Rpb24oY20sIGFyZ3MsIHJhbmdlcykge1xuICAgICAgdmFyIGZpbmFsSGVhZCwgdGV4dDtcbiAgICAgIHZhciB2aW0gPSBjbS5zdGF0ZS52aW07XG4gICAgICBpZiAoIXZpbS52aXN1YWxCbG9jaykge1xuICAgICAgICB2YXIgYW5jaG9yID0gcmFuZ2VzWzBdLmFuY2hvcixcbiAgICAgICAgICAgIGhlYWQgPSByYW5nZXNbMF0uaGVhZDtcbiAgICAgICAgaWYgKGFyZ3MubGluZXdpc2UgJiZcbiAgICAgICAgICAgIGhlYWQubGluZSAhPSBjbS5maXJzdExpbmUoKSAmJlxuICAgICAgICAgICAgYW5jaG9yLmxpbmUgPT0gY20ubGFzdExpbmUoKSAmJlxuICAgICAgICAgICAgYW5jaG9yLmxpbmUgPT0gaGVhZC5saW5lIC0gMSkge1xuICAgICAgICAgIC8vIFNwZWNpYWwgY2FzZSBmb3IgZGQgb24gbGFzdCBsaW5lIChhbmQgZmlyc3QgbGluZSkuXG4gICAgICAgICAgaWYgKGFuY2hvci5saW5lID09IGNtLmZpcnN0TGluZSgpKSB7XG4gICAgICAgICAgICBhbmNob3IuY2ggPSAwO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhbmNob3IgPSBuZXcgUG9zKGFuY2hvci5saW5lIC0gMSwgbGluZUxlbmd0aChjbSwgYW5jaG9yLmxpbmUgLSAxKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRleHQgPSBjbS5nZXRSYW5nZShhbmNob3IsIGhlYWQpO1xuICAgICAgICBjbS5yZXBsYWNlUmFuZ2UoJycsIGFuY2hvciwgaGVhZCk7XG4gICAgICAgIGZpbmFsSGVhZCA9IGFuY2hvcjtcbiAgICAgICAgaWYgKGFyZ3MubGluZXdpc2UpIHtcbiAgICAgICAgICBmaW5hbEhlYWQgPSBtb3Rpb25zLm1vdmVUb0ZpcnN0Tm9uV2hpdGVTcGFjZUNoYXJhY3RlcihjbSwgYW5jaG9yKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGV4dCA9IGNtLmdldFNlbGVjdGlvbigpO1xuICAgICAgICB2YXIgcmVwbGFjZW1lbnQgPSBmaWxsQXJyYXkoJycsIHJhbmdlcy5sZW5ndGgpO1xuICAgICAgICBjbS5yZXBsYWNlU2VsZWN0aW9ucyhyZXBsYWNlbWVudCk7XG4gICAgICAgIGZpbmFsSGVhZCA9IGN1cnNvck1pbihyYW5nZXNbMF0uaGVhZCwgcmFuZ2VzWzBdLmFuY2hvcik7XG4gICAgICB9XG4gICAgICB2aW1HbG9iYWxTdGF0ZS5yZWdpc3RlckNvbnRyb2xsZXIucHVzaFRleHQoXG4gICAgICAgICAgYXJncy5yZWdpc3Rlck5hbWUsICdkZWxldGUnLCB0ZXh0LFxuICAgICAgICAgIGFyZ3MubGluZXdpc2UsIHZpbS52aXN1YWxCbG9jayk7XG4gICAgICByZXR1cm4gY2xpcEN1cnNvclRvQ29udGVudChjbSwgZmluYWxIZWFkKTtcbiAgICB9LFxuICAgIGluZGVudDogZnVuY3Rpb24oY20sIGFyZ3MsIHJhbmdlcykge1xuICAgICAgdmFyIHZpbSA9IGNtLnN0YXRlLnZpbTtcbiAgICAgIC8vIEluIHZpc3VhbCBtb2RlLCBuPiBzaGlmdHMgdGhlIHNlbGVjdGlvbiByaWdodCBuIHRpbWVzLCBpbnN0ZWFkIG9mXG4gICAgICAvLyBzaGlmdGluZyBuIGxpbmVzIHJpZ2h0IG9uY2UuXG4gICAgICB2YXIgcmVwZWF0ID0gdmltLnZpc3VhbE1vZGUgPyBhcmdzLnJlcGVhdCB8fCAxIDogMTtcbiAgICAgIGlmICh2aW0udmlzdWFsQmxvY2spIHtcbiAgICAgICAgdmFyIHRhYlNpemUgPSBjbS5nZXRPcHRpb24oJ3RhYlNpemUnKTtcbiAgICAgICAgdmFyIGluZGVudCA9IGNtLmdldE9wdGlvbignaW5kZW50V2l0aFRhYnMnKSA/ICdcXHQnIDogJyAnLnJlcGVhdCh0YWJTaXplKTtcbiAgICAgICAgdmFyIGN1cnNvcjtcbiAgICAgICAgZm9yICh2YXIgaSA9IHJhbmdlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIGN1cnNvciA9IGN1cnNvck1pbihyYW5nZXNbaV0uYW5jaG9yLCByYW5nZXNbaV0uaGVhZCk7XG4gICAgICAgICAgaWYgKGFyZ3MuaW5kZW50UmlnaHQpIHtcbiAgICAgICAgICAgIGNtLnJlcGxhY2VSYW5nZShpbmRlbnQucmVwZWF0KHJlcGVhdCksIGN1cnNvciwgY3Vyc29yKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHRleHQgPSBjbS5nZXRMaW5lKGN1cnNvci5saW5lKTtcbiAgICAgICAgICAgIHZhciBlbmQgPSAwO1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCByZXBlYXQ7IGorKykge1xuICAgICAgICAgICAgICB2YXIgY2ggPSB0ZXh0W2N1cnNvci5jaCArIGVuZF07XG4gICAgICAgICAgICAgIGlmIChjaCA9PSAnXFx0Jykge1xuICAgICAgICAgICAgICAgIGVuZCsrO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNoID09ICcgJykge1xuICAgICAgICAgICAgICAgIGVuZCsrO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGsgPSAxOyBrIDwgaW5kZW50Lmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgICAgICAgICBjaCA9IHRleHRbY3Vyc29yLmNoICsgZW5kXTtcbiAgICAgICAgICAgICAgICAgIGlmIChjaCAhPT0gJyAnKSBicmVhaztcbiAgICAgICAgICAgICAgICAgIGVuZCsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjbS5yZXBsYWNlUmFuZ2UoJycsIGN1cnNvciwgb2Zmc2V0Q3Vyc29yKGN1cnNvciwgMCwgZW5kKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjdXJzb3I7XG4gICAgICB9IGVsc2UgaWYgKGNtLmluZGVudE1vcmUpIHtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCByZXBlYXQ7IGorKykge1xuICAgICAgICAgIGlmIChhcmdzLmluZGVudFJpZ2h0KSBjbS5pbmRlbnRNb3JlKCk7XG4gICAgICAgICAgZWxzZSBjbS5pbmRlbnRMZXNzKCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBzdGFydExpbmUgPSByYW5nZXNbMF0uYW5jaG9yLmxpbmU7XG4gICAgICAgIHZhciBlbmRMaW5lID0gdmltLnZpc3VhbEJsb2NrID9cbiAgICAgICAgICByYW5nZXNbcmFuZ2VzLmxlbmd0aCAtIDFdLmFuY2hvci5saW5lIDpcbiAgICAgICAgICByYW5nZXNbMF0uaGVhZC5saW5lO1xuICAgICAgICBpZiAoYXJncy5saW5ld2lzZSkge1xuICAgICAgICAgIC8vIFRoZSBvbmx5IHdheSB0byBkZWxldGUgYSBuZXdsaW5lIGlzIHRvIGRlbGV0ZSB1bnRpbCB0aGUgc3RhcnQgb2ZcbiAgICAgICAgICAvLyB0aGUgbmV4dCBsaW5lLCBzbyBpbiBsaW5ld2lzZSBtb2RlIGV2YWxJbnB1dCB3aWxsIGluY2x1ZGUgdGhlIG5leHRcbiAgICAgICAgICAvLyBsaW5lLiBXZSBkb24ndCB3YW50IHRoaXMgaW4gaW5kZW50LCBzbyB3ZSBnbyBiYWNrIGEgbGluZS5cbiAgICAgICAgICBlbmRMaW5lLS07XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSA9IHN0YXJ0TGluZTsgaSA8PSBlbmRMaW5lOyBpKyspIHtcbiAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHJlcGVhdDsgaisrKSB7XG4gICAgICAgICAgICBjbS5pbmRlbnRMaW5lKGksIGFyZ3MuaW5kZW50UmlnaHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG1vdGlvbnMubW92ZVRvRmlyc3ROb25XaGl0ZVNwYWNlQ2hhcmFjdGVyKGNtLCByYW5nZXNbMF0uYW5jaG9yKTtcbiAgICB9LFxuICAgIGluZGVudEF1dG86IGZ1bmN0aW9uKGNtLCBfYXJncywgcmFuZ2VzKSB7XG4gICAgICBjbS5leGVjQ29tbWFuZChcImluZGVudEF1dG9cIik7XG4gICAgICByZXR1cm4gbW90aW9ucy5tb3ZlVG9GaXJzdE5vbldoaXRlU3BhY2VDaGFyYWN0ZXIoY20sIHJhbmdlc1swXS5hbmNob3IpO1xuICAgIH0sXG4gICAgaGFyZFdyYXA6IGZ1bmN0aW9uKGNtLCBvcGVyYXRvckFyZ3MsIHJhbmdlcywgb2xkQW5jaG9yKSB7XG4gICAgICBpZiAoIWNtLmhhcmRXcmFwKSByZXR1cm47XG4gICAgICB2YXIgZnJvbSA9IHJhbmdlc1swXS5hbmNob3IubGluZTtcbiAgICAgIHZhciB0byA9IHJhbmdlc1swXS5oZWFkLmxpbmU7XG4gICAgICBpZiAob3BlcmF0b3JBcmdzLmxpbmV3aXNlKSB0by0tO1xuICAgICAgdmFyIGVuZFJvdyA9IGNtLmhhcmRXcmFwKHtmcm9tOiBmcm9tLCB0bzogdG99KTtcbiAgICAgIGlmIChlbmRSb3cgPiBmcm9tICYmIG9wZXJhdG9yQXJncy5saW5ld2lzZSkgZW5kUm93LS07XG4gICAgICByZXR1cm4gb3BlcmF0b3JBcmdzLmtlZXBDdXJzb3IgPyBvbGRBbmNob3IgOiBuZXcgUG9zKGVuZFJvdywgMCk7XG4gICAgfSxcbiAgICBjaGFuZ2VDYXNlOiBmdW5jdGlvbihjbSwgYXJncywgcmFuZ2VzLCBvbGRBbmNob3IsIG5ld0hlYWQpIHtcbiAgICAgIHZhciBzZWxlY3Rpb25zID0gY20uZ2V0U2VsZWN0aW9ucygpO1xuICAgICAgdmFyIHN3YXBwZWQgPSBbXTtcbiAgICAgIHZhciB0b0xvd2VyID0gYXJncy50b0xvd2VyO1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBzZWxlY3Rpb25zLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIHZhciB0b1N3YXAgPSBzZWxlY3Rpb25zW2pdO1xuICAgICAgICB2YXIgdGV4dCA9ICcnO1xuICAgICAgICBpZiAodG9Mb3dlciA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHRleHQgPSB0b1N3YXAudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgfSBlbHNlIGlmICh0b0xvd2VyID09PSBmYWxzZSkge1xuICAgICAgICAgIHRleHQgPSB0b1N3YXAudG9VcHBlckNhc2UoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRvU3dhcC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGNoYXJhY3RlciA9IHRvU3dhcC5jaGFyQXQoaSk7XG4gICAgICAgICAgICB0ZXh0ICs9IGlzVXBwZXJDYXNlKGNoYXJhY3RlcikgPyBjaGFyYWN0ZXIudG9Mb3dlckNhc2UoKSA6XG4gICAgICAgICAgICAgICAgY2hhcmFjdGVyLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN3YXBwZWQucHVzaCh0ZXh0KTtcbiAgICAgIH1cbiAgICAgIGNtLnJlcGxhY2VTZWxlY3Rpb25zKHN3YXBwZWQpO1xuICAgICAgaWYgKGFyZ3Muc2hvdWxkTW92ZUN1cnNvcil7XG4gICAgICAgIHJldHVybiBuZXdIZWFkO1xuICAgICAgfSBlbHNlIGlmICghY20uc3RhdGUudmltLnZpc3VhbE1vZGUgJiYgYXJncy5saW5ld2lzZSAmJiByYW5nZXNbMF0uYW5jaG9yLmxpbmUgKyAxID09IHJhbmdlc1swXS5oZWFkLmxpbmUpIHtcbiAgICAgICAgcmV0dXJuIG1vdGlvbnMubW92ZVRvRmlyc3ROb25XaGl0ZVNwYWNlQ2hhcmFjdGVyKGNtLCBvbGRBbmNob3IpO1xuICAgICAgfSBlbHNlIGlmIChhcmdzLmxpbmV3aXNlKXtcbiAgICAgICAgcmV0dXJuIG9sZEFuY2hvcjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBjdXJzb3JNaW4ocmFuZ2VzWzBdLmFuY2hvciwgcmFuZ2VzWzBdLmhlYWQpO1xuICAgICAgfVxuICAgIH0sXG4gICAgeWFuazogZnVuY3Rpb24oY20sIGFyZ3MsIHJhbmdlcywgb2xkQW5jaG9yKSB7XG4gICAgICB2YXIgdmltID0gY20uc3RhdGUudmltO1xuICAgICAgdmFyIHRleHQgPSBjbS5nZXRTZWxlY3Rpb24oKTtcbiAgICAgIHZhciBlbmRQb3MgPSB2aW0udmlzdWFsTW9kZVxuICAgICAgICA/IGN1cnNvck1pbih2aW0uc2VsLmFuY2hvciwgdmltLnNlbC5oZWFkLCByYW5nZXNbMF0uaGVhZCwgcmFuZ2VzWzBdLmFuY2hvcilcbiAgICAgICAgOiBvbGRBbmNob3I7XG4gICAgICB2aW1HbG9iYWxTdGF0ZS5yZWdpc3RlckNvbnRyb2xsZXIucHVzaFRleHQoXG4gICAgICAgICAgYXJncy5yZWdpc3Rlck5hbWUsICd5YW5rJyxcbiAgICAgICAgICB0ZXh0LCBhcmdzLmxpbmV3aXNlLCB2aW0udmlzdWFsQmxvY2spO1xuICAgICAgcmV0dXJuIGVuZFBvcztcbiAgICB9LFxuICAgIHJvdDEzOiBmdW5jdGlvbihjbSwgYXJncywgcmFuZ2VzLCBvbGRBbmNob3IsIG5ld0hlYWQpIHtcbiAgICAgIHZhciBzZWxlY3Rpb25zID0gY20uZ2V0U2VsZWN0aW9ucygpO1xuICAgICAgdmFyIHN3YXBwZWQgPSBbXTtcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgc2VsZWN0aW9ucy5sZW5ndGg7IGorKykge1xuICAgICAgICBjb25zdCByZXBsYWNlbWVudCA9IHNlbGVjdGlvbnNbal1cbiAgICAgICAgICAuc3BsaXQoJycpXG4gICAgICAgICAgLm1hcCh4ID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGNvZGUgPSB4LmNoYXJDb2RlQXQoMCk7XG4gICAgICAgICAgICBpZiAoY29kZSA+PSA2NSAmJiBjb2RlIDw9IDkwKSB7IC8vIFVwcGVyY2FzZVxuICAgICAgICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZSg2NSArICgoY29kZSAtIDY1ICsgMTMpICUgMjYpKVxuICAgICAgICAgICAgfSBlbHNlIGlmIChjb2RlID49IDk3ICYmIGNvZGUgPD0gMTIyKSB7IC8vIExvd2VyY2FzZVxuICAgICAgICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZSg5NyArICgoY29kZSAtIDk3ICsgMTMpICUgMjYpKVxuICAgICAgICAgICAgfSBlbHNlIHsgLy8gTm90IGEgbGV0dGVyXG4gICAgICAgICAgICAgIHJldHVybiB4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG4gICAgICAgICAgLmpvaW4oJycpO1xuICAgICAgICBzd2FwcGVkLnB1c2gocmVwbGFjZW1lbnQpO1xuICAgICAgfVxuICAgICAgY20ucmVwbGFjZVNlbGVjdGlvbnMoc3dhcHBlZCk7XG4gICAgICBpZiAoYXJncy5zaG91bGRNb3ZlQ3Vyc29yKXtcbiAgICAgICAgcmV0dXJuIG5ld0hlYWQ7XG4gICAgICB9IGVsc2UgaWYgKCFjbS5zdGF0ZS52aW0udmlzdWFsTW9kZSAmJiBhcmdzLmxpbmV3aXNlICYmIHJhbmdlc1swXS5hbmNob3IubGluZSArIDEgPT0gcmFuZ2VzWzBdLmhlYWQubGluZSkge1xuICAgICAgICByZXR1cm4gbW90aW9ucy5tb3ZlVG9GaXJzdE5vbldoaXRlU3BhY2VDaGFyYWN0ZXIoY20sIG9sZEFuY2hvcik7XG4gICAgICB9IGVsc2UgaWYgKGFyZ3MubGluZXdpc2Upe1xuICAgICAgICByZXR1cm4gb2xkQW5jaG9yO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGN1cnNvck1pbihyYW5nZXNbMF0uYW5jaG9yLCByYW5nZXNbMF0uaGVhZCk7XG4gICAgICB9XG4gICAgfSxcbiAgfTtcblxuICAvKiogQGFyZyB7c3RyaW5nfSBuYW1lICBAYXJnIHtpbXBvcnQoXCIuL3R5cGVzXCIpLk9wZXJhdG9yRm59IGZuICovXG4gIGZ1bmN0aW9uIGRlZmluZU9wZXJhdG9yKG5hbWUsIGZuKSB7XG4gICAgb3BlcmF0b3JzW25hbWVdID0gZm47XG4gIH1cblxuICAvKiogQHR5cGUge2ltcG9ydChcIi4vdHlwZXNcIikudmltQWN0aW9uc30gKi9cbiAgdmFyIGFjdGlvbnMgPSB7XG4gICAganVtcExpc3RXYWxrOiBmdW5jdGlvbihjbSwgYWN0aW9uQXJncywgdmltKSB7XG4gICAgICBpZiAodmltLnZpc3VhbE1vZGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIHJlcGVhdCA9IGFjdGlvbkFyZ3MucmVwZWF0IHx8IDE7XG4gICAgICB2YXIgZm9yd2FyZCA9IGFjdGlvbkFyZ3MuZm9yd2FyZDtcbiAgICAgIHZhciBqdW1wTGlzdCA9IHZpbUdsb2JhbFN0YXRlLmp1bXBMaXN0O1xuXG4gICAgICB2YXIgbWFyayA9IGp1bXBMaXN0Lm1vdmUoY20sIGZvcndhcmQgPyByZXBlYXQgOiAtcmVwZWF0KTtcbiAgICAgIHZhciBtYXJrUG9zID0gbWFyayA/IG1hcmsuZmluZCgpIDogdW5kZWZpbmVkO1xuICAgICAgbWFya1BvcyA9IG1hcmtQb3MgPyBtYXJrUG9zIDogY20uZ2V0Q3Vyc29yKCk7XG4gICAgICBjbS5zZXRDdXJzb3IobWFya1Bvcyk7XG4gICAgfSxcbiAgICBzY3JvbGw6IGZ1bmN0aW9uKGNtLCBhY3Rpb25BcmdzLCB2aW0pIHtcbiAgICAgIGlmICh2aW0udmlzdWFsTW9kZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgcmVwZWF0ID0gYWN0aW9uQXJncy5yZXBlYXQgfHwgMTtcbiAgICAgIHZhciBsaW5lSGVpZ2h0ID0gY20uZGVmYXVsdFRleHRIZWlnaHQoKTtcbiAgICAgIHZhciB0b3AgPSBjbS5nZXRTY3JvbGxJbmZvKCkudG9wO1xuICAgICAgdmFyIGRlbHRhID0gbGluZUhlaWdodCAqIHJlcGVhdDtcbiAgICAgIHZhciBuZXdQb3MgPSBhY3Rpb25BcmdzLmZvcndhcmQgPyB0b3AgKyBkZWx0YSA6IHRvcCAtIGRlbHRhO1xuICAgICAgdmFyIGN1cnNvciA9IGNvcHlDdXJzb3IoY20uZ2V0Q3Vyc29yKCkpO1xuICAgICAgdmFyIGN1cnNvckNvb3JkcyA9IGNtLmNoYXJDb29yZHMoY3Vyc29yLCAnbG9jYWwnKTtcbiAgICAgIGlmIChhY3Rpb25BcmdzLmZvcndhcmQpIHtcbiAgICAgICAgaWYgKG5ld1BvcyA+IGN1cnNvckNvb3Jkcy50b3ApIHtcbiAgICAgICAgICAgIGN1cnNvci5saW5lICs9IChuZXdQb3MgLSBjdXJzb3JDb29yZHMudG9wKSAvIGxpbmVIZWlnaHQ7XG4gICAgICAgICAgICBjdXJzb3IubGluZSA9IE1hdGguY2VpbChjdXJzb3IubGluZSk7XG4gICAgICAgICAgICBjbS5zZXRDdXJzb3IoY3Vyc29yKTtcbiAgICAgICAgICAgIGN1cnNvckNvb3JkcyA9IGNtLmNoYXJDb29yZHMoY3Vyc29yLCAnbG9jYWwnKTtcbiAgICAgICAgICAgIGNtLnNjcm9sbFRvKG51bGwsIGN1cnNvckNvb3Jkcy50b3ApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gQ3Vyc29yIHN0YXlzIHdpdGhpbiBib3VuZHMuICBKdXN0IHJlcG9zaXRpb24gdGhlIHNjcm9sbCB3aW5kb3cuXG4gICAgICAgICAgICBjbS5zY3JvbGxUbyhudWxsLCBuZXdQb3MpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgbmV3Qm90dG9tID0gbmV3UG9zICsgY20uZ2V0U2Nyb2xsSW5mbygpLmNsaWVudEhlaWdodDtcbiAgICAgICAgaWYgKG5ld0JvdHRvbSA8IGN1cnNvckNvb3Jkcy5ib3R0b20pIHtcbiAgICAgICAgICAgIGN1cnNvci5saW5lIC09IChjdXJzb3JDb29yZHMuYm90dG9tIC0gbmV3Qm90dG9tKSAvIGxpbmVIZWlnaHQ7XG4gICAgICAgICAgICBjdXJzb3IubGluZSA9IE1hdGguZmxvb3IoY3Vyc29yLmxpbmUpO1xuICAgICAgICAgICAgY20uc2V0Q3Vyc29yKGN1cnNvcik7XG4gICAgICAgICAgICBjdXJzb3JDb29yZHMgPSBjbS5jaGFyQ29vcmRzKGN1cnNvciwgJ2xvY2FsJyk7XG4gICAgICAgICAgICBjbS5zY3JvbGxUbyhcbiAgICAgICAgICAgICAgICBudWxsLCBjdXJzb3JDb29yZHMuYm90dG9tIC0gY20uZ2V0U2Nyb2xsSW5mbygpLmNsaWVudEhlaWdodCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBDdXJzb3Igc3RheXMgd2l0aGluIGJvdW5kcy4gIEp1c3QgcmVwb3NpdGlvbiB0aGUgc2Nyb2xsIHdpbmRvdy5cbiAgICAgICAgICAgIGNtLnNjcm9sbFRvKG51bGwsIG5ld1Bvcyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIHNjcm9sbFRvQ3Vyc29yOiBmdW5jdGlvbihjbSwgYWN0aW9uQXJncykge1xuICAgICAgdmFyIGxpbmVOdW0gPSBjbS5nZXRDdXJzb3IoKS5saW5lO1xuICAgICAgdmFyIGNoYXJDb29yZHMgPSBjbS5jaGFyQ29vcmRzKG5ldyBQb3MobGluZU51bSwgMCksICdsb2NhbCcpO1xuICAgICAgdmFyIGhlaWdodCA9IGNtLmdldFNjcm9sbEluZm8oKS5jbGllbnRIZWlnaHQ7XG4gICAgICB2YXIgeSA9IGNoYXJDb29yZHMudG9wO1xuICAgICAgc3dpdGNoIChhY3Rpb25BcmdzLnBvc2l0aW9uKSB7XG4gICAgICAgIGNhc2UgJ2NlbnRlcic6IHkgPSBjaGFyQ29vcmRzLmJvdHRvbSAtIGhlaWdodCAvIDI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2JvdHRvbSc6XG4gICAgICAgICAgdmFyIGxpbmVMYXN0Q2hhclBvcyA9IG5ldyBQb3MobGluZU51bSwgY20uZ2V0TGluZShsaW5lTnVtKS5sZW5ndGggLSAxKTtcbiAgICAgICAgICB2YXIgbGluZUxhc3RDaGFyQ29vcmRzID0gY20uY2hhckNvb3JkcyhsaW5lTGFzdENoYXJQb3MsICdsb2NhbCcpO1xuICAgICAgICAgIHZhciBsaW5lSGVpZ2h0ID0gbGluZUxhc3RDaGFyQ29vcmRzLmJvdHRvbSAtIHk7XG4gICAgICAgICAgeSA9IHkgLSBoZWlnaHQgKyBsaW5lSGVpZ2h0O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY20uc2Nyb2xsVG8obnVsbCwgeSk7XG4gICAgfSxcbiAgICByZXBsYXlNYWNybzogZnVuY3Rpb24oY20sIGFjdGlvbkFyZ3MsIHZpbSkge1xuICAgICAgdmFyIHJlZ2lzdGVyTmFtZSA9IGFjdGlvbkFyZ3Muc2VsZWN0ZWRDaGFyYWN0ZXIgfHwgXCJcIjtcbiAgICAgIHZhciByZXBlYXQgPSBhY3Rpb25BcmdzLnJlcGVhdCB8fCAxO1xuICAgICAgdmFyIG1hY3JvTW9kZVN0YXRlID0gdmltR2xvYmFsU3RhdGUubWFjcm9Nb2RlU3RhdGU7XG4gICAgICBpZiAocmVnaXN0ZXJOYW1lID09ICdAJykge1xuICAgICAgICByZWdpc3Rlck5hbWUgPSBtYWNyb01vZGVTdGF0ZS5sYXRlc3RSZWdpc3RlciB8fCBcIlwiO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWFjcm9Nb2RlU3RhdGUubGF0ZXN0UmVnaXN0ZXIgPSByZWdpc3Rlck5hbWU7XG4gICAgICB9XG4gICAgICB3aGlsZShyZXBlYXQtLSl7XG4gICAgICAgIGV4ZWN1dGVNYWNyb1JlZ2lzdGVyKGNtLCB2aW0sIG1hY3JvTW9kZVN0YXRlLCByZWdpc3Rlck5hbWUpO1xuICAgICAgfVxuICAgIH0sXG4gICAgZW50ZXJNYWNyb1JlY29yZE1vZGU6IGZ1bmN0aW9uKGNtLCBhY3Rpb25BcmdzKSB7XG4gICAgICB2YXIgbWFjcm9Nb2RlU3RhdGUgPSB2aW1HbG9iYWxTdGF0ZS5tYWNyb01vZGVTdGF0ZTtcbiAgICAgIHZhciByZWdpc3Rlck5hbWUgPSBhY3Rpb25BcmdzLnNlbGVjdGVkQ2hhcmFjdGVyO1xuICAgICAgaWYgKHZpbUdsb2JhbFN0YXRlLnJlZ2lzdGVyQ29udHJvbGxlci5pc1ZhbGlkUmVnaXN0ZXIocmVnaXN0ZXJOYW1lKSkge1xuICAgICAgICBtYWNyb01vZGVTdGF0ZS5lbnRlck1hY3JvUmVjb3JkTW9kZShjbSwgcmVnaXN0ZXJOYW1lKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHRvZ2dsZU92ZXJ3cml0ZTogZnVuY3Rpb24oY20pIHtcbiAgICAgIGlmICghY20uc3RhdGUub3ZlcndyaXRlKSB7XG4gICAgICAgIGNtLnRvZ2dsZU92ZXJ3cml0ZSh0cnVlKTtcbiAgICAgICAgY20uc2V0T3B0aW9uKCdrZXlNYXAnLCAndmltLXJlcGxhY2UnKTtcbiAgICAgICAgQ00uc2lnbmFsKGNtLCBcInZpbS1tb2RlLWNoYW5nZVwiLCB7bW9kZTogXCJyZXBsYWNlXCJ9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNtLnRvZ2dsZU92ZXJ3cml0ZShmYWxzZSk7XG4gICAgICAgIGNtLnNldE9wdGlvbigna2V5TWFwJywgJ3ZpbS1pbnNlcnQnKTtcbiAgICAgICAgQ00uc2lnbmFsKGNtLCBcInZpbS1tb2RlLWNoYW5nZVwiLCB7bW9kZTogXCJpbnNlcnRcIn0pO1xuICAgICAgfVxuICAgIH0sXG4gICAgZW50ZXJJbnNlcnRNb2RlOiBmdW5jdGlvbihjbSwgYWN0aW9uQXJncywgdmltKSB7XG4gICAgICBpZiAoY20uZ2V0T3B0aW9uKCdyZWFkT25seScpKSB7IHJldHVybjsgfVxuICAgICAgdmltLmluc2VydE1vZGUgPSB0cnVlO1xuICAgICAgdmltLmluc2VydE1vZGVSZXBlYXQgPSBhY3Rpb25BcmdzICYmIGFjdGlvbkFyZ3MucmVwZWF0IHx8IDE7XG4gICAgICB2YXIgaW5zZXJ0QXQgPSAoYWN0aW9uQXJncykgPyBhY3Rpb25BcmdzLmluc2VydEF0IDogbnVsbDtcbiAgICAgIHZhciBzZWwgPSB2aW0uc2VsO1xuICAgICAgdmFyIGhlYWQgPSBhY3Rpb25BcmdzLmhlYWQgfHwgY20uZ2V0Q3Vyc29yKCdoZWFkJyk7XG4gICAgICB2YXIgaGVpZ2h0ID0gY20ubGlzdFNlbGVjdGlvbnMoKS5sZW5ndGg7XG4gICAgICBpZiAoaW5zZXJ0QXQgPT0gJ2VvbCcpIHtcbiAgICAgICAgaGVhZCA9IG5ldyBQb3MoaGVhZC5saW5lLCBsaW5lTGVuZ3RoKGNtLCBoZWFkLmxpbmUpKTtcbiAgICAgIH0gZWxzZSBpZiAoaW5zZXJ0QXQgPT0gJ2JvbCcpIHtcbiAgICAgICAgaGVhZCA9IG5ldyBQb3MoaGVhZC5saW5lLCAwKTtcbiAgICAgIH0gZWxzZSBpZiAoaW5zZXJ0QXQgPT0gJ2NoYXJBZnRlcicpIHtcbiAgICAgICAgdmFyIG5ld1Bvc2l0aW9uID0gdXBkYXRlU2VsZWN0aW9uRm9yU3Vycm9nYXRlQ2hhcmFjdGVycyhjbSwgaGVhZCwgb2Zmc2V0Q3Vyc29yKGhlYWQsIDAsIDEpKTtcbiAgICAgICAgaGVhZCA9IG5ld1Bvc2l0aW9uLmVuZDtcbiAgICAgIH0gZWxzZSBpZiAoaW5zZXJ0QXQgPT0gJ2ZpcnN0Tm9uQmxhbmsnKSB7XG4gICAgICAgIHZhciBuZXdQb3NpdGlvbiA9IHVwZGF0ZVNlbGVjdGlvbkZvclN1cnJvZ2F0ZUNoYXJhY3RlcnMoY20sIGhlYWQsIG1vdGlvbnMubW92ZVRvRmlyc3ROb25XaGl0ZVNwYWNlQ2hhcmFjdGVyKGNtLCBoZWFkKSk7XG4gICAgICAgIGhlYWQgPSBuZXdQb3NpdGlvbi5lbmQ7XG4gICAgICB9IGVsc2UgaWYgKGluc2VydEF0ID09ICdzdGFydE9mU2VsZWN0ZWRBcmVhJykge1xuICAgICAgICBpZiAoIXZpbS52aXN1YWxNb2RlKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAoIXZpbS52aXN1YWxCbG9jaykge1xuICAgICAgICAgIGlmIChzZWwuaGVhZC5saW5lIDwgc2VsLmFuY2hvci5saW5lKSB7XG4gICAgICAgICAgICBoZWFkID0gc2VsLmhlYWQ7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGhlYWQgPSBuZXcgUG9zKHNlbC5hbmNob3IubGluZSwgMCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGhlYWQgPSBuZXcgUG9zKFxuICAgICAgICAgICAgICBNYXRoLm1pbihzZWwuaGVhZC5saW5lLCBzZWwuYW5jaG9yLmxpbmUpLFxuICAgICAgICAgICAgICBNYXRoLm1pbihzZWwuaGVhZC5jaCwgc2VsLmFuY2hvci5jaCkpO1xuICAgICAgICAgIGhlaWdodCA9IE1hdGguYWJzKHNlbC5oZWFkLmxpbmUgLSBzZWwuYW5jaG9yLmxpbmUpICsgMTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChpbnNlcnRBdCA9PSAnZW5kT2ZTZWxlY3RlZEFyZWEnKSB7XG4gICAgICAgICAgaWYgKCF2aW0udmlzdWFsTW9kZSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKCF2aW0udmlzdWFsQmxvY2spIHtcbiAgICAgICAgICBpZiAoc2VsLmhlYWQubGluZSA+PSBzZWwuYW5jaG9yLmxpbmUpIHtcbiAgICAgICAgICAgIGhlYWQgPSBvZmZzZXRDdXJzb3Ioc2VsLmhlYWQsIDAsIDEpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBoZWFkID0gbmV3IFBvcyhzZWwuYW5jaG9yLmxpbmUsIDApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBoZWFkID0gbmV3IFBvcyhcbiAgICAgICAgICAgICAgTWF0aC5taW4oc2VsLmhlYWQubGluZSwgc2VsLmFuY2hvci5saW5lKSxcbiAgICAgICAgICAgICAgTWF0aC5tYXgoc2VsLmhlYWQuY2gsIHNlbC5hbmNob3IuY2gpICsgMSk7XG4gICAgICAgICAgaGVpZ2h0ID0gTWF0aC5hYnMoc2VsLmhlYWQubGluZSAtIHNlbC5hbmNob3IubGluZSkgKyAxO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGluc2VydEF0ID09ICdpbnBsYWNlJykge1xuICAgICAgICBpZiAodmltLnZpc3VhbE1vZGUpe1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChpbnNlcnRBdCA9PSAnbGFzdEVkaXQnKSB7XG4gICAgICAgIGhlYWQgPSBnZXRMYXN0RWRpdFBvcyhjbSkgfHwgaGVhZDtcbiAgICAgIH1cbiAgICAgIGNtLnNldE9wdGlvbignZGlzYWJsZUlucHV0JywgZmFsc2UpO1xuICAgICAgaWYgKGFjdGlvbkFyZ3MgJiYgYWN0aW9uQXJncy5yZXBsYWNlKSB7XG4gICAgICAgIC8vIEhhbmRsZSBSZXBsYWNlLW1vZGUgYXMgYSBzcGVjaWFsIGNhc2Ugb2YgaW5zZXJ0IG1vZGUuXG4gICAgICAgIGNtLnRvZ2dsZU92ZXJ3cml0ZSh0cnVlKTtcbiAgICAgICAgY20uc2V0T3B0aW9uKCdrZXlNYXAnLCAndmltLXJlcGxhY2UnKTtcbiAgICAgICAgQ00uc2lnbmFsKGNtLCBcInZpbS1tb2RlLWNoYW5nZVwiLCB7bW9kZTogXCJyZXBsYWNlXCJ9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNtLnRvZ2dsZU92ZXJ3cml0ZShmYWxzZSk7XG4gICAgICAgIGNtLnNldE9wdGlvbigna2V5TWFwJywgJ3ZpbS1pbnNlcnQnKTtcbiAgICAgICAgQ00uc2lnbmFsKGNtLCBcInZpbS1tb2RlLWNoYW5nZVwiLCB7bW9kZTogXCJpbnNlcnRcIn0pO1xuICAgICAgfVxuICAgICAgaWYgKCF2aW1HbG9iYWxTdGF0ZS5tYWNyb01vZGVTdGF0ZS5pc1BsYXlpbmcpIHtcbiAgICAgICAgLy8gT25seSByZWNvcmQgaWYgbm90IHJlcGxheWluZy5cbiAgICAgICAgY20ub24oJ2NoYW5nZScsIG9uQ2hhbmdlKTtcbiAgICAgICAgaWYgKHZpbS5pbnNlcnRFbmQpIHZpbS5pbnNlcnRFbmQuY2xlYXIoKTtcbiAgICAgICAgdmltLmluc2VydEVuZCA9IGNtLnNldEJvb2ttYXJrKGhlYWQsIHtpbnNlcnRMZWZ0OiB0cnVlfSk7XG4gICAgICAgIENNLm9uKGNtLmdldElucHV0RmllbGQoKSwgJ2tleWRvd24nLCBvbktleUV2ZW50VGFyZ2V0S2V5RG93bik7XG4gICAgICB9XG4gICAgICBpZiAodmltLnZpc3VhbE1vZGUpIHtcbiAgICAgICAgZXhpdFZpc3VhbE1vZGUoY20pO1xuICAgICAgfVxuICAgICAgc2VsZWN0Rm9ySW5zZXJ0KGNtLCBoZWFkLCBoZWlnaHQpO1xuICAgIH0sXG4gICAgdG9nZ2xlVmlzdWFsTW9kZTogZnVuY3Rpb24oY20sIGFjdGlvbkFyZ3MsIHZpbSkge1xuICAgICAgdmFyIHJlcGVhdCA9IGFjdGlvbkFyZ3MucmVwZWF0O1xuICAgICAgdmFyIGFuY2hvciA9IGNtLmdldEN1cnNvcigpO1xuICAgICAgdmFyIGhlYWQ7XG4gICAgICAvLyBUT0RPOiBUaGUgcmVwZWF0IHNob3VsZCBhY3R1YWxseSBzZWxlY3QgbnVtYmVyIG9mIGNoYXJhY3RlcnMvbGluZXNcbiAgICAgIC8vICAgICBlcXVhbCB0byB0aGUgcmVwZWF0IHRpbWVzIHRoZSBzaXplIG9mIHRoZSBwcmV2aW91cyB2aXN1YWxcbiAgICAgIC8vICAgICBvcGVyYXRpb24uXG4gICAgICBpZiAoIXZpbS52aXN1YWxNb2RlKSB7XG4gICAgICAgIC8vIEVudGVyaW5nIHZpc3VhbCBtb2RlXG4gICAgICAgIHZpbS52aXN1YWxNb2RlID0gdHJ1ZTtcbiAgICAgICAgdmltLnZpc3VhbExpbmUgPSAhIWFjdGlvbkFyZ3MubGluZXdpc2U7XG4gICAgICAgIHZpbS52aXN1YWxCbG9jayA9ICEhYWN0aW9uQXJncy5ibG9ja3dpc2U7XG4gICAgICAgIGhlYWQgPSBjbGlwQ3Vyc29yVG9Db250ZW50KFxuICAgICAgICAgICAgY20sIG5ldyBQb3MoYW5jaG9yLmxpbmUsIGFuY2hvci5jaCArIHJlcGVhdCAtIDEpKTtcbiAgICAgICAgdmFyIG5ld1Bvc2l0aW9uID0gdXBkYXRlU2VsZWN0aW9uRm9yU3Vycm9nYXRlQ2hhcmFjdGVycyhjbSwgYW5jaG9yLCBoZWFkKTtcbiAgICAgICAgdmltLnNlbCA9IHtcbiAgICAgICAgICBhbmNob3I6IG5ld1Bvc2l0aW9uLnN0YXJ0LFxuICAgICAgICAgIGhlYWQ6IG5ld1Bvc2l0aW9uLmVuZFxuICAgICAgICB9O1xuICAgICAgICBDTS5zaWduYWwoY20sIFwidmltLW1vZGUtY2hhbmdlXCIsIHttb2RlOiBcInZpc3VhbFwiLCBzdWJNb2RlOiB2aW0udmlzdWFsTGluZSA/IFwibGluZXdpc2VcIiA6IHZpbS52aXN1YWxCbG9jayA/IFwiYmxvY2t3aXNlXCIgOiBcIlwifSk7XG4gICAgICAgIHVwZGF0ZUNtU2VsZWN0aW9uKGNtKTtcbiAgICAgICAgdXBkYXRlTWFyayhjbSwgdmltLCAnPCcsIGN1cnNvck1pbihhbmNob3IsIGhlYWQpKTtcbiAgICAgICAgdXBkYXRlTWFyayhjbSwgdmltLCAnPicsIGN1cnNvck1heChhbmNob3IsIGhlYWQpKTtcbiAgICAgIH0gZWxzZSBpZiAodmltLnZpc3VhbExpbmUgIT0gISFhY3Rpb25BcmdzLmxpbmV3aXNlIHx8XG4gICAgICAgICAgdmltLnZpc3VhbEJsb2NrICE9ICEhYWN0aW9uQXJncy5ibG9ja3dpc2UpIHtcbiAgICAgICAgLy8gVG9nZ2xpbmcgYmV0d2VlbiBtb2Rlc1xuICAgICAgICB2aW0udmlzdWFsTGluZSA9ICEhYWN0aW9uQXJncy5saW5ld2lzZTtcbiAgICAgICAgdmltLnZpc3VhbEJsb2NrID0gISFhY3Rpb25BcmdzLmJsb2Nrd2lzZTtcbiAgICAgICAgQ00uc2lnbmFsKGNtLCBcInZpbS1tb2RlLWNoYW5nZVwiLCB7bW9kZTogXCJ2aXN1YWxcIiwgc3ViTW9kZTogdmltLnZpc3VhbExpbmUgPyBcImxpbmV3aXNlXCIgOiB2aW0udmlzdWFsQmxvY2sgPyBcImJsb2Nrd2lzZVwiIDogXCJcIn0pO1xuICAgICAgICB1cGRhdGVDbVNlbGVjdGlvbihjbSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBleGl0VmlzdWFsTW9kZShjbSk7XG4gICAgICB9XG4gICAgfSxcbiAgICByZXNlbGVjdExhc3RTZWxlY3Rpb246IGZ1bmN0aW9uKGNtLCBfYWN0aW9uQXJncywgdmltKSB7XG4gICAgICB2YXIgbGFzdFNlbGVjdGlvbiA9IHZpbS5sYXN0U2VsZWN0aW9uO1xuICAgICAgaWYgKHZpbS52aXN1YWxNb2RlKSB7XG4gICAgICAgIHVwZGF0ZUxhc3RTZWxlY3Rpb24oY20sIHZpbSk7XG4gICAgICB9XG4gICAgICBpZiAobGFzdFNlbGVjdGlvbikge1xuICAgICAgICB2YXIgYW5jaG9yID0gbGFzdFNlbGVjdGlvbi5hbmNob3JNYXJrLmZpbmQoKTtcbiAgICAgICAgdmFyIGhlYWQgPSBsYXN0U2VsZWN0aW9uLmhlYWRNYXJrLmZpbmQoKTtcbiAgICAgICAgaWYgKCFhbmNob3IgfHwgIWhlYWQpIHtcbiAgICAgICAgICAvLyBJZiB0aGUgbWFya3MgaGF2ZSBiZWVuIGRlc3Ryb3llZCBkdWUgdG8gZWRpdHMsIGRvIG5vdGhpbmcuXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZpbS5zZWwgPSB7XG4gICAgICAgICAgYW5jaG9yOiBhbmNob3IsXG4gICAgICAgICAgaGVhZDogaGVhZFxuICAgICAgICB9O1xuICAgICAgICB2aW0udmlzdWFsTW9kZSA9IHRydWU7XG4gICAgICAgIHZpbS52aXN1YWxMaW5lID0gbGFzdFNlbGVjdGlvbi52aXN1YWxMaW5lO1xuICAgICAgICB2aW0udmlzdWFsQmxvY2sgPSBsYXN0U2VsZWN0aW9uLnZpc3VhbEJsb2NrO1xuICAgICAgICB1cGRhdGVDbVNlbGVjdGlvbihjbSk7XG4gICAgICAgIHVwZGF0ZU1hcmsoY20sIHZpbSwgJzwnLCBjdXJzb3JNaW4oYW5jaG9yLCBoZWFkKSk7XG4gICAgICAgIHVwZGF0ZU1hcmsoY20sIHZpbSwgJz4nLCBjdXJzb3JNYXgoYW5jaG9yLCBoZWFkKSk7XG4gICAgICAgIENNLnNpZ25hbChjbSwgJ3ZpbS1tb2RlLWNoYW5nZScsIHtcbiAgICAgICAgICBtb2RlOiAndmlzdWFsJyxcbiAgICAgICAgICBzdWJNb2RlOiB2aW0udmlzdWFsTGluZSA/ICdsaW5ld2lzZScgOlxuICAgICAgICAgICAgICAgICAgICB2aW0udmlzdWFsQmxvY2sgPyAnYmxvY2t3aXNlJyA6ICcnfSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBqb2luTGluZXM6IGZ1bmN0aW9uKGNtLCBhY3Rpb25BcmdzLCB2aW0pIHtcbiAgICAgIHZhciBjdXJTdGFydCwgY3VyRW5kO1xuICAgICAgaWYgKHZpbS52aXN1YWxNb2RlKSB7XG4gICAgICAgIGN1clN0YXJ0ID0gY20uZ2V0Q3Vyc29yKCdhbmNob3InKTtcbiAgICAgICAgY3VyRW5kID0gY20uZ2V0Q3Vyc29yKCdoZWFkJyk7XG4gICAgICAgIGlmIChjdXJzb3JJc0JlZm9yZShjdXJFbmQsIGN1clN0YXJ0KSkge1xuICAgICAgICAgIHZhciB0bXAgPSBjdXJFbmQ7XG4gICAgICAgICAgY3VyRW5kID0gY3VyU3RhcnQ7XG4gICAgICAgICAgY3VyU3RhcnQgPSB0bXA7XG4gICAgICAgIH1cbiAgICAgICAgY3VyRW5kLmNoID0gbGluZUxlbmd0aChjbSwgY3VyRW5kLmxpbmUpIC0gMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFJlcGVhdCBpcyB0aGUgbnVtYmVyIG9mIGxpbmVzIHRvIGpvaW4uIE1pbmltdW0gMiBsaW5lcy5cbiAgICAgICAgdmFyIHJlcGVhdCA9IE1hdGgubWF4KGFjdGlvbkFyZ3MucmVwZWF0LCAyKTtcbiAgICAgICAgY3VyU3RhcnQgPSBjbS5nZXRDdXJzb3IoKTtcbiAgICAgICAgY3VyRW5kID0gY2xpcEN1cnNvclRvQ29udGVudChjbSwgbmV3IFBvcyhjdXJTdGFydC5saW5lICsgcmVwZWF0IC0gMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJbmZpbml0eSkpO1xuICAgICAgfVxuICAgICAgdmFyIGZpbmFsQ2ggPSAwO1xuICAgICAgZm9yICh2YXIgaSA9IGN1clN0YXJ0LmxpbmU7IGkgPCBjdXJFbmQubGluZTsgaSsrKSB7XG4gICAgICAgIGZpbmFsQ2ggPSBsaW5lTGVuZ3RoKGNtLCBjdXJTdGFydC5saW5lKTtcbiAgICAgICAgdmFyIHRleHQgPSAnJztcbiAgICAgICAgdmFyIG5leHRTdGFydENoID0gMDtcbiAgICAgICAgaWYgKCFhY3Rpb25BcmdzLmtlZXBTcGFjZXMpIHtcbiAgICAgICAgICB2YXIgbmV4dExpbmUgPSBjbS5nZXRMaW5lKGN1clN0YXJ0LmxpbmUgKyAxKTtcbiAgICAgICAgICBuZXh0U3RhcnRDaCA9IG5leHRMaW5lLnNlYXJjaCgvXFxTLyk7XG4gICAgICAgICAgaWYgKG5leHRTdGFydENoID09IC0xKSB7XG4gICAgICAgICAgICBuZXh0U3RhcnRDaCA9IG5leHRMaW5lLmxlbmd0aDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGV4dCA9IFwiIFwiO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjbS5yZXBsYWNlUmFuZ2UodGV4dCwgXG4gICAgICAgICAgbmV3IFBvcyhjdXJTdGFydC5saW5lLCBmaW5hbENoKSxcbiAgICAgICAgICBuZXcgUG9zKGN1clN0YXJ0LmxpbmUgKyAxLCBuZXh0U3RhcnRDaCkpO1xuICAgICAgfVxuICAgICAgdmFyIGN1ckZpbmFsUG9zID0gY2xpcEN1cnNvclRvQ29udGVudChjbSwgbmV3IFBvcyhjdXJTdGFydC5saW5lLCBmaW5hbENoKSk7XG4gICAgICBpZiAodmltLnZpc3VhbE1vZGUpIHtcbiAgICAgICAgZXhpdFZpc3VhbE1vZGUoY20sIGZhbHNlKTtcbiAgICAgIH1cbiAgICAgIGNtLnNldEN1cnNvcihjdXJGaW5hbFBvcyk7XG4gICAgfSxcbiAgICBuZXdMaW5lQW5kRW50ZXJJbnNlcnRNb2RlOiBmdW5jdGlvbihjbSwgYWN0aW9uQXJncywgdmltKSB7XG4gICAgICB2aW0uaW5zZXJ0TW9kZSA9IHRydWU7XG4gICAgICB2YXIgaW5zZXJ0QXQgPSBjb3B5Q3Vyc29yKGNtLmdldEN1cnNvcigpKTtcbiAgICAgIGlmIChpbnNlcnRBdC5saW5lID09PSBjbS5maXJzdExpbmUoKSAmJiAhYWN0aW9uQXJncy5hZnRlcikge1xuICAgICAgICAvLyBTcGVjaWFsIGNhc2UgZm9yIGluc2VydGluZyBuZXdsaW5lIGJlZm9yZSBzdGFydCBvZiBkb2N1bWVudC5cbiAgICAgICAgY20ucmVwbGFjZVJhbmdlKCdcXG4nLCBuZXcgUG9zKGNtLmZpcnN0TGluZSgpLCAwKSk7XG4gICAgICAgIGNtLnNldEN1cnNvcihjbS5maXJzdExpbmUoKSwgMCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbnNlcnRBdC5saW5lID0gKGFjdGlvbkFyZ3MuYWZ0ZXIpID8gaW5zZXJ0QXQubGluZSA6XG4gICAgICAgICAgICBpbnNlcnRBdC5saW5lIC0gMTtcbiAgICAgICAgaW5zZXJ0QXQuY2ggPSBsaW5lTGVuZ3RoKGNtLCBpbnNlcnRBdC5saW5lKTtcbiAgICAgICAgY20uc2V0Q3Vyc29yKGluc2VydEF0KTtcbiAgICAgICAgdmFyIG5ld2xpbmVGbiA9IENNLmNvbW1hbmRzLm5ld2xpbmVBbmRJbmRlbnRDb250aW51ZUNvbW1lbnQgfHxcbiAgICAgICAgICAgIENNLmNvbW1hbmRzLm5ld2xpbmVBbmRJbmRlbnQ7XG4gICAgICAgIG5ld2xpbmVGbihjbSk7XG4gICAgICB9XG4gICAgICB0aGlzLmVudGVySW5zZXJ0TW9kZShjbSwgeyByZXBlYXQ6IGFjdGlvbkFyZ3MucmVwZWF0IH0sIHZpbSk7XG4gICAgfSxcbiAgICBwYXN0ZTogZnVuY3Rpb24oY20sIGFjdGlvbkFyZ3MsIHZpbSkge1xuICAgICAgdmFyIHJlZ2lzdGVyID0gdmltR2xvYmFsU3RhdGUucmVnaXN0ZXJDb250cm9sbGVyLmdldFJlZ2lzdGVyKFxuICAgICAgICAgIGFjdGlvbkFyZ3MucmVnaXN0ZXJOYW1lKTtcbiAgICAgIGlmIChhY3Rpb25BcmdzLnJlZ2lzdGVyTmFtZSA9PT0gJysnKSB7XG4gICAgICAgIG5hdmlnYXRvci5jbGlwYm9hcmQucmVhZFRleHQoKS50aGVuKCh2YWx1ZSkgPT4ge1xuICAgICAgICAgIHRoaXMuY29udGludWVQYXN0ZShjbSwgYWN0aW9uQXJncywgdmltLCB2YWx1ZSwgcmVnaXN0ZXIpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciB0ZXh0ID0gcmVnaXN0ZXIudG9TdHJpbmcoKTtcbiAgICAgICAgdGhpcy5jb250aW51ZVBhc3RlKGNtLCBhY3Rpb25BcmdzLCB2aW0sIHRleHQsIHJlZ2lzdGVyKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGNvbnRpbnVlUGFzdGU6IGZ1bmN0aW9uKGNtLCBhY3Rpb25BcmdzLCB2aW0sIHRleHQsIHJlZ2lzdGVyKSB7XG4gICAgICB2YXIgY3VyID0gY29weUN1cnNvcihjbS5nZXRDdXJzb3IoKSk7XG4gICAgICBpZiAoIXRleHQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGFjdGlvbkFyZ3MubWF0Y2hJbmRlbnQpIHtcbiAgICAgICAgdmFyIHRhYlNpemUgPSBjbS5nZXRPcHRpb24oXCJ0YWJTaXplXCIpO1xuICAgICAgICAvLyBsZW5ndGggdGhhdCBjb25zaWRlcnMgdGFicyBhbmQgdGFiU2l6ZVxuICAgICAgICB2YXIgd2hpdGVzcGFjZUxlbmd0aCA9IGZ1bmN0aW9uKC8qKiBAdHlwZSB7c3RyaW5nfSAqLyBzdHIpIHtcbiAgICAgICAgICB2YXIgdGFicyA9IChzdHIuc3BsaXQoXCJcXHRcIikubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgdmFyIHNwYWNlcyA9IChzdHIuc3BsaXQoXCIgXCIpLmxlbmd0aCAtIDEpO1xuICAgICAgICAgIHJldHVybiB0YWJzICogdGFiU2l6ZSArIHNwYWNlcyAqIDE7XG4gICAgICAgIH07XG4gICAgICAgIHZhciBjdXJyZW50TGluZSA9IGNtLmdldExpbmUoY20uZ2V0Q3Vyc29yKCkubGluZSk7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgdmFyIGluZGVudCA9IHdoaXRlc3BhY2VMZW5ndGgoY3VycmVudExpbmUubWF0Y2goL15cXHMqLylbMF0pO1xuICAgICAgICAvLyBjaG9tcCBsYXN0IG5ld2xpbmUgYi9jIGRvbid0IHdhbnQgaXQgdG8gbWF0Y2ggL15cXHMqL2dtXG4gICAgICAgIHZhciBjaG9tcGVkVGV4dCA9IHRleHQucmVwbGFjZSgvXFxuJC8sICcnKTtcbiAgICAgICAgdmFyIHdhc0Nob21wZWQgPSB0ZXh0ICE9PSBjaG9tcGVkVGV4dDtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICB2YXIgZmlyc3RJbmRlbnQgPSB3aGl0ZXNwYWNlTGVuZ3RoKHRleHQubWF0Y2goL15cXHMqLylbMF0pO1xuICAgICAgICB2YXIgdGV4dCA9IGNob21wZWRUZXh0LnJlcGxhY2UoL15cXHMqL2dtLCBmdW5jdGlvbih3c3BhY2UpIHtcbiAgICAgICAgICB2YXIgbmV3SW5kZW50ID0gaW5kZW50ICsgKHdoaXRlc3BhY2VMZW5ndGgod3NwYWNlKSAtIGZpcnN0SW5kZW50KTtcbiAgICAgICAgICBpZiAobmV3SW5kZW50IDwgMCkge1xuICAgICAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKGNtLmdldE9wdGlvbihcImluZGVudFdpdGhUYWJzXCIpKSB7XG4gICAgICAgICAgICB2YXIgcXVvdGllbnQgPSBNYXRoLmZsb29yKG5ld0luZGVudCAvIHRhYlNpemUpO1xuICAgICAgICAgICAgcmV0dXJuIEFycmF5KHF1b3RpZW50ICsgMSkuam9pbignXFx0Jyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIEFycmF5KG5ld0luZGVudCArIDEpLmpvaW4oJyAnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0ZXh0ICs9IHdhc0Nob21wZWQgPyBcIlxcblwiIDogXCJcIjtcbiAgICAgIH1cbiAgICAgIGlmIChhY3Rpb25BcmdzLnJlcGVhdCA+IDEpIHtcbiAgICAgICAgdGV4dCA9IEFycmF5KGFjdGlvbkFyZ3MucmVwZWF0ICsgMSkuam9pbih0ZXh0KTtcbiAgICAgIH1cbiAgICAgIHZhciBsaW5ld2lzZSA9IHJlZ2lzdGVyLmxpbmV3aXNlO1xuICAgICAgdmFyIGJsb2Nrd2lzZSA9IHJlZ2lzdGVyLmJsb2Nrd2lzZTtcbiAgICAgIHZhciB0ZXh0TGluZXMgPSBibG9ja3dpc2UgPyB0ZXh0LnNwbGl0KCdcXG4nKSA6IHVuZGVmaW5lZDtcbiAgICAgIGlmICh0ZXh0TGluZXMpIHtcbiAgICAgICAgaWYgKGxpbmV3aXNlKSB7XG4gICAgICAgICAgdGV4dExpbmVzLnBvcCgpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGV4dExpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdGV4dExpbmVzW2ldID0gKHRleHRMaW5lc1tpXSA9PSAnJykgPyAnICcgOiB0ZXh0TGluZXNbaV07XG4gICAgICAgIH1cbiAgICAgICAgY3VyLmNoICs9IGFjdGlvbkFyZ3MuYWZ0ZXIgPyAxIDogMDtcbiAgICAgICAgY3VyLmNoID0gTWF0aC5taW4obGluZUxlbmd0aChjbSwgY3VyLmxpbmUpLCBjdXIuY2gpO1xuICAgICAgfSBlbHNlIGlmIChsaW5ld2lzZSkge1xuICAgICAgICBpZiAodmltLnZpc3VhbE1vZGUpIHtcbiAgICAgICAgICB0ZXh0ID0gdmltLnZpc3VhbExpbmUgPyB0ZXh0LnNsaWNlKDAsIC0xKSA6ICdcXG4nICsgdGV4dC5zbGljZSgwLCB0ZXh0Lmxlbmd0aCAtIDEpICsgJ1xcbic7XG4gICAgICAgIH0gZWxzZSBpZiAoYWN0aW9uQXJncy5hZnRlcikge1xuICAgICAgICAgIC8vIE1vdmUgdGhlIG5ld2xpbmUgYXQgdGhlIGVuZCB0byB0aGUgc3RhcnQgaW5zdGVhZCwgYW5kIHBhc3RlIGp1c3RcbiAgICAgICAgICAvLyBiZWZvcmUgdGhlIG5ld2xpbmUgY2hhcmFjdGVyIG9mIHRoZSBsaW5lIHdlIGFyZSBvbiByaWdodCBub3cuXG4gICAgICAgICAgdGV4dCA9ICdcXG4nICsgdGV4dC5zbGljZSgwLCB0ZXh0Lmxlbmd0aCAtIDEpO1xuICAgICAgICAgIGN1ci5jaCA9IGxpbmVMZW5ndGgoY20sIGN1ci5saW5lKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjdXIuY2ggPSAwO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjdXIuY2ggKz0gYWN0aW9uQXJncy5hZnRlciA/IDEgOiAwO1xuICAgICAgfVxuICAgICAgdmFyIGN1clBvc0ZpbmFsO1xuICAgICAgaWYgKHZpbS52aXN1YWxNb2RlKSB7XG4gICAgICAgIC8vICBzYXZlIHRoZSBwYXN0ZWQgdGV4dCBmb3IgcmVzZWxlY3Rpb24gaWYgdGhlIG5lZWQgYXJpc2VzXG4gICAgICAgIHZpbS5sYXN0UGFzdGVkVGV4dCA9IHRleHQ7XG4gICAgICAgIHZhciBsYXN0U2VsZWN0aW9uQ3VyRW5kO1xuICAgICAgICB2YXIgc2VsZWN0ZWRBcmVhID0gZ2V0U2VsZWN0ZWRBcmVhUmFuZ2UoY20pO1xuICAgICAgICB2YXIgc2VsZWN0aW9uU3RhcnQgPSBzZWxlY3RlZEFyZWFbMF07XG4gICAgICAgIHZhciBzZWxlY3Rpb25FbmQgPSBzZWxlY3RlZEFyZWFbMV07XG4gICAgICAgIHZhciBzZWxlY3RlZFRleHQgPSBjbS5nZXRTZWxlY3Rpb24oKTtcbiAgICAgICAgdmFyIHNlbGVjdGlvbnMgPSBjbS5saXN0U2VsZWN0aW9ucygpO1xuICAgICAgICB2YXIgZW1wdHlTdHJpbmdzID0gbmV3IEFycmF5KHNlbGVjdGlvbnMubGVuZ3RoKS5qb2luKCcxJykuc3BsaXQoJzEnKTtcbiAgICAgICAgLy8gc2F2ZSB0aGUgY3VyRW5kIG1hcmtlciBiZWZvcmUgaXQgZ2V0IGNsZWFyZWQgZHVlIHRvIGNtLnJlcGxhY2VSYW5nZS5cbiAgICAgICAgaWYgKHZpbS5sYXN0U2VsZWN0aW9uKSB7XG4gICAgICAgICAgbGFzdFNlbGVjdGlvbkN1ckVuZCA9IHZpbS5sYXN0U2VsZWN0aW9uLmhlYWRNYXJrLmZpbmQoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBwdXNoIHRoZSBwcmV2aW91c2x5IHNlbGVjdGVkIHRleHQgdG8gdW5uYW1lZCByZWdpc3RlclxuICAgICAgICB2aW1HbG9iYWxTdGF0ZS5yZWdpc3RlckNvbnRyb2xsZXIudW5uYW1lZFJlZ2lzdGVyLnNldFRleHQoc2VsZWN0ZWRUZXh0KTtcbiAgICAgICAgaWYgKGJsb2Nrd2lzZSkge1xuICAgICAgICAgIC8vIGZpcnN0IGRlbGV0ZSB0aGUgc2VsZWN0ZWQgdGV4dFxuICAgICAgICAgIGNtLnJlcGxhY2VTZWxlY3Rpb25zKGVtcHR5U3RyaW5ncyk7XG4gICAgICAgICAgLy8gU2V0IG5ldyBzZWxlY3Rpb25zIGFzIHBlciB0aGUgYmxvY2sgbGVuZ3RoIG9mIHRoZSB5YW5rZWQgdGV4dFxuICAgICAgICAgIHNlbGVjdGlvbkVuZCA9IG5ldyBQb3Moc2VsZWN0aW9uU3RhcnQubGluZSArIHRleHQubGVuZ3RoLTEsIHNlbGVjdGlvblN0YXJ0LmNoKTtcbiAgICAgICAgICBjbS5zZXRDdXJzb3Ioc2VsZWN0aW9uU3RhcnQpO1xuICAgICAgICAgIHNlbGVjdEJsb2NrKGNtLCBzZWxlY3Rpb25FbmQpO1xuICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICBjbS5yZXBsYWNlU2VsZWN0aW9ucyh0ZXh0KTtcbiAgICAgICAgICBjdXJQb3NGaW5hbCA9IHNlbGVjdGlvblN0YXJ0O1xuICAgICAgICB9IGVsc2UgaWYgKHZpbS52aXN1YWxCbG9jaykge1xuICAgICAgICAgIGNtLnJlcGxhY2VTZWxlY3Rpb25zKGVtcHR5U3RyaW5ncyk7XG4gICAgICAgICAgY20uc2V0Q3Vyc29yKHNlbGVjdGlvblN0YXJ0KTtcbiAgICAgICAgICBjbS5yZXBsYWNlUmFuZ2UodGV4dCwgc2VsZWN0aW9uU3RhcnQsIHNlbGVjdGlvblN0YXJ0KTtcbiAgICAgICAgICBjdXJQb3NGaW5hbCA9IHNlbGVjdGlvblN0YXJ0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNtLnJlcGxhY2VSYW5nZSh0ZXh0LCBzZWxlY3Rpb25TdGFydCwgc2VsZWN0aW9uRW5kKTtcbiAgICAgICAgICBjdXJQb3NGaW5hbCA9IGNtLnBvc0Zyb21JbmRleChjbS5pbmRleEZyb21Qb3Moc2VsZWN0aW9uU3RhcnQpICsgdGV4dC5sZW5ndGggLSAxKTtcbiAgICAgICAgfVxuICAgICAgICAvLyByZXN0b3JlIHRoZSBjdXJFbmQgbWFya2VyXG4gICAgICAgIGlmKGxhc3RTZWxlY3Rpb25DdXJFbmQpIHtcbiAgICAgICAgICB2aW0ubGFzdFNlbGVjdGlvbi5oZWFkTWFyayA9IGNtLnNldEJvb2ttYXJrKGxhc3RTZWxlY3Rpb25DdXJFbmQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsaW5ld2lzZSkge1xuICAgICAgICAgIGN1clBvc0ZpbmFsLmNoPTA7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChibG9ja3dpc2UgJiYgdGV4dExpbmVzKSB7XG4gICAgICAgICAgY20uc2V0Q3Vyc29yKGN1cik7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0ZXh0TGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBsaW5lID0gY3VyLmxpbmUraTtcbiAgICAgICAgICAgIGlmIChsaW5lID4gY20ubGFzdExpbmUoKSkge1xuICAgICAgICAgICAgICBjbS5yZXBsYWNlUmFuZ2UoJ1xcbicsICBuZXcgUG9zKGxpbmUsIDApKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBsYXN0Q2ggPSBsaW5lTGVuZ3RoKGNtLCBsaW5lKTtcbiAgICAgICAgICAgIGlmIChsYXN0Q2ggPCBjdXIuY2gpIHtcbiAgICAgICAgICAgICAgZXh0ZW5kTGluZVRvQ29sdW1uKGNtLCBsaW5lLCBjdXIuY2gpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBjbS5zZXRDdXJzb3IoY3VyKTtcbiAgICAgICAgICBzZWxlY3RCbG9jayhjbSwgbmV3IFBvcyhjdXIubGluZSArIHRleHRMaW5lcy5sZW5ndGgtMSwgY3VyLmNoKSk7XG4gICAgICAgICAgY20ucmVwbGFjZVNlbGVjdGlvbnModGV4dExpbmVzKTtcbiAgICAgICAgICBjdXJQb3NGaW5hbCA9IGN1cjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjbS5yZXBsYWNlUmFuZ2UodGV4dCwgY3VyKTtcbiAgICAgICAgICAvLyBOb3cgZmluZSB0dW5lIHRoZSBjdXJzb3IgdG8gd2hlcmUgd2Ugd2FudCBpdC5cbiAgICAgICAgICBpZiAobGluZXdpc2UpIHtcbiAgICAgICAgICAgIHZhciBsaW5lID0gYWN0aW9uQXJncy5hZnRlciA/IGN1ci5saW5lICsgMSA6IGN1ci5saW5lO1xuICAgICAgICAgICAgY3VyUG9zRmluYWwgPSBuZXcgUG9zKGxpbmUsIGZpbmRGaXJzdE5vbldoaXRlU3BhY2VDaGFyYWN0ZXIoY20uZ2V0TGluZShsaW5lKSkpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjdXJQb3NGaW5hbCA9IGNvcHlDdXJzb3IoY3VyKTtcbiAgICAgICAgICAgIGlmICghL1xcbi8udGVzdCh0ZXh0KSkge1xuICAgICAgICAgICAgICBjdXJQb3NGaW5hbC5jaCArPSB0ZXh0Lmxlbmd0aCAtIChhY3Rpb25BcmdzLmFmdGVyID8gMSA6IDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHZpbS52aXN1YWxNb2RlKSB7XG4gICAgICAgIGV4aXRWaXN1YWxNb2RlKGNtLCBmYWxzZSk7XG4gICAgICB9XG4gICAgICBjbS5zZXRDdXJzb3IoY3VyUG9zRmluYWwpO1xuICAgIH0sXG4gICAgdW5kbzogZnVuY3Rpb24oY20sIGFjdGlvbkFyZ3MpIHtcbiAgICAgIGNtLm9wZXJhdGlvbihmdW5jdGlvbigpIHtcbiAgICAgICAgcmVwZWF0Rm4oY20sIENNLmNvbW1hbmRzLnVuZG8sIGFjdGlvbkFyZ3MucmVwZWF0KSgpO1xuICAgICAgICBjbS5zZXRDdXJzb3IoY2xpcEN1cnNvclRvQ29udGVudChjbSwgY20uZ2V0Q3Vyc29yKCdzdGFydCcpKSk7XG4gICAgICB9KTtcbiAgICB9LFxuICAgIHJlZG86IGZ1bmN0aW9uKGNtLCBhY3Rpb25BcmdzKSB7XG4gICAgICByZXBlYXRGbihjbSwgQ00uY29tbWFuZHMucmVkbywgYWN0aW9uQXJncy5yZXBlYXQpKCk7XG4gICAgfSxcbiAgICBzZXRSZWdpc3RlcjogZnVuY3Rpb24oX2NtLCBhY3Rpb25BcmdzLCB2aW0pIHtcbiAgICAgIHZpbS5pbnB1dFN0YXRlLnJlZ2lzdGVyTmFtZSA9IGFjdGlvbkFyZ3Muc2VsZWN0ZWRDaGFyYWN0ZXI7XG4gICAgfSxcbiAgICBpbnNlcnRSZWdpc3RlcjogZnVuY3Rpb24oY20sIGFjdGlvbkFyZ3MsIHZpbSkge1xuICAgICAgdmFyIHJlZ2lzdGVyTmFtZSA9IGFjdGlvbkFyZ3Muc2VsZWN0ZWRDaGFyYWN0ZXI7XG4gICAgICB2YXIgcmVnaXN0ZXIgPSB2aW1HbG9iYWxTdGF0ZS5yZWdpc3RlckNvbnRyb2xsZXIuZ2V0UmVnaXN0ZXIocmVnaXN0ZXJOYW1lKTtcbiAgICAgIHZhciB0ZXh0ID0gcmVnaXN0ZXIgJiYgcmVnaXN0ZXIudG9TdHJpbmcoKTtcbiAgICAgIGlmICh0ZXh0KSB7XG4gICAgICAgIGNtLnJlcGxhY2VTZWxlY3Rpb24odGV4dCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBvbmVOb3JtYWxDb21tYW5kOiBmdW5jdGlvbihjbSwgYWN0aW9uQXJncywgdmltKSB7XG4gICAgICBleGl0SW5zZXJ0TW9kZShjbSwgdHJ1ZSk7XG4gICAgICB2aW0uaW5zZXJ0TW9kZVJldHVybiA9IHRydWU7XG4gICAgICBDTS5vbihjbSwgJ3ZpbS1jb21tYW5kLWRvbmUnLCBmdW5jdGlvbiBoYW5kbGVyKCkge1xuICAgICAgICBpZiAodmltLnZpc3VhbE1vZGUpIHJldHVybjtcbiAgICAgICAgaWYgKHZpbS5pbnNlcnRNb2RlUmV0dXJuKSB7XG4gICAgICAgICAgdmltLmluc2VydE1vZGVSZXR1cm4gPSBmYWxzZTtcbiAgICAgICAgICBpZiAoIXZpbS5pbnNlcnRNb2RlKSB7XG4gICAgICAgICAgICBhY3Rpb25zLmVudGVySW5zZXJ0TW9kZShjbSwge30sIHZpbSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIENNLm9mZihjbSwgJ3ZpbS1jb21tYW5kLWRvbmUnLCBoYW5kbGVyKTtcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgc2V0TWFyazogZnVuY3Rpb24oY20sIGFjdGlvbkFyZ3MsIHZpbSkge1xuICAgICAgdmFyIG1hcmtOYW1lID0gYWN0aW9uQXJncy5zZWxlY3RlZENoYXJhY3RlcjtcbiAgICAgIGlmIChtYXJrTmFtZSkgdXBkYXRlTWFyayhjbSwgdmltLCBtYXJrTmFtZSwgY20uZ2V0Q3Vyc29yKCkpO1xuICAgIH0sXG4gICAgcmVwbGFjZTogZnVuY3Rpb24oY20sIGFjdGlvbkFyZ3MsIHZpbSkge1xuICAgICAgdmFyIHJlcGxhY2VXaXRoID0gYWN0aW9uQXJncy5zZWxlY3RlZENoYXJhY3RlciB8fCBcIlwiO1xuICAgICAgdmFyIGN1clN0YXJ0ID0gY20uZ2V0Q3Vyc29yKCk7XG4gICAgICB2YXIgcmVwbGFjZVRvO1xuICAgICAgdmFyIGN1ckVuZDtcbiAgICAgIHZhciBzZWxlY3Rpb25zID0gY20ubGlzdFNlbGVjdGlvbnMoKTtcbiAgICAgIGlmICh2aW0udmlzdWFsTW9kZSkge1xuICAgICAgICBjdXJTdGFydCA9IGNtLmdldEN1cnNvcignc3RhcnQnKTtcbiAgICAgICAgY3VyRW5kID0gY20uZ2V0Q3Vyc29yKCdlbmQnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBsaW5lID0gY20uZ2V0TGluZShjdXJTdGFydC5saW5lKTtcbiAgICAgICAgcmVwbGFjZVRvID0gY3VyU3RhcnQuY2ggKyBhY3Rpb25BcmdzLnJlcGVhdDtcbiAgICAgICAgaWYgKHJlcGxhY2VUbyA+IGxpbmUubGVuZ3RoKSB7XG4gICAgICAgICAgcmVwbGFjZVRvPWxpbmUubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGN1ckVuZCA9IG5ldyBQb3MoY3VyU3RhcnQubGluZSwgcmVwbGFjZVRvKTtcbiAgICAgIH1cblxuICAgICAgdmFyIG5ld1Bvc2l0aW9ucyA9IHVwZGF0ZVNlbGVjdGlvbkZvclN1cnJvZ2F0ZUNoYXJhY3RlcnMoY20sIGN1clN0YXJ0LCBjdXJFbmQpO1xuICAgICAgY3VyU3RhcnQgPSBuZXdQb3NpdGlvbnMuc3RhcnQ7XG4gICAgICBjdXJFbmQgPSBuZXdQb3NpdGlvbnMuZW5kO1xuICAgICAgaWYgKHJlcGxhY2VXaXRoPT0nXFxuJykge1xuICAgICAgICBpZiAoIXZpbS52aXN1YWxNb2RlKSBjbS5yZXBsYWNlUmFuZ2UoJycsIGN1clN0YXJ0LCBjdXJFbmQpO1xuICAgICAgICAvLyBzcGVjaWFsIGNhc2UsIHdoZXJlIHZpbSBoZWxwIHNheXMgdG8gcmVwbGFjZSBieSBqdXN0IG9uZSBsaW5lLWJyZWFrXG4gICAgICAgIChDTS5jb21tYW5kcy5uZXdsaW5lQW5kSW5kZW50Q29udGludWVDb21tZW50IHx8IENNLmNvbW1hbmRzLm5ld2xpbmVBbmRJbmRlbnQpKGNtKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciByZXBsYWNlV2l0aFN0ciA9IGNtLmdldFJhbmdlKGN1clN0YXJ0LCBjdXJFbmQpO1xuICAgICAgICAvLyByZXBsYWNlIGFsbCBzdXJyb2dhdGUgY2hhcmFjdGVycyB3aXRoIHNlbGVjdGVkIGNoYXJhY3RlclxuICAgICAgICByZXBsYWNlV2l0aFN0ciA9IHJlcGxhY2VXaXRoU3RyLnJlcGxhY2UoL1tcXHVEODAwLVxcdURCRkZdW1xcdURDMDAtXFx1REZGRl0vZywgcmVwbGFjZVdpdGgpO1xuICAgICAgICAvL3JlcGxhY2UgYWxsIGNoYXJhY3RlcnMgaW4gcmFuZ2UgYnkgc2VsZWN0ZWQsIGJ1dCBrZWVwIGxpbmVicmVha3NcbiAgICAgICAgcmVwbGFjZVdpdGhTdHIgPSByZXBsYWNlV2l0aFN0ci5yZXBsYWNlKC9bXlxcbl0vZywgcmVwbGFjZVdpdGgpO1xuICAgICAgICBpZiAodmltLnZpc3VhbEJsb2NrKSB7XG4gICAgICAgICAgLy8gVGFicyBhcmUgc3BsaXQgaW4gdmlzdWEgYmxvY2sgYmVmb3JlIHJlcGxhY2luZ1xuICAgICAgICAgIHZhciBzcGFjZXMgPSBuZXcgQXJyYXkoY20uZ2V0T3B0aW9uKFwidGFiU2l6ZVwiKSsxKS5qb2luKCcgJyk7XG4gICAgICAgICAgcmVwbGFjZVdpdGhTdHIgPSBjbS5nZXRTZWxlY3Rpb24oKTtcbiAgICAgICAgICByZXBsYWNlV2l0aFN0ciA9IHJlcGxhY2VXaXRoU3RyLnJlcGxhY2UoL1tcXHVEODAwLVxcdURCRkZdW1xcdURDMDAtXFx1REZGRl0vZywgcmVwbGFjZVdpdGgpO1xuICAgICAgICAgIHZhciByZXBsYWNlV2l0aFN0cmluZ3MgPSByZXBsYWNlV2l0aFN0ci5yZXBsYWNlKC9cXHQvZywgc3BhY2VzKS5yZXBsYWNlKC9bXlxcbl0vZywgcmVwbGFjZVdpdGgpLnNwbGl0KCdcXG4nKTtcbiAgICAgICAgICBjbS5yZXBsYWNlU2VsZWN0aW9ucyhyZXBsYWNlV2l0aFN0cmluZ3MpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNtLnJlcGxhY2VSYW5nZShyZXBsYWNlV2l0aFN0ciwgY3VyU3RhcnQsIGN1ckVuZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZpbS52aXN1YWxNb2RlKSB7XG4gICAgICAgICAgY3VyU3RhcnQgPSBjdXJzb3JJc0JlZm9yZShzZWxlY3Rpb25zWzBdLmFuY2hvciwgc2VsZWN0aW9uc1swXS5oZWFkKSA/XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3Rpb25zWzBdLmFuY2hvciA6IHNlbGVjdGlvbnNbMF0uaGVhZDtcbiAgICAgICAgICBjbS5zZXRDdXJzb3IoY3VyU3RhcnQpO1xuICAgICAgICAgIGV4aXRWaXN1YWxNb2RlKGNtLCBmYWxzZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY20uc2V0Q3Vyc29yKG9mZnNldEN1cnNvcihjdXJFbmQsIDAsIC0xKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGluY3JlbWVudE51bWJlclRva2VuOiBmdW5jdGlvbihjbSwgYWN0aW9uQXJncykge1xuICAgICAgdmFyIGN1ciA9IGNtLmdldEN1cnNvcigpO1xuICAgICAgdmFyIGxpbmVTdHIgPSBjbS5nZXRMaW5lKGN1ci5saW5lKTtcbiAgICAgIHZhciByZSA9IC8oLT8pKD86KDB4KShbXFxkYS1mXSspfCgwYnwwfCkoXFxkKykpL2dpO1xuICAgICAgdmFyIG1hdGNoO1xuICAgICAgdmFyIHN0YXJ0O1xuICAgICAgdmFyIGVuZDtcbiAgICAgIHZhciBudW1iZXJTdHI7XG4gICAgICB3aGlsZSAoKG1hdGNoID0gcmUuZXhlYyhsaW5lU3RyKSkgIT09IG51bGwpIHtcbiAgICAgICAgc3RhcnQgPSBtYXRjaC5pbmRleDtcbiAgICAgICAgZW5kID0gc3RhcnQgKyBtYXRjaFswXS5sZW5ndGg7XG4gICAgICAgIGlmIChjdXIuY2ggPCBlbmQpYnJlYWs7XG4gICAgICB9XG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICBpZiAoIWFjdGlvbkFyZ3MuYmFja3RyYWNrICYmIChlbmQgPD0gY3VyLmNoKSlyZXR1cm47XG4gICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgdmFyIGJhc2VTdHIgPSBtYXRjaFsyXSB8fCBtYXRjaFs0XTtcbiAgICAgICAgdmFyIGRpZ2l0cyA9IG1hdGNoWzNdIHx8IG1hdGNoWzVdO1xuICAgICAgICB2YXIgaW5jcmVtZW50ID0gYWN0aW9uQXJncy5pbmNyZWFzZSA/IDEgOiAtMTtcbiAgICAgICAgdmFyIGJhc2UgPSB7JzBiJzogMiwgJzAnOiA4LCAnJzogMTAsICcweCc6IDE2fVtiYXNlU3RyLnRvTG93ZXJDYXNlKCldO1xuICAgICAgICB2YXIgbnVtYmVyID0gcGFyc2VJbnQobWF0Y2hbMV0gKyBkaWdpdHMsIGJhc2UpICsgKGluY3JlbWVudCAqIGFjdGlvbkFyZ3MucmVwZWF0KTtcbiAgICAgICAgbnVtYmVyU3RyID0gbnVtYmVyLnRvU3RyaW5nKGJhc2UpO1xuICAgICAgICB2YXIgemVyb1BhZGRpbmcgPSBiYXNlU3RyID8gbmV3IEFycmF5KGRpZ2l0cy5sZW5ndGggLSBudW1iZXJTdHIubGVuZ3RoICsgMSArIG1hdGNoWzFdLmxlbmd0aCkuam9pbignMCcpIDogJyc7XG4gICAgICAgIGlmIChudW1iZXJTdHIuY2hhckF0KDApID09PSAnLScpIHtcbiAgICAgICAgICBudW1iZXJTdHIgPSAnLScgKyBiYXNlU3RyICsgemVyb1BhZGRpbmcgKyBudW1iZXJTdHIuc3Vic3RyKDEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG51bWJlclN0ciA9IGJhc2VTdHIgKyB6ZXJvUGFkZGluZyArIG51bWJlclN0cjtcbiAgICAgICAgfVxuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIHZhciBmcm9tID0gbmV3IFBvcyhjdXIubGluZSwgc3RhcnQpO1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIHZhciB0byA9IG5ldyBQb3MoY3VyLmxpbmUsIGVuZCk7XG4gICAgICAgIGNtLnJlcGxhY2VSYW5nZShudW1iZXJTdHIsIGZyb20sIHRvKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIGNtLnNldEN1cnNvcihuZXcgUG9zKGN1ci5saW5lLCBzdGFydCArIG51bWJlclN0ci5sZW5ndGggLSAxKSk7XG4gICAgfSxcbiAgICByZXBlYXRMYXN0RWRpdDogZnVuY3Rpb24oY20sIGFjdGlvbkFyZ3MsIHZpbSkge1xuICAgICAgdmFyIGxhc3RFZGl0SW5wdXRTdGF0ZSA9IHZpbS5sYXN0RWRpdElucHV0U3RhdGU7XG4gICAgICBpZiAoIWxhc3RFZGl0SW5wdXRTdGF0ZSkgeyByZXR1cm47IH1cbiAgICAgIHZhciByZXBlYXQgPSBhY3Rpb25BcmdzLnJlcGVhdDtcbiAgICAgIGlmIChyZXBlYXQgJiYgYWN0aW9uQXJncy5yZXBlYXRJc0V4cGxpY2l0KSB7XG4gICAgICAgIGxhc3RFZGl0SW5wdXRTdGF0ZS5yZXBlYXRPdmVycmlkZSA9IHJlcGVhdDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlcGVhdCA9IGxhc3RFZGl0SW5wdXRTdGF0ZS5yZXBlYXRPdmVycmlkZSB8fCByZXBlYXQ7XG4gICAgICB9XG4gICAgICByZXBlYXRMYXN0RWRpdChjbSwgdmltLCByZXBlYXQsIGZhbHNlIC8qKiByZXBlYXRGb3JJbnNlcnQgKi8pO1xuICAgIH0sXG4gICAgaW5kZW50OiBmdW5jdGlvbihjbSwgYWN0aW9uQXJncykge1xuICAgICAgY20uaW5kZW50TGluZShjbS5nZXRDdXJzb3IoKS5saW5lLCBhY3Rpb25BcmdzLmluZGVudFJpZ2h0KTtcbiAgICB9LFxuICAgIGV4aXRJbnNlcnRNb2RlOiBmdW5jdGlvbihjbSwgYWN0aW9uQXJncykge1xuICAgICAgZXhpdEluc2VydE1vZGUoY20pO1xuICAgIH1cbiAgfTtcblxuICAvKiogQGFyZyB7c3RyaW5nIH0gbmFtZSAgQGFyZyB7aW1wb3J0KFwiLi90eXBlc1wiKS5BY3Rpb25Gbn0gZm4gKi9cbiAgZnVuY3Rpb24gZGVmaW5lQWN0aW9uKG5hbWUsIGZuKSB7XG4gICAgYWN0aW9uc1tuYW1lXSA9IGZuO1xuICB9XG5cbiAgLypcbiAgICogQmVsb3cgYXJlIG1pc2NlbGxhbmVvdXMgdXRpbGl0eSBmdW5jdGlvbnMgdXNlZCBieSB2aW0uanNcbiAgICovXG5cbiAgLyoqXG4gICAqIENsaXBzIGN1cnNvciB0byBlbnN1cmUgdGhhdCBsaW5lIGlzIHdpdGhpbiB0aGUgYnVmZmVyJ3MgcmFuZ2VcbiAgICogYW5kIGlzIG5vdCBpbnNpZGUgc3Vycm9nYXRlIHBhaXJcbiAgICogSWYgaW5jbHVkZUxpbmVCcmVhayBpcyB0cnVlLCB0aGVuIGFsbG93IGN1ci5jaCA9PSBsaW5lTGVuZ3RoLlxuICAgKiBAYXJnIHtDb2RlTWlycm9yVn0gY20gXG4gICAqIEBhcmcge1Bvc30gY3VyIFxuICAgKiBAYXJnIHtQb3N9IFtvbGRDdXJdXG4gICAqIEByZXR1cm4ge1Bvc31cbiAgICovXG4gIGZ1bmN0aW9uIGNsaXBDdXJzb3JUb0NvbnRlbnQoY20sIGN1ciwgb2xkQ3VyKSB7XG4gICAgdmFyIHZpbSA9IGNtLnN0YXRlLnZpbTtcbiAgICB2YXIgaW5jbHVkZUxpbmVCcmVhayA9IHZpbS5pbnNlcnRNb2RlIHx8IHZpbS52aXN1YWxNb2RlO1xuICAgIHZhciBsaW5lID0gTWF0aC5taW4oTWF0aC5tYXgoY20uZmlyc3RMaW5lKCksIGN1ci5saW5lKSwgY20ubGFzdExpbmUoKSApO1xuICAgIHZhciB0ZXh0ID0gY20uZ2V0TGluZShsaW5lKTtcbiAgICB2YXIgbWF4Q2ggPSB0ZXh0Lmxlbmd0aCAtIDEgKyBOdW1iZXIoISFpbmNsdWRlTGluZUJyZWFrKTtcbiAgICB2YXIgY2ggPSBNYXRoLm1pbihNYXRoLm1heCgwLCBjdXIuY2gpLCBtYXhDaCk7XG4gICAgLy8gcHJldmVudCBjdXJzb3IgZnJvbSBlbnRlcmluZyBzdXJyb2dhdGUgcGFpclxuICAgIHZhciBjaGFyQ29kZSA9IHRleHQuY2hhckNvZGVBdChjaCk7XG4gICAgaWYgKDB4REMwMCA8PSBjaGFyQ29kZSAmJiBjaGFyQ29kZSA8PSAweERGRkYpIHtcbiAgICAgIHZhciBkaXJlY3Rpb24gPSAxO1xuICAgICAgaWYgKG9sZEN1ciAmJiBvbGRDdXIubGluZSA9PSBsaW5lICYmIG9sZEN1ci5jaCA+IGNoKSB7XG4gICAgICAgIGRpcmVjdGlvbiA9IC0xO1xuICAgICAgfVxuICAgICAgY2ggKz1kaXJlY3Rpb247XG4gICAgICBpZiAoY2ggPiBtYXhDaCkgY2ggLT0yO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFBvcyhsaW5lLCBjaCk7XG4gIH1cbiAgLyoqQHR5cGUgPFQ+KGFyZ3M6IFQpPT5UICovXG4gIGZ1bmN0aW9uIGNvcHlBcmdzKGFyZ3MpIHtcbiAgICB2YXIgcmV0ID0gLyoqQHR5cGV7dHlwZW9mIGFyZ3N9Ki8oe30pO1xuICAgIGZvciAodmFyIHByb3AgaW4gYXJncykge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChhcmdzLCBwcm9wKSkge1xuICAgICAgICByZXRbcHJvcF0gPSBhcmdzW3Byb3BdO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gIC8qKkB0eXBle3R5cGVvZiBhcmdzfSovKHJldCk7XG4gIH1cbiAgLyoqXG4gICAqIEBwYXJhbSB7UG9zfSBjdXJcbiAgICogQHBhcmFtIHtudW1iZXJ8UG9zfSBvZmZzZXRMaW5lXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRDaFxuICAgKi9cbiAgZnVuY3Rpb24gb2Zmc2V0Q3Vyc29yKGN1ciwgb2Zmc2V0TGluZSwgb2Zmc2V0Q2gpIHtcbiAgICBpZiAodHlwZW9mIG9mZnNldExpbmUgPT09ICdvYmplY3QnKSB7XG4gICAgICBvZmZzZXRDaCA9IG9mZnNldExpbmUuY2g7XG4gICAgICBvZmZzZXRMaW5lID0gb2Zmc2V0TGluZS5saW5lO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFBvcyhjdXIubGluZSArIG9mZnNldExpbmUsIGN1ci5jaCArIG9mZnNldENoKTtcbiAgfVxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleXNcbiAgICogQHBhcmFtIHt2aW1LZXlbXX0ga2V5TWFwXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjb250ZXh0XG4gICAqIEBwYXJhbSB7SW5wdXRTdGF0ZUludGVyZmFjZX0gaW5wdXRTdGF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gY29tbWFuZE1hdGNoZXMoa2V5cywga2V5TWFwLCBjb250ZXh0LCBpbnB1dFN0YXRlKSB7XG4gICAgLy8gUGFydGlhbCBtYXRjaGVzIGFyZSBub3QgYXBwbGllZC4gVGhleSBpbmZvcm0gdGhlIGtleSBoYW5kbGVyXG4gICAgLy8gdGhhdCB0aGUgY3VycmVudCBrZXkgc2VxdWVuY2UgaXMgYSBzdWJzZXF1ZW5jZSBvZiBhIHZhbGlkIGtleVxuICAgIC8vIHNlcXVlbmNlLCBzbyB0aGF0IHRoZSBrZXkgYnVmZmVyIGlzIG5vdCBjbGVhcmVkLlxuICAgIGlmIChpbnB1dFN0YXRlLm9wZXJhdG9yKSBjb250ZXh0ID0gXCJvcGVyYXRvclBlbmRpbmdcIjtcbiAgICB2YXIgbWF0Y2gsIHBhcnRpYWwgPSBbXSwgZnVsbCA9IFtdO1xuICAgIC8vIGlmIGN1cnJlbnRseSBleHBhbmRlZCBrZXkgY29tZXMgZnJvbSBhIG5vcmVtYXAsIHNlYXJjZyBvbmx5IGluIGRlZmF1bHQga2V5c1xuICAgIHZhciBzdGFydEluZGV4ID0gbm9yZW1hcCA/IGtleU1hcC5sZW5ndGggLSBkZWZhdWx0S2V5bWFwTGVuZ3RoIDogMDtcbiAgICBmb3IgKHZhciBpID0gc3RhcnRJbmRleDsgaSA8IGtleU1hcC5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGNvbW1hbmQgPSBrZXlNYXBbaV07XG4gICAgICBpZiAoY29udGV4dCA9PSAnaW5zZXJ0JyAmJiBjb21tYW5kLmNvbnRleHQgIT0gJ2luc2VydCcgfHxcbiAgICAgICAgICAoY29tbWFuZC5jb250ZXh0ICYmIGNvbW1hbmQuY29udGV4dCAhPSBjb250ZXh0KSB8fFxuICAgICAgICAgIGlucHV0U3RhdGUub3BlcmF0b3IgJiYgY29tbWFuZC50eXBlID09ICdhY3Rpb24nIHx8XG4gICAgICAgICAgIShtYXRjaCA9IGNvbW1hbmRNYXRjaChrZXlzLCBjb21tYW5kLmtleXMpKSkgeyBjb250aW51ZTsgfVxuICAgICAgaWYgKG1hdGNoID09ICdwYXJ0aWFsJykgeyBwYXJ0aWFsLnB1c2goY29tbWFuZCk7IH1cbiAgICAgIGlmIChtYXRjaCA9PSAnZnVsbCcpIHsgZnVsbC5wdXNoKGNvbW1hbmQpOyB9XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBwYXJ0aWFsOiBwYXJ0aWFsLFxuICAgICAgZnVsbDogZnVsbFxuICAgIH07XG4gIH1cbiAgLyoqIEBhcmcge3N0cmluZ30gcHJlc3NlZCAgQGFyZyB7c3RyaW5nfSBtYXBwZWQgIEByZXR1cm4geydmdWxsJ3wncGFydGlhbCd8ZmFsc2V9Ki9cbiAgZnVuY3Rpb24gY29tbWFuZE1hdGNoKHByZXNzZWQsIG1hcHBlZCkge1xuICAgIGNvbnN0IGlzTGFzdENoYXJhY3RlciA9IG1hcHBlZC5zbGljZSgtMTEpID09ICc8Y2hhcmFjdGVyPic7XG4gICAgY29uc3QgaXNMYXN0UmVnaXN0ZXIgPSBtYXBwZWQuc2xpY2UoLTEwKSA9PSAnPHJlZ2lzdGVyPic7XG4gICAgaWYgKGlzTGFzdENoYXJhY3RlciB8fCBpc0xhc3RSZWdpc3Rlcikge1xuICAgICAgLy8gTGFzdCBjaGFyYWN0ZXIgbWF0Y2hlcyBhbnl0aGluZy5cbiAgICAgIHZhciBwcmVmaXhMZW4gPSBtYXBwZWQubGVuZ3RoIC0gKGlzTGFzdENoYXJhY3RlciA/IDExIDogMTApO1xuICAgICAgdmFyIHByZXNzZWRQcmVmaXggPSBwcmVzc2VkLnNsaWNlKDAsIHByZWZpeExlbik7XG4gICAgICB2YXIgbWFwcGVkUHJlZml4ID0gbWFwcGVkLnNsaWNlKDAsIHByZWZpeExlbik7XG4gICAgICByZXR1cm4gcHJlc3NlZFByZWZpeCA9PSBtYXBwZWRQcmVmaXggJiYgcHJlc3NlZC5sZW5ndGggPiBwcmVmaXhMZW4gPyAnZnVsbCcgOlxuICAgICAgICAgICAgICBtYXBwZWRQcmVmaXguaW5kZXhPZihwcmVzc2VkUHJlZml4KSA9PSAwID8gJ3BhcnRpYWwnIDogZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBwcmVzc2VkID09IG1hcHBlZCA/ICdmdWxsJyA6XG4gICAgICAgICAgICAgIG1hcHBlZC5pbmRleE9mKHByZXNzZWQpID09IDAgPyAncGFydGlhbCcgOiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgLyoqIEBhcmcge3N0cmluZ30ga2V5cyAqL1xuICBmdW5jdGlvbiBsYXN0Q2hhcihrZXlzKSB7XG4gICAgdmFyIG1hdGNoID0gL14uKig8W14+XSs+KSQvLmV4ZWMoa2V5cyk7XG4gICAgdmFyIHNlbGVjdGVkQ2hhcmFjdGVyID0gbWF0Y2ggPyBtYXRjaFsxXSA6IGtleXMuc2xpY2UoLTEpO1xuICAgIGlmIChzZWxlY3RlZENoYXJhY3Rlci5sZW5ndGggPiAxKXtcbiAgICAgIHN3aXRjaChzZWxlY3RlZENoYXJhY3Rlcil7XG4gICAgICAgIGNhc2UgJzxDUj4nOlxuICAgICAgICBjYXNlICc8Uy1DUj4nOlxuICAgICAgICAgIHNlbGVjdGVkQ2hhcmFjdGVyPSdcXG4nO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICc8U3BhY2U+JzpcbiAgICAgICAgY2FzZSAnPFMtU3BhY2U+JzpcbiAgICAgICAgICBzZWxlY3RlZENoYXJhY3Rlcj0nICc7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgc2VsZWN0ZWRDaGFyYWN0ZXI9Jyc7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzZWxlY3RlZENoYXJhY3RlcjtcbiAgfVxuICAvKiogQGFyZyB7Q29kZU1pcnJvcn0gY20gICBAYXJnIHt7IChjbTogQ29kZU1pcnJvcik6IHZvaWQgfX0gZm4gICBAYXJnIHtudW1iZXJ9IHJlcGVhdCAqL1xuICBmdW5jdGlvbiByZXBlYXRGbihjbSwgZm4sIHJlcGVhdCkge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVwZWF0OyBpKyspIHtcbiAgICAgICAgZm4oY20pO1xuICAgICAgfVxuICAgIH07XG4gIH1cbiAgLyoqIEBhcmcge1Bvc30gY3VyICAgQHJldHVybiB7UG9zfSovXG4gIGZ1bmN0aW9uIGNvcHlDdXJzb3IoY3VyKSB7XG4gICAgcmV0dXJuIG5ldyBQb3MoY3VyLmxpbmUsIGN1ci5jaCk7XG4gIH1cbiAgLyoqIEBhcmcge1Bvc30gY3VyMSBAYXJnIHtQb3N9IGN1cjIgIEByZXR1cm4ge2Jvb2xlYW59ICovXG4gIGZ1bmN0aW9uIGN1cnNvckVxdWFsKGN1cjEsIGN1cjIpIHtcbiAgICByZXR1cm4gY3VyMS5jaCA9PSBjdXIyLmNoICYmIGN1cjEubGluZSA9PSBjdXIyLmxpbmU7XG4gIH1cbiAgLyoqIEBhcmcge1Bvc30gY3VyMSAgQGFyZyB7UG9zfSBjdXIyIEByZXR1cm4ge2Jvb2xlYW59Ki9cbiAgZnVuY3Rpb24gY3Vyc29ySXNCZWZvcmUoY3VyMSwgY3VyMikge1xuICAgIGlmIChjdXIxLmxpbmUgPCBjdXIyLmxpbmUpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoY3VyMS5saW5lID09IGN1cjIubGluZSAmJiBjdXIxLmNoIDwgY3VyMi5jaCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvKiogQGFyZyB7UG9zfSBjdXIxIEBhcmcge1Bvc30gY3VyMiAgQHJldHVybiB7UG9zfSovXG4gIGZ1bmN0aW9uIGN1cnNvck1pbihjdXIxLCBjdXIyKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAyKSB7XG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICBjdXIyID0gY3Vyc29yTWluLmFwcGx5KHVuZGVmaW5lZCwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSk7XG4gICAgfVxuICAgIHJldHVybiBjdXJzb3JJc0JlZm9yZShjdXIxLCBjdXIyKSA/IGN1cjEgOiBjdXIyO1xuICB9XG4gIC8qKiBAYXJnIHtQb3N9IGN1cjEgIEBhcmcge1Bvc30gY3VyMiAgQHJldHVybiB7UG9zfSAqL1xuICBmdW5jdGlvbiBjdXJzb3JNYXgoY3VyMSwgY3VyMikge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMikge1xuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgY3VyMiA9IGN1cnNvck1heC5hcHBseSh1bmRlZmluZWQsIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpO1xuICAgIH1cbiAgICByZXR1cm4gY3Vyc29ySXNCZWZvcmUoY3VyMSwgY3VyMikgPyBjdXIyIDogY3VyMTtcbiAgfVxuICAvKiogQGFyZyB7UG9zfSBjdXIxICAgQGFyZyB7UG9zfSBjdXIyICBAYXJnIHtQb3N9IGN1cjMgIEByZXR1cm4ge2Jvb2xlYW59Ki8gXG4gIGZ1bmN0aW9uIGN1cnNvcklzQmV0d2VlbihjdXIxLCBjdXIyLCBjdXIzKSB7XG4gICAgLy8gcmV0dXJucyB0cnVlIGlmIGN1cjIgaXMgYmV0d2VlbiBjdXIxIGFuZCBjdXIzLlxuICAgIHZhciBjdXIxYmVmb3JlMiA9IGN1cnNvcklzQmVmb3JlKGN1cjEsIGN1cjIpO1xuICAgIHZhciBjdXIyYmVmb3JlMyA9IGN1cnNvcklzQmVmb3JlKGN1cjIsIGN1cjMpO1xuICAgIHJldHVybiBjdXIxYmVmb3JlMiAmJiBjdXIyYmVmb3JlMztcbiAgfVxuICAvKiogQGFyZyB7Q29kZU1pcnJvcn0gY20gIEBhcmcge251bWJlcn0gbGluZU51bSAqL1xuICBmdW5jdGlvbiBsaW5lTGVuZ3RoKGNtLCBsaW5lTnVtKSB7XG4gICAgcmV0dXJuIGNtLmdldExpbmUobGluZU51bSkubGVuZ3RoO1xuICB9XG4gIC8qKiBAYXJnIHtzdHJpbmd9IHMgKi9cbiAgZnVuY3Rpb24gdHJpbShzKSB7XG4gICAgaWYgKHMudHJpbSkge1xuICAgICAgcmV0dXJuIHMudHJpbSgpO1xuICAgIH1cbiAgICByZXR1cm4gcy5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLCAnJyk7XG4gIH1cbiAgLyoqIEBhcmcge3N0cmluZ30gcyAqL1xuICBmdW5jdGlvbiBlc2NhcGVSZWdleChzKSB7XG4gICAgcmV0dXJuIHMucmVwbGFjZSgvKFsuPyorJFxcW1xcXVxcL1xcXFwoKXt9fFxcLV0pL2csICdcXFxcJDEnKTtcbiAgfVxuICAvKiogQGFyZyB7Q29kZU1pcnJvcn0gY20gIEBhcmcge251bWJlcn0gbGluZU51bSAgQGFyZyB7bnVtYmVyfSBjb2x1bW4gKi9cbiAgZnVuY3Rpb24gZXh0ZW5kTGluZVRvQ29sdW1uKGNtLCBsaW5lTnVtLCBjb2x1bW4pIHtcbiAgICB2YXIgZW5kQ2ggPSBsaW5lTGVuZ3RoKGNtLCBsaW5lTnVtKTtcbiAgICB2YXIgc3BhY2VzID0gbmV3IEFycmF5KGNvbHVtbi1lbmRDaCsxKS5qb2luKCcgJyk7XG4gICAgY20uc2V0Q3Vyc29yKG5ldyBQb3MobGluZU51bSwgZW5kQ2gpKTtcbiAgICBjbS5yZXBsYWNlUmFuZ2Uoc3BhY2VzLCBjbS5nZXRDdXJzb3IoKSk7XG4gIH1cbiAgLy8gVGhpcyBmdW5jdGlvbnMgc2VsZWN0cyBhIHJlY3Rhbmd1bGFyIGJsb2NrXG4gIC8vIG9mIHRleHQgd2l0aCBzZWxlY3Rpb25FbmQgYXMgYW55IG9mIGl0cyBjb3JuZXJcbiAgLy8gSGVpZ2h0IG9mIGJsb2NrOlxuICAvLyBEaWZmZXJlbmNlIGluIHNlbGVjdGlvbkVuZC5saW5lIGFuZCBmaXJzdC9sYXN0IHNlbGVjdGlvbi5saW5lXG4gIC8vIFdpZHRoIG9mIHRoZSBibG9jazpcbiAgLy8gRGlzdGFuY2UgYmV0d2VlbiBzZWxlY3Rpb25FbmQuY2ggYW5kIGFueShmaXJzdCBjb25zaWRlcmVkIGhlcmUpIHNlbGVjdGlvbi5jaFxuICAvKiogQGFyZyB7Q29kZU1pcnJvcn0gY20gIEBhcmcge1Bvc30gc2VsZWN0aW9uRW5kICovXG4gIGZ1bmN0aW9uIHNlbGVjdEJsb2NrKGNtLCBzZWxlY3Rpb25FbmQpIHtcbiAgICB2YXIgc2VsZWN0aW9ucyA9IFtdLCByYW5nZXMgPSBjbS5saXN0U2VsZWN0aW9ucygpO1xuICAgIHZhciBoZWFkID0gY29weUN1cnNvcihjbS5jbGlwUG9zKHNlbGVjdGlvbkVuZCkpO1xuICAgIHZhciBpc0NsaXBwZWQgPSAhY3Vyc29yRXF1YWwoc2VsZWN0aW9uRW5kLCBoZWFkKTtcbiAgICB2YXIgY3VySGVhZCA9IGNtLmdldEN1cnNvcignaGVhZCcpO1xuICAgIHZhciBwcmltSW5kZXggPSBnZXRJbmRleChyYW5nZXMsIGN1ckhlYWQpO1xuICAgIHZhciB3YXNDbGlwcGVkID0gY3Vyc29yRXF1YWwocmFuZ2VzW3ByaW1JbmRleF0uaGVhZCwgcmFuZ2VzW3ByaW1JbmRleF0uYW5jaG9yKTtcbiAgICB2YXIgbWF4ID0gcmFuZ2VzLmxlbmd0aCAtIDE7XG4gICAgdmFyIGluZGV4ID0gbWF4IC0gcHJpbUluZGV4ID4gcHJpbUluZGV4ID8gbWF4IDogMDtcbiAgICB2YXIgYmFzZSA9IHJhbmdlc1tpbmRleF0uYW5jaG9yO1xuXG4gICAgdmFyIGZpcnN0TGluZSA9IE1hdGgubWluKGJhc2UubGluZSwgaGVhZC5saW5lKTtcbiAgICB2YXIgbGFzdExpbmUgPSBNYXRoLm1heChiYXNlLmxpbmUsIGhlYWQubGluZSk7XG4gICAgdmFyIGJhc2VDaCA9IGJhc2UuY2gsIGhlYWRDaCA9IGhlYWQuY2g7XG5cbiAgICB2YXIgZGlyID0gcmFuZ2VzW2luZGV4XS5oZWFkLmNoIC0gYmFzZUNoO1xuICAgIHZhciBuZXdEaXIgPSBoZWFkQ2ggLSBiYXNlQ2g7XG4gICAgaWYgKGRpciA+IDAgJiYgbmV3RGlyIDw9IDApIHtcbiAgICAgIGJhc2VDaCsrO1xuICAgICAgaWYgKCFpc0NsaXBwZWQpIHsgaGVhZENoLS07IH1cbiAgICB9IGVsc2UgaWYgKGRpciA8IDAgJiYgbmV3RGlyID49IDApIHtcbiAgICAgIGJhc2VDaC0tO1xuICAgICAgaWYgKCF3YXNDbGlwcGVkKSB7IGhlYWRDaCsrOyB9XG4gICAgfSBlbHNlIGlmIChkaXIgPCAwICYmIG5ld0RpciA9PSAtMSkge1xuICAgICAgYmFzZUNoLS07XG4gICAgICBoZWFkQ2grKztcbiAgICB9XG4gICAgZm9yICh2YXIgbGluZSA9IGZpcnN0TGluZTsgbGluZSA8PSBsYXN0TGluZTsgbGluZSsrKSB7XG4gICAgICB2YXIgcmFuZ2UgPSB7YW5jaG9yOiBuZXcgUG9zKGxpbmUsIGJhc2VDaCksIGhlYWQ6IG5ldyBQb3MobGluZSwgaGVhZENoKX07XG4gICAgICBzZWxlY3Rpb25zLnB1c2gocmFuZ2UpO1xuICAgIH1cbiAgICBjbS5zZXRTZWxlY3Rpb25zKHNlbGVjdGlvbnMpO1xuICAgIHNlbGVjdGlvbkVuZC5jaCA9IGhlYWRDaDtcbiAgICBiYXNlLmNoID0gYmFzZUNoO1xuICAgIHJldHVybiBiYXNlO1xuICB9XG4gIC8qKiBAYXJnIHtDb2RlTWlycm9yfSBjbSAgQGFyZyB7YW55fSBoZWFkICBAYXJnIHtudW1iZXJ9IGhlaWdodCAqL1xuICBmdW5jdGlvbiBzZWxlY3RGb3JJbnNlcnQoY20sIGhlYWQsIGhlaWdodCkge1xuICAgIHZhciBzZWwgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhlaWdodDsgaSsrKSB7XG4gICAgICB2YXIgbGluZUhlYWQgPSBvZmZzZXRDdXJzb3IoaGVhZCwgaSwgMCk7XG4gICAgICBzZWwucHVzaCh7YW5jaG9yOiBsaW5lSGVhZCwgaGVhZDogbGluZUhlYWR9KTtcbiAgICB9XG4gICAgY20uc2V0U2VsZWN0aW9ucyhzZWwsIDApO1xuICB9XG4gIC8vIGdldEluZGV4IHJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBjdXJzb3IgaW4gdGhlIHNlbGVjdGlvbnMuXG4gIC8qKiBAYXJnIHt2aW1TdGF0ZVtcInNlbFwiXVtdfSByYW5nZXMgIEBhcmcge1Bvc30gY3Vyc29yICBAYXJnIHtzdHJpbmcgfCB1bmRlZmluZWR9IFtlbmRdICovXG4gIGZ1bmN0aW9uIGdldEluZGV4KHJhbmdlcywgY3Vyc29yLCBlbmQpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJhbmdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGF0QW5jaG9yID0gY3Vyc29yRXF1YWwocmFuZ2VzW2ldLmFuY2hvciwgY3Vyc29yKTtcbiAgICAgIHZhciBhdEhlYWQgPSBjdXJzb3JFcXVhbChyYW5nZXNbaV0uaGVhZCwgY3Vyc29yKTtcbiAgICAgIGlmIChhdEFuY2hvciB8fCBhdEhlYWQpIHtcbiAgICAgICAgcmV0dXJuIGk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAtMTtcbiAgfVxuICAvKiogQGFyZyB7Q29kZU1pcnJvcn0gY20gIEBhcmcge3ZpbVN0YXRlfSB2aW0gIEByZXR1cm4ge1tQb3MsUG9zXX0qL1xuICBmdW5jdGlvbiBnZXRTZWxlY3RlZEFyZWFSYW5nZShjbSwgdmltKSB7XG4gICAgdmFyIHNlbGVjdGlvbnMgPSBjbS5saXN0U2VsZWN0aW9ucygpO1xuICAgIHZhciBzdGFydCA9ICBzZWxlY3Rpb25zWzBdO1xuICAgIHZhciBlbmQgPSBzZWxlY3Rpb25zW3NlbGVjdGlvbnMubGVuZ3RoLTFdO1xuICAgIHZhciBzZWxlY3Rpb25TdGFydCA9IGN1cnNvcklzQmVmb3JlKHN0YXJ0LmFuY2hvciwgc3RhcnQuaGVhZCkgPyBzdGFydC5hbmNob3IgOiBzdGFydC5oZWFkO1xuICAgIHZhciBzZWxlY3Rpb25FbmQgPSBjdXJzb3JJc0JlZm9yZShlbmQuYW5jaG9yLCBlbmQuaGVhZCkgPyBlbmQuaGVhZCA6IGVuZC5hbmNob3I7XG4gICAgcmV0dXJuIFtzZWxlY3Rpb25TdGFydCwgc2VsZWN0aW9uRW5kXTtcbiAgfVxuICAvLyBVcGRhdGVzIHRoZSBwcmV2aW91cyBzZWxlY3Rpb24gd2l0aCB0aGUgY3VycmVudCBzZWxlY3Rpb24ncyB2YWx1ZXMuIFRoaXNcbiAgLy8gc2hvdWxkIG9ubHkgYmUgY2FsbGVkIGluIHZpc3VhbCBtb2RlLlxuICAvKiogQGFyZyB7Q29kZU1pcnJvcn0gY20gQGFyZyB7dmltU3RhdGV9IHZpbSAqL1xuICBmdW5jdGlvbiB1cGRhdGVMYXN0U2VsZWN0aW9uKGNtLCB2aW0pIHtcbiAgICB2YXIgYW5jaG9yID0gdmltLnNlbC5hbmNob3I7XG4gICAgdmFyIGhlYWQgPSB2aW0uc2VsLmhlYWQ7XG4gICAgLy8gVG8gYWNjb21tb2RhdGUgdGhlIGVmZmVjdCBvZiBsYXN0UGFzdGVkVGV4dCBpbiB0aGUgbGFzdCBzZWxlY3Rpb25cbiAgICBpZiAodmltLmxhc3RQYXN0ZWRUZXh0KSB7XG4gICAgICBoZWFkID0gY20ucG9zRnJvbUluZGV4KGNtLmluZGV4RnJvbVBvcyhhbmNob3IpICsgdmltLmxhc3RQYXN0ZWRUZXh0Lmxlbmd0aCk7XG4gICAgICB2aW0ubGFzdFBhc3RlZFRleHQgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHZpbS5sYXN0U2VsZWN0aW9uID0geydhbmNob3JNYXJrJzogY20uc2V0Qm9va21hcmsoYW5jaG9yKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgJ2hlYWRNYXJrJzogY20uc2V0Qm9va21hcmsoaGVhZCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICdhbmNob3InOiBjb3B5Q3Vyc29yKGFuY2hvciksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICdoZWFkJzogY29weUN1cnNvcihoZWFkKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgJ3Zpc3VhbE1vZGUnOiB2aW0udmlzdWFsTW9kZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgJ3Zpc3VhbExpbmUnOiB2aW0udmlzdWFsTGluZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgJ3Zpc3VhbEJsb2NrJzogdmltLnZpc3VhbEJsb2NrfTtcbiAgfVxuICAvKiogQGFyZyB7Q29kZU1pcnJvclZ9IGNtIEBhcmcge1Bvc30gc3RhcnQgQGFyZyB7UG9zfSBlbmQgQGFyZyB7Qm9vbGVhbn0gW21vdmVdIEByZXR1cm5zIHtbUG9zLCBQb3NdfSAqL1xuICBmdW5jdGlvbiBleHBhbmRTZWxlY3Rpb24oY20sIHN0YXJ0LCBlbmQsIG1vdmUpIHtcbiAgICB2YXIgc2VsID0gY20uc3RhdGUudmltLnNlbDtcbiAgICB2YXIgaGVhZCA9IG1vdmUgPyBzdGFydDogc2VsLmhlYWQ7XG4gICAgdmFyIGFuY2hvciA9IG1vdmUgPyBzdGFydDogc2VsLmFuY2hvcjtcbiAgICB2YXIgdG1wO1xuICAgIGlmIChjdXJzb3JJc0JlZm9yZShlbmQsIHN0YXJ0KSkge1xuICAgICAgdG1wID0gZW5kO1xuICAgICAgZW5kID0gc3RhcnQ7XG4gICAgICBzdGFydCA9IHRtcDtcbiAgICB9XG4gICAgaWYgKGN1cnNvcklzQmVmb3JlKGhlYWQsIGFuY2hvcikpIHtcbiAgICAgIGhlYWQgPSBjdXJzb3JNaW4oc3RhcnQsIGhlYWQpO1xuICAgICAgYW5jaG9yID0gY3Vyc29yTWF4KGFuY2hvciwgZW5kKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYW5jaG9yID0gY3Vyc29yTWluKHN0YXJ0LCBhbmNob3IpO1xuICAgICAgaGVhZCA9IGN1cnNvck1heChoZWFkLCBlbmQpO1xuICAgICAgaGVhZCA9IG9mZnNldEN1cnNvcihoZWFkLCAwLCAtMSk7XG4gICAgICBpZiAoaGVhZC5jaCA9PSAtMSAmJiBoZWFkLmxpbmUgIT0gY20uZmlyc3RMaW5lKCkpIHtcbiAgICAgICAgaGVhZCA9IG5ldyBQb3MoaGVhZC5saW5lIC0gMSwgbGluZUxlbmd0aChjbSwgaGVhZC5saW5lIC0gMSkpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gW2FuY2hvciwgaGVhZF07XG4gIH1cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIENvZGVNaXJyb3Igc2VsZWN0aW9uIHRvIG1hdGNoIHRoZSBwcm92aWRlZCB2aW0gc2VsZWN0aW9uLlxuICAgKiBJZiBubyBhcmd1bWVudHMgYXJlIGdpdmVuLCBpdCB1c2VzIHRoZSBjdXJyZW50IHZpbSBzZWxlY3Rpb24gc3RhdGUuXG4gICAqIEBhcmcge0NvZGVNaXJyb3JWfSBjbSBcbiAgICogQGFyZyB7dmltU3RhdGVbXCJzZWxcIl19IFtzZWxdIFxuICAgKiBAYXJnIHtcImNoYXJcInxcImxpbmVcInxcImJsb2NrXCIgfCB1bmRlZmluZWR9IFttb2RlXVxuICAgKi9cbiAgZnVuY3Rpb24gdXBkYXRlQ21TZWxlY3Rpb24oY20sIHNlbCwgbW9kZSkge1xuICAgIHZhciB2aW0gPSBjbS5zdGF0ZS52aW07XG4gICAgc2VsID0gc2VsIHx8IHZpbS5zZWw7XG4gICAgaWYgKCFtb2RlKSB7XG4gICAgICBtb2RlID0gdmltLnZpc3VhbExpbmUgPyAnbGluZScgOiB2aW0udmlzdWFsQmxvY2sgPyAnYmxvY2snIDogJ2NoYXInO1xuICAgIH1cbiAgICB2YXIgY21TZWwgPSBtYWtlQ21TZWxlY3Rpb24oY20sIHNlbCwgbW9kZSk7XG4gICAgY20uc2V0U2VsZWN0aW9ucyhjbVNlbC5yYW5nZXMsIGNtU2VsLnByaW1hcnkpO1xuICB9XG4gIC8qKlxuICAgKiBAYXJnIHtDb2RlTWlycm9yfSBjbSBcbiAgICogQGFyZyB7aW1wb3J0KFwiLi90eXBlc1wiKS5DTTVSYW5nZUludGVyZmFjZX0gc2VsXG4gICAqIEBhcmcge1wiY2hhclwifFwibGluZVwifFwiYmxvY2tcIn0gbW9kZSBcbiAgICogQGFyZyB7Ym9vbGVhbnx1bmRlZmluZWR9IFtleGNsdXNpdmVdIFxuICAgKi9cbiAgZnVuY3Rpb24gbWFrZUNtU2VsZWN0aW9uKGNtLCBzZWwsIG1vZGUsIGV4Y2x1c2l2ZSkge1xuICAgIHZhciBoZWFkID0gY29weUN1cnNvcihzZWwuaGVhZCk7XG4gICAgdmFyIGFuY2hvciA9IGNvcHlDdXJzb3Ioc2VsLmFuY2hvcik7XG4gICAgaWYgKG1vZGUgPT0gJ2NoYXInKSB7XG4gICAgICB2YXIgaGVhZE9mZnNldCA9ICFleGNsdXNpdmUgJiYgIWN1cnNvcklzQmVmb3JlKHNlbC5oZWFkLCBzZWwuYW5jaG9yKSA/IDEgOiAwO1xuICAgICAgdmFyIGFuY2hvck9mZnNldCA9IGN1cnNvcklzQmVmb3JlKHNlbC5oZWFkLCBzZWwuYW5jaG9yKSA/IDEgOiAwO1xuICAgICAgaGVhZCA9IG9mZnNldEN1cnNvcihzZWwuaGVhZCwgMCwgaGVhZE9mZnNldCk7XG4gICAgICBhbmNob3IgPSBvZmZzZXRDdXJzb3Ioc2VsLmFuY2hvciwgMCwgYW5jaG9yT2Zmc2V0KTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJhbmdlczogW3thbmNob3I6IGFuY2hvciwgaGVhZDogaGVhZH1dLFxuICAgICAgICBwcmltYXJ5OiAwXG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAobW9kZSA9PSAnbGluZScpIHtcbiAgICAgIGlmICghY3Vyc29ySXNCZWZvcmUoc2VsLmhlYWQsIHNlbC5hbmNob3IpKSB7XG4gICAgICAgIGFuY2hvci5jaCA9IDA7XG5cbiAgICAgICAgdmFyIGxhc3RMaW5lID0gY20ubGFzdExpbmUoKTtcbiAgICAgICAgaWYgKGhlYWQubGluZSA+IGxhc3RMaW5lKSB7XG4gICAgICAgICAgaGVhZC5saW5lID0gbGFzdExpbmU7XG4gICAgICAgIH1cbiAgICAgICAgaGVhZC5jaCA9IGxpbmVMZW5ndGgoY20sIGhlYWQubGluZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBoZWFkLmNoID0gMDtcbiAgICAgICAgYW5jaG9yLmNoID0gbGluZUxlbmd0aChjbSwgYW5jaG9yLmxpbmUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcmFuZ2VzOiBbe2FuY2hvcjogYW5jaG9yLCBoZWFkOiBoZWFkfV0sXG4gICAgICAgIHByaW1hcnk6IDBcbiAgICAgIH07XG4gICAgfSBlbHNlIGlmIChtb2RlID09ICdibG9jaycpIHtcbiAgICAgIHZhciB0b3AgPSBNYXRoLm1pbihhbmNob3IubGluZSwgaGVhZC5saW5lKSxcbiAgICAgICAgICBmcm9tQ2ggPSBhbmNob3IuY2gsXG4gICAgICAgICAgYm90dG9tID0gTWF0aC5tYXgoYW5jaG9yLmxpbmUsIGhlYWQubGluZSksXG4gICAgICAgICAgdG9DaCA9IGhlYWQuY2g7XG4gICAgICBpZiAoZnJvbUNoIDwgdG9DaCkgeyB0b0NoICs9IDE7IH1cbiAgICAgIGVsc2UgeyBmcm9tQ2ggKz0gMTsgfSAgICAgIHZhciBoZWlnaHQgPSBib3R0b20gLSB0b3AgKyAxO1xuICAgICAgdmFyIHByaW1hcnkgPSBoZWFkLmxpbmUgPT0gdG9wID8gMCA6IGhlaWdodCAtIDE7XG4gICAgICB2YXIgcmFuZ2VzID0gW107XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhlaWdodDsgaSsrKSB7XG4gICAgICAgIHJhbmdlcy5wdXNoKHtcbiAgICAgICAgICBhbmNob3I6IG5ldyBQb3ModG9wICsgaSwgZnJvbUNoKSxcbiAgICAgICAgICBoZWFkOiBuZXcgUG9zKHRvcCArIGksIHRvQ2gpXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcmFuZ2VzOiByYW5nZXMsXG4gICAgICAgIHByaW1hcnk6IHByaW1hcnlcbiAgICAgIH07XG4gICAgfVxuICAgIHRocm93IFwibmV2ZXIgaGFwcGVuc1wiO1xuICB9XG4gIC8qKiBAYXJnIHtDb2RlTWlycm9yfSBjbSAqL1xuICBmdW5jdGlvbiBnZXRIZWFkKGNtKSB7XG4gICAgdmFyIGN1ciA9IGNtLmdldEN1cnNvcignaGVhZCcpO1xuICAgIGlmIChjbS5nZXRTZWxlY3Rpb24oKS5sZW5ndGggPT0gMSkge1xuICAgICAgLy8gU21hbGwgY29ybmVyIGNhc2Ugd2hlbiBvbmx5IDEgY2hhcmFjdGVyIGlzIHNlbGVjdGVkLiBUaGUgXCJyZWFsXCJcbiAgICAgIC8vIGhlYWQgaXMgdGhlIGxlZnQgb2YgaGVhZCBhbmQgYW5jaG9yLlxuICAgICAgY3VyID0gY3Vyc29yTWluKGN1ciwgY20uZ2V0Q3Vyc29yKCdhbmNob3InKSk7XG4gICAgfVxuICAgIHJldHVybiBjdXI7XG4gIH1cblxuICAvKipcbiAgICogSWYgbW92ZUhlYWQgaXMgc2V0IHRvIGZhbHNlLCB0aGUgQ29kZU1pcnJvciBzZWxlY3Rpb24gd2lsbCBub3QgYmVcbiAgICogdG91Y2hlZC4gVGhlIGNhbGxlciBhc3N1bWVzIHRoZSByZXNwb25zaWJpbGl0eSBvZiBwdXR0aW5nIHRoZSBjdXJzb3JcbiAgICogaW4gdGhlIHJpZ2h0IHBsYWNlLlxuICAgKiBAYXJnIHtDb2RlTWlycm9yVn0gY20gXG4gICAqIEBhcmcge2Jvb2xlYW59IFttb3ZlSGVhZF1cbiAgICovXG4gIGZ1bmN0aW9uIGV4aXRWaXN1YWxNb2RlKGNtLCBtb3ZlSGVhZCkge1xuICAgIHZhciB2aW0gPSBjbS5zdGF0ZS52aW07XG4gICAgaWYgKG1vdmVIZWFkICE9PSBmYWxzZSkge1xuICAgICAgY20uc2V0Q3Vyc29yKGNsaXBDdXJzb3JUb0NvbnRlbnQoY20sIHZpbS5zZWwuaGVhZCkpO1xuICAgIH1cbiAgICB1cGRhdGVMYXN0U2VsZWN0aW9uKGNtLCB2aW0pO1xuICAgIHZpbS52aXN1YWxNb2RlID0gZmFsc2U7XG4gICAgdmltLnZpc3VhbExpbmUgPSBmYWxzZTtcbiAgICB2aW0udmlzdWFsQmxvY2sgPSBmYWxzZTtcbiAgICBpZiAoIXZpbS5pbnNlcnRNb2RlKSBDTS5zaWduYWwoY20sIFwidmltLW1vZGUtY2hhbmdlXCIsIHttb2RlOiBcIm5vcm1hbFwifSk7XG4gIH1cblxuICAvKiogXG4gICAqIFJlbW92ZSBhbnkgdHJhaWxpbmcgbmV3bGluZXMgZnJvbSB0aGUgc2VsZWN0aW9uLiBGb3JcbiAgICogZXhhbXBsZSwgd2l0aCB0aGUgY2FyZXQgYXQgdGhlIHN0YXJ0IG9mIHRoZSBsYXN0IHdvcmQgb24gdGhlIGxpbmUsXG4gICAqICdkdycgc2hvdWxkIHdvcmQsIGJ1dCBub3QgdGhlIG5ld2xpbmUsIHdoaWxlICd3JyBzaG91bGQgYWR2YW5jZSB0aGVcbiAgICogY2FyZXQgdG8gdGhlIGZpcnN0IGNoYXJhY3RlciBvZiB0aGUgbmV4dCBsaW5lLlxuICAgKiBAYXJnIHtDb2RlTWlycm9yfSBjbVxuICAgKiBAYXJnIHtQb3N9IGN1clN0YXJ0XG4gICAqIEBhcmcge1Bvc30gY3VyRW5kXG4gICAqL1xuICBmdW5jdGlvbiBjbGlwVG9MaW5lKGNtLCBjdXJTdGFydCwgY3VyRW5kKSB7XG4gICAgdmFyIHNlbGVjdGlvbiA9IGNtLmdldFJhbmdlKGN1clN0YXJ0LCBjdXJFbmQpO1xuICAgIC8vIE9ubHkgY2xpcCBpZiB0aGUgc2VsZWN0aW9uIGVuZHMgd2l0aCB0cmFpbGluZyBuZXdsaW5lICsgd2hpdGVzcGFjZVxuICAgIGlmICgvXFxuXFxzKiQvLnRlc3Qoc2VsZWN0aW9uKSkge1xuICAgICAgdmFyIGxpbmVzID0gc2VsZWN0aW9uLnNwbGl0KCdcXG4nKTtcbiAgICAgIC8vIFdlIGtub3cgdGhpcyBpcyBhbGwgd2hpdGVzcGFjZS5cbiAgICAgIGxpbmVzLnBvcCgpO1xuXG4gICAgICAvLyBDYXNlczpcbiAgICAgIC8vIDEuIExhc3Qgd29yZCBpcyBhbiBlbXB0eSBsaW5lIC0gZG8gbm90IGNsaXAgdGhlIHRyYWlsaW5nICdcXG4nXG4gICAgICAvLyAyLiBMYXN0IHdvcmQgaXMgbm90IGFuIGVtcHR5IGxpbmUgLSBjbGlwIHRoZSB0cmFpbGluZyAnXFxuJ1xuICAgICAgLy8gRmluZCB0aGUgbGluZSBjb250YWluaW5nIHRoZSBsYXN0IHdvcmQsIGFuZCBjbGlwIGFsbCB3aGl0ZXNwYWNlIHVwXG4gICAgICAvLyB0byBpdC5cbiAgICAgIGZvciAodmFyIGxpbmUgPSBsaW5lcy5wb3AoKTsgbGluZXMubGVuZ3RoID4gMCAmJiBsaW5lICYmIGlzV2hpdGVTcGFjZVN0cmluZyhsaW5lKTsgbGluZSA9IGxpbmVzLnBvcCgpKSB7XG4gICAgICAgIGN1ckVuZC5saW5lLS07XG4gICAgICAgIGN1ckVuZC5jaCA9IDA7XG4gICAgICB9XG4gICAgICAvLyBJZiB0aGUgbGFzdCB3b3JkIGlzIG5vdCBhbiBlbXB0eSBsaW5lLCBjbGlwIGFuIGFkZGl0aW9uYWwgbmV3bGluZVxuICAgICAgaWYgKGxpbmUpIHtcbiAgICAgICAgY3VyRW5kLmxpbmUtLTtcbiAgICAgICAgY3VyRW5kLmNoID0gbGluZUxlbmd0aChjbSwgY3VyRW5kLmxpbmUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3VyRW5kLmNoID0gMDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBFeHBhbmQgdGhlIHNlbGVjdGlvbiB0byBsaW5lIGVuZHMuXG4gIC8qKiBAYXJnIHtDb2RlTWlycm9yfSBfY20gIEBhcmcge1Bvc30gY3VyU3RhcnQgIEBhcmcge1Bvc30gY3VyRW5kICovXG4gIGZ1bmN0aW9uIGV4cGFuZFNlbGVjdGlvblRvTGluZShfY20sIGN1clN0YXJ0LCBjdXJFbmQpIHtcbiAgICBjdXJTdGFydC5jaCA9IDA7XG4gICAgY3VyRW5kLmNoID0gMDtcbiAgICBjdXJFbmQubGluZSsrO1xuICB9XG5cbiAgLyoqIEBhcmcge3N0cmluZ30gW3RleHRdICovXG4gIGZ1bmN0aW9uIGZpbmRGaXJzdE5vbldoaXRlU3BhY2VDaGFyYWN0ZXIodGV4dCkge1xuICAgIGlmICghdGV4dCkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIHZhciBmaXJzdE5vbldTID0gdGV4dC5zZWFyY2goL1xcUy8pO1xuICAgIHJldHVybiBmaXJzdE5vbldTID09IC0xID8gdGV4dC5sZW5ndGggOiBmaXJzdE5vbldTO1xuICB9XG5cbiAgLyoqIFxuICAgKiBAYXJnIHtDb2RlTWlycm9yfSBjbSBcbiAgICogQGFyZyB7e2luY2x1c2l2ZT86IGJvb2xlYW4sIGlubmVyV29yZD86IGJvb2xlYW4sIGJpZ1dvcmQ/OiBib29sZWFuLCBub1N5bWJvbD86IGJvb2xlYW4sIG11bHRpbGluZT86IGJvb2xlYW59fSBvcHRpb25zXG4gICAqIEBhcmcge1Bvc30gW2N1cnNvcl1cbiAgICoqL1xuICBmdW5jdGlvbiBleHBhbmRXb3JkVW5kZXJDdXJzb3IoY20sIHtpbmNsdXNpdmUsIGlubmVyV29yZCwgYmlnV29yZCwgbm9TeW1ib2wsIG11bHRpbGluZX0sIGN1cnNvcikge1xuICAgIHZhciBjdXIgPSBjdXJzb3IgfHwgZ2V0SGVhZChjbSk7XG4gICAgdmFyIGxpbmUgPSBjbS5nZXRMaW5lKGN1ci5saW5lKTtcbiAgICB2YXIgZW5kTGluZSA9IGxpbmU7XG4gICAgdmFyIHN0YXJ0TGluZU51bWJlciA9IGN1ci5saW5lO1xuICAgIHZhciBlbmRMaW5lTnVtYmVyID0gc3RhcnRMaW5lTnVtYmVyO1xuICAgIHZhciBpZHggPSBjdXIuY2g7XG5cbiAgICB2YXIgd29yZE9uTmV4dExpbmU7XG4gICAgLy8gU2VlayB0byBmaXJzdCB3b3JkIG9yIG5vbi13aGl0ZXNwYWNlIGNoYXJhY3RlciwgZGVwZW5kaW5nIG9uIGlmXG4gICAgLy8gbm9TeW1ib2wgaXMgdHJ1ZS5cbiAgICB2YXIgdGVzdCA9IG5vU3ltYm9sID8gd29yZENoYXJUZXN0WzBdIDogYmlnV29yZENoYXJUZXN0IFswXTtcbiAgICBpZiAoaW5uZXJXb3JkICYmIC9cXHMvLnRlc3QobGluZS5jaGFyQXQoaWR4KSkpIHtcbiAgICAgIHRlc3QgPSBmdW5jdGlvbigvKiogQHR5cGUge3N0cmluZ30gKi8gY2gpIHsgcmV0dXJuIC9cXHMvLnRlc3QoY2gpOyB9O1xuICAgIH0gZWxzZSB7XG4gICAgICB3aGlsZSAoIXRlc3QobGluZS5jaGFyQXQoaWR4KSkpIHtcbiAgICAgICAgaWR4Kys7XG4gICAgICAgIGlmIChpZHggPj0gbGluZS5sZW5ndGgpIHtcbiAgICAgICAgICBpZiAoIW11bHRpbGluZSkgcmV0dXJuIG51bGw7XG4gICAgICAgICAgaWR4LS07XG4gICAgICAgICAgd29yZE9uTmV4dExpbmUgPSBmaW5kV29yZChjbSwgY3VyLCB0cnVlLCBiaWdXb3JkLCB0cnVlKTtcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChiaWdXb3JkKSB7XG4gICAgICAgIHRlc3QgPSBiaWdXb3JkQ2hhclRlc3RbMF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0ZXN0ID0gd29yZENoYXJUZXN0WzBdO1xuICAgICAgICBpZiAoIXRlc3QobGluZS5jaGFyQXQoaWR4KSkpIHtcbiAgICAgICAgICB0ZXN0ID0gd29yZENoYXJUZXN0WzFdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGVuZCA9IGlkeCwgc3RhcnQgPSBpZHg7XG4gICAgd2hpbGUgKHRlc3QobGluZS5jaGFyQXQoc3RhcnQpKSAmJiBzdGFydCA+PSAwKSB7IHN0YXJ0LS07IH1cbiAgICBzdGFydCsrO1xuICAgIGlmICh3b3JkT25OZXh0TGluZSkge1xuICAgICAgZW5kID0gd29yZE9uTmV4dExpbmUudG87XG4gICAgICBlbmRMaW5lTnVtYmVyID0gd29yZE9uTmV4dExpbmUubGluZTtcbiAgICAgIGVuZExpbmUgPSBjbS5nZXRMaW5lKGVuZExpbmVOdW1iZXIpO1xuICAgICAgaWYgKCFlbmRMaW5lICYmIGVuZCA9PSAwKSBlbmQrKztcbiAgICB9IGVsc2Uge1xuICAgICAgd2hpbGUgKHRlc3QobGluZS5jaGFyQXQoZW5kKSkgJiYgZW5kIDwgbGluZS5sZW5ndGgpIHsgZW5kKys7IH1cbiAgICB9XG5cbiAgICBpZiAoaW5jbHVzaXZlKSB7XG4gICAgICAvLyBJZiBwcmVzZW50LCBpbmNsdWRlIGFsbCB3aGl0ZXNwYWNlIGFmdGVyIHdvcmQuXG4gICAgICAvLyBPdGhlcndpc2UsIGluY2x1ZGUgYWxsIHdoaXRlc3BhY2UgYmVmb3JlIHdvcmQsIGV4Y2VwdCBpbmRlbnRhdGlvbi5cbiAgICAgIHZhciB3b3JkRW5kID0gZW5kO1xuICAgICAgdmFyIHN0YXJ0c1dpdGhTcGFjZSA9IGN1ci5jaCA8PSBzdGFydCAmJiAvXFxzLy50ZXN0KGxpbmUuY2hhckF0KGN1ci5jaCkpO1xuICAgICAgaWYgKCFzdGFydHNXaXRoU3BhY2UpIHtcbiAgICAgICAgd2hpbGUgKC9cXHMvLnRlc3QoZW5kTGluZS5jaGFyQXQoZW5kKSkgJiYgZW5kIDwgZW5kTGluZS5sZW5ndGgpIHsgZW5kKys7IH1cbiAgICAgIH1cbiAgICAgIGlmICh3b3JkRW5kID09IGVuZCB8fCBzdGFydHNXaXRoU3BhY2UpIHtcbiAgICAgICAgdmFyIHdvcmRTdGFydCA9IHN0YXJ0O1xuICAgICAgICB3aGlsZSAoL1xccy8udGVzdChsaW5lLmNoYXJBdChzdGFydCAtIDEpKSAmJiBzdGFydCA+IDApIHsgc3RhcnQtLTsgfVxuICAgICAgICBpZiAoIXN0YXJ0ICYmICFzdGFydHNXaXRoU3BhY2UpIHsgc3RhcnQgPSB3b3JkU3RhcnQ7IH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4geyBzdGFydDogbmV3IFBvcyhzdGFydExpbmVOdW1iZXIsIHN0YXJ0KSwgZW5kOiBuZXcgUG9zKGVuZExpbmVOdW1iZXIsIGVuZCkgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXBlbmRzIG9uIHRoZSBmb2xsb3dpbmc6XG4gICAqXG4gICAqIC0gZWRpdG9yIG1vZGUgc2hvdWxkIGJlIGh0bWxtaXhlZG1vZGUgLyB4bWxcbiAgICogLSBtb2RlL3htbC94bWwuanMgc2hvdWxkIGJlIGxvYWRlZFxuICAgKiAtIGFkZG9uL2ZvbGQveG1sLWZvbGQuanMgc2hvdWxkIGJlIGxvYWRlZFxuICAgKlxuICAgKiBJZiBhbnkgb2YgdGhlIGFib3ZlIHJlcXVpcmVtZW50cyBhcmUgbm90IHRydWUsIHRoaXMgZnVuY3Rpb24gbm9vcHMuXG4gICAqXG4gICAqIFRoaXMgaXMgX05PVF8gYSAxMDAlIGFjY3VyYXRlIGltcGxlbWVudGF0aW9uIG9mIHZpbSB0YWcgdGV4dCBvYmplY3RzLlxuICAgKiBUaGUgZm9sbG93aW5nIGNhdmVhdHMgYXBwbHkgKGJhc2VkIG9mZiBjdXJzb3J5IHRlc3RpbmcsIEknbSBzdXJlIHRoZXJlXG4gICAqIGFyZSBvdGhlciBkaXNjcmVwYW5jaWVzKTpcbiAgICpcbiAgICogLSBEb2VzIG5vdCB3b3JrIGluc2lkZSBjb21tZW50czpcbiAgICogICBgYGBcbiAgICogICA8IS0tIDxkaXY+YnJva2VuPC9kaXY+IC0tPlxuICAgKiAgIGBgYFxuICAgKiAtIERvZXMgbm90IHdvcmsgd2hlbiB0YWdzIGhhdmUgZGlmZmVyZW50IGNhc2VzOlxuICAgKiAgIGBgYFxuICAgKiAgIDxkaXY+YnJva2VuPC9ESVY+XG4gICAqICAgYGBgXG4gICAqIC0gRG9lcyBub3Qgd29yayB3aGVuIGN1cnNvciBpcyBpbnNpZGUgYSBicm9rZW4gdGFnOlxuICAgKiAgIGBgYFxuICAgKiAgIDxkaXY+PGJyb2s+PGVuPjwvZGl2PlxuICAgKiAgIGBgYFxuICAgKiBAYXJnIHtDb2RlTWlycm9yfSBjbSBcbiAgICogQGFyZyB7UG9zfSBoZWFkIFxuICAgKiBAYXJnIHtib29sZWFufSBbaW5jbHVzaXZlXVxuICAgKi9cbiAgZnVuY3Rpb24gZXhwYW5kVGFnVW5kZXJDdXJzb3IoY20sIGhlYWQsIGluY2x1c2l2ZSkge1xuICAgIHZhciBjdXIgPSBoZWFkO1xuICAgIGlmICghQ00uZmluZE1hdGNoaW5nVGFnIHx8ICFDTS5maW5kRW5jbG9zaW5nVGFnKSB7XG4gICAgICByZXR1cm4geyBzdGFydDogY3VyLCBlbmQ6IGN1ciB9O1xuICAgIH1cblxuICAgIHZhciB0YWdzID0gQ00uZmluZE1hdGNoaW5nVGFnKGNtLCBoZWFkKSB8fCBDTS5maW5kRW5jbG9zaW5nVGFnKGNtLCBoZWFkKTtcbiAgICBpZiAoIXRhZ3MgfHwgIXRhZ3Mub3BlbiB8fCAhdGFncy5jbG9zZSkge1xuICAgICAgcmV0dXJuIHsgc3RhcnQ6IGN1ciwgZW5kOiBjdXIgfTtcbiAgICB9XG5cbiAgICBpZiAoaW5jbHVzaXZlKSB7XG4gICAgICByZXR1cm4geyBzdGFydDogdGFncy5vcGVuLmZyb20sIGVuZDogdGFncy5jbG9zZS50byB9O1xuICAgIH1cbiAgICByZXR1cm4geyBzdGFydDogdGFncy5vcGVuLnRvLCBlbmQ6IHRhZ3MuY2xvc2UuZnJvbSB9O1xuICB9XG5cbiAgLyoqIEBhcmcge0NvZGVNaXJyb3J9IGNtIEBhcmcge1Bvc30gb2xkQ3VyIEBhcmcge1Bvc30gbmV3Q3VyICovXG4gIGZ1bmN0aW9uIHJlY29yZEp1bXBQb3NpdGlvbihjbSwgb2xkQ3VyLCBuZXdDdXIpIHtcbiAgICBpZiAoIWN1cnNvckVxdWFsKG9sZEN1ciwgbmV3Q3VyKSkge1xuICAgICAgdmltR2xvYmFsU3RhdGUuanVtcExpc3QuYWRkKGNtLCBvbGRDdXIsIG5ld0N1cik7XG4gICAgfVxuICB9XG5cbiAgLyoqIEBhcmcge251bWJlcn0gaW5jcmVtZW50ICBAYXJnIHt7IGZvcndhcmQ/OiBhbnk7IHNlbGVjdGVkQ2hhcmFjdGVyPzogYW55OyB9fSBhcmdzICovXG4gIGZ1bmN0aW9uIHJlY29yZExhc3RDaGFyYWN0ZXJTZWFyY2goaW5jcmVtZW50LCBhcmdzKSB7XG4gICAgICB2aW1HbG9iYWxTdGF0ZS5sYXN0Q2hhcmFjdGVyU2VhcmNoLmluY3JlbWVudCA9IGluY3JlbWVudDtcbiAgICAgIHZpbUdsb2JhbFN0YXRlLmxhc3RDaGFyYWN0ZXJTZWFyY2guZm9yd2FyZCA9IGFyZ3MuZm9yd2FyZDtcbiAgICAgIHZpbUdsb2JhbFN0YXRlLmxhc3RDaGFyYWN0ZXJTZWFyY2guc2VsZWN0ZWRDaGFyYWN0ZXIgPSBhcmdzLnNlbGVjdGVkQ2hhcmFjdGVyO1xuICB9XG5cbiAgLyoqQHR5cGV7UmVjb3JkPHN0cmluZywga2V5b2YgZmluZFN5bWJvbE1vZGVzPn0gKi9cbiAgdmFyIHN5bWJvbFRvTW9kZSA9IHtcbiAgICAgICcoJzogJ2JyYWNrZXQnLCAnKSc6ICdicmFja2V0JywgJ3snOiAnYnJhY2tldCcsICd9JzogJ2JyYWNrZXQnLFxuICAgICAgJ1snOiAnc2VjdGlvbicsICddJzogJ3NlY3Rpb24nLFxuICAgICAgJyonOiAnY29tbWVudCcsICcvJzogJ2NvbW1lbnQnLFxuICAgICAgJ20nOiAnbWV0aG9kJywgJ00nOiAnbWV0aG9kJyxcbiAgICAgICcjJzogJ3ByZXByb2Nlc3MnXG4gIH07XG5cbiAgLyoqIFxuICAgIEB0eXBlZGVmIHsge1xuICAgIGxpbmVUZXh0OiBzdHJpbmcsXG4gICAgbmV4dENoOiBzdHJpbmcsXG4gICAgbGFzdENoOiBzdHJpbmd8bnVsbCxcbiAgICBpbmRleDogbnVtYmVyLFxuICAgIHN5bWI6IHN0cmluZyxcbiAgICByZXZlcnNlU3ltYjogYW55LFxuICAgIGZvcndhcmQ/OiBib29sZWFuLFxuICAgIGRlcHRoOiBudW1iZXIsXG4gICAgY3VyTW92ZVRocm91Z2g6IGJvb2xlYW5cbiAgfSB9IGZpbmRTeW1ib2xTdGF0ZSAqL1xuICAvKiogXG4gICAqIEB0eXBlIHtSZWNvcmQ8c3RyaW5nLCB7IFxuICAgKiAgaXNDb21wbGV0ZShzdGF0ZTogZmluZFN5bWJvbFN0YXRlKTogYm9vbGVhbixcbiAgICogIGluaXQ/KHN0YXRlOiBmaW5kU3ltYm9sU3RhdGUpOiB2b2lkIFxuICAgKiB9Pn0gKi9cbiAgdmFyIGZpbmRTeW1ib2xNb2RlcyA9IHtcbiAgICBicmFja2V0OiB7XG4gICAgICBpc0NvbXBsZXRlOiBmdW5jdGlvbihzdGF0ZSkge1xuICAgICAgICBpZiAoc3RhdGUubmV4dENoID09PSBzdGF0ZS5zeW1iKSB7XG4gICAgICAgICAgc3RhdGUuZGVwdGgrKztcbiAgICAgICAgICBpZiAoc3RhdGUuZGVwdGggPj0gMSlyZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmIChzdGF0ZS5uZXh0Q2ggPT09IHN0YXRlLnJldmVyc2VTeW1iKSB7XG4gICAgICAgICAgc3RhdGUuZGVwdGgtLTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSxcbiAgICBzZWN0aW9uOiB7XG4gICAgICBpbml0OiBmdW5jdGlvbihzdGF0ZSkge1xuICAgICAgICBzdGF0ZS5jdXJNb3ZlVGhyb3VnaCA9IHRydWU7XG4gICAgICAgIHN0YXRlLnN5bWIgPSAoc3RhdGUuZm9yd2FyZCA/ICddJyA6ICdbJykgPT09IHN0YXRlLnN5bWIgPyAneycgOiAnfSc7XG4gICAgICB9LFxuICAgICAgaXNDb21wbGV0ZTogZnVuY3Rpb24oc3RhdGUpIHtcbiAgICAgICAgcmV0dXJuIHN0YXRlLmluZGV4ID09PSAwICYmIHN0YXRlLm5leHRDaCA9PT0gc3RhdGUuc3ltYjtcbiAgICAgIH1cbiAgICB9LFxuICAgIGNvbW1lbnQ6IHtcbiAgICAgIGlzQ29tcGxldGU6IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgICAgIHZhciBmb3VuZCA9IHN0YXRlLmxhc3RDaCA9PT0gJyonICYmIHN0YXRlLm5leHRDaCA9PT0gJy8nO1xuICAgICAgICBzdGF0ZS5sYXN0Q2ggPSBzdGF0ZS5uZXh0Q2g7XG4gICAgICAgIHJldHVybiBmb3VuZDtcbiAgICAgIH1cbiAgICB9LFxuICAgIC8vIFRPRE86IFRoZSBvcmlnaW5hbCBWaW0gaW1wbGVtZW50YXRpb24gb25seSBvcGVyYXRlcyBvbiBsZXZlbCAxIGFuZCAyLlxuICAgIC8vIFRoZSBjdXJyZW50IGltcGxlbWVudGF0aW9uIGRvZXNuJ3QgY2hlY2sgZm9yIGNvZGUgYmxvY2sgbGV2ZWwgYW5kXG4gICAgLy8gdGhlcmVmb3JlIGl0IG9wZXJhdGVzIG9uIGFueSBsZXZlbHMuXG4gICAgbWV0aG9kOiB7XG4gICAgICBpbml0OiBmdW5jdGlvbihzdGF0ZSkge1xuICAgICAgICBzdGF0ZS5zeW1iID0gKHN0YXRlLnN5bWIgPT09ICdtJyA/ICd7JyA6ICd9Jyk7XG4gICAgICAgIHN0YXRlLnJldmVyc2VTeW1iID0gc3RhdGUuc3ltYiA9PT0gJ3snID8gJ30nIDogJ3snO1xuICAgICAgfSxcbiAgICAgIGlzQ29tcGxldGU6IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgICAgIGlmIChzdGF0ZS5uZXh0Q2ggPT09IHN0YXRlLnN5bWIpcmV0dXJuIHRydWU7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHByZXByb2Nlc3M6IHtcbiAgICAgIGluaXQ6IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgICAgIHN0YXRlLmluZGV4ID0gMDtcbiAgICAgIH0sXG4gICAgICBpc0NvbXBsZXRlOiBmdW5jdGlvbihzdGF0ZSkge1xuICAgICAgICBpZiAoc3RhdGUubmV4dENoID09PSAnIycpIHtcbiAgICAgICAgICB2YXIgdG9rZW4gPSBzdGF0ZS5saW5lVGV4dC5tYXRjaCgvXiMoXFx3KykvKT8uWzFdO1xuICAgICAgICAgIGlmICh0b2tlbiA9PT0gJ2VuZGlmJykge1xuICAgICAgICAgICAgaWYgKHN0YXRlLmZvcndhcmQgJiYgc3RhdGUuZGVwdGggPT09IDApIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdGF0ZS5kZXB0aCsrO1xuICAgICAgICAgIH0gZWxzZSBpZiAodG9rZW4gPT09ICdpZicpIHtcbiAgICAgICAgICAgIGlmICghc3RhdGUuZm9yd2FyZCAmJiBzdGF0ZS5kZXB0aCA9PT0gMCkge1xuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0YXRlLmRlcHRoLS07XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0b2tlbiA9PT0gJ2Vsc2UnICYmIHN0YXRlLmRlcHRoID09PSAwKXJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9ICAgICAgXG4gIH07XG4gIC8qKiBAYXJnIHtDb2RlTWlycm9yVn0gY20gIEBhcmcge251bWJlcn0gcmVwZWF0ICBAYXJnIHtib29sZWFufHVuZGVmaW5lZH0gZm9yd2FyZCAgQGFyZyB7c3RyaW5nfSBzeW1iICovXG4gIGZ1bmN0aW9uIGZpbmRTeW1ib2woY20sIHJlcGVhdCwgZm9yd2FyZCwgc3ltYikge1xuICAgIHZhciBjdXIgPSBjb3B5Q3Vyc29yKGNtLmdldEN1cnNvcigpKTtcbiAgICB2YXIgaW5jcmVtZW50ID0gZm9yd2FyZCA/IDEgOiAtMTtcbiAgICB2YXIgZW5kTGluZSA9IGZvcndhcmQgPyBjbS5saW5lQ291bnQoKSA6IC0xO1xuICAgIHZhciBjdXJDaCA9IGN1ci5jaDtcbiAgICB2YXIgbGluZSA9IGN1ci5saW5lO1xuICAgIHZhciBsaW5lVGV4dCA9IGNtLmdldExpbmUobGluZSk7XG4gICAgdmFyIHN0YXRlID0ge1xuICAgICAgbGluZVRleHQ6IGxpbmVUZXh0LFxuICAgICAgbmV4dENoOiBsaW5lVGV4dC5jaGFyQXQoY3VyQ2gpLFxuICAgICAgbGFzdENoOiBudWxsLFxuICAgICAgaW5kZXg6IGN1ckNoLFxuICAgICAgc3ltYjogc3ltYixcbiAgICAgIHJldmVyc2VTeW1iOiAoZm9yd2FyZCA/ICB7ICcpJzogJygnLCAnfSc6ICd7JyB9IDogeyAnKCc6ICcpJywgJ3snOiAnfScgfSlbc3ltYl0sXG4gICAgICBmb3J3YXJkOiBmb3J3YXJkLFxuICAgICAgZGVwdGg6IDAsXG4gICAgICBjdXJNb3ZlVGhyb3VnaDogZmFsc2VcbiAgICB9O1xuICAgIHZhciBtb2RlID0gc3ltYm9sVG9Nb2RlW3N5bWJdO1xuICAgIGlmICghbW9kZSlyZXR1cm4gY3VyO1xuICAgIHZhciBpbml0ID0gZmluZFN5bWJvbE1vZGVzW21vZGVdLmluaXQ7XG4gICAgdmFyIGlzQ29tcGxldGUgPSBmaW5kU3ltYm9sTW9kZXNbbW9kZV0uaXNDb21wbGV0ZTtcbiAgICBpZiAoaW5pdCkgeyBpbml0KHN0YXRlKTsgfVxuICAgIHdoaWxlIChsaW5lICE9PSBlbmRMaW5lICYmIHJlcGVhdCkge1xuICAgICAgc3RhdGUuaW5kZXggKz0gaW5jcmVtZW50O1xuICAgICAgc3RhdGUubmV4dENoID0gc3RhdGUubGluZVRleHQuY2hhckF0KHN0YXRlLmluZGV4KTtcbiAgICAgIGlmICghc3RhdGUubmV4dENoKSB7XG4gICAgICAgIGxpbmUgKz0gaW5jcmVtZW50O1xuICAgICAgICBzdGF0ZS5saW5lVGV4dCA9IGNtLmdldExpbmUobGluZSkgfHwgJyc7XG4gICAgICAgIGlmIChpbmNyZW1lbnQgPiAwKSB7XG4gICAgICAgICAgc3RhdGUuaW5kZXggPSAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBsaW5lTGVuID0gc3RhdGUubGluZVRleHQubGVuZ3RoO1xuICAgICAgICAgIHN0YXRlLmluZGV4ID0gKGxpbmVMZW4gPiAwKSA/IChsaW5lTGVuLTEpIDogMDtcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5uZXh0Q2ggPSBzdGF0ZS5saW5lVGV4dC5jaGFyQXQoc3RhdGUuaW5kZXgpO1xuICAgICAgfVxuICAgICAgaWYgKGlzQ29tcGxldGUoc3RhdGUpKSB7XG4gICAgICAgIGN1ci5saW5lID0gbGluZTtcbiAgICAgICAgY3VyLmNoID0gc3RhdGUuaW5kZXg7XG4gICAgICAgIHJlcGVhdC0tO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoc3RhdGUubmV4dENoIHx8IHN0YXRlLmN1ck1vdmVUaHJvdWdoKSB7XG4gICAgICByZXR1cm4gbmV3IFBvcyhsaW5lLCBzdGF0ZS5pbmRleCk7XG4gICAgfVxuICAgIHJldHVybiBjdXI7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgYm91bmRhcmllcyBvZiB0aGUgbmV4dCB3b3JkLiBJZiB0aGUgY3Vyc29yIGluIHRoZSBtaWRkbGUgb2ZcbiAgICogdGhlIHdvcmQsIHRoZW4gcmV0dXJucyB0aGUgYm91bmRhcmllcyBvZiB0aGUgY3VycmVudCB3b3JkLCBzdGFydGluZyBhdFxuICAgKiB0aGUgY3Vyc29yLiBJZiB0aGUgY3Vyc29yIGlzIGF0IHRoZSBzdGFydC9lbmQgb2YgYSB3b3JkLCBhbmQgd2UgYXJlIGdvaW5nXG4gICAqIGZvcndhcmQvYmFja3dhcmQsIHJlc3BlY3RpdmVseSwgZmluZCB0aGUgYm91bmRhcmllcyBvZiB0aGUgbmV4dCB3b3JkLlxuICAgKlxuICAgKiBAYXJnIHtDb2RlTWlycm9yfSBjbSBDb2RlTWlycm9yIG9iamVjdC5cbiAgICogQGFyZyB7UG9zfSBjdXIgVGhlIGN1cnNvciBwb3NpdGlvbi5cbiAgICogQGFyZyB7Ym9vbGVhbn0gZm9yd2FyZCBUcnVlIHRvIHNlYXJjaCBmb3J3YXJkLiBGYWxzZSB0byBzZWFyY2hcbiAgICogICAgIGJhY2t3YXJkLlxuICAgKiBAYXJnIHtib29sZWFufHVuZGVmaW5lZH0gYmlnV29yZCBUcnVlIGlmIHB1bmN0dWF0aW9uIGNvdW50IGFzIHBhcnQgb2YgdGhlIHdvcmQuXG4gICAqICAgICBGYWxzZSBpZiBvbmx5IFthLXpBLVowLTldIGNoYXJhY3RlcnMgY291bnQgYXMgcGFydCBvZiB0aGUgd29yZC5cbiAgICogQGFyZyB7Ym9vbGVhbnx1bmRlZmluZWR9IGVtcHR5TGluZUlzV29yZCBUcnVlIGlmIGVtcHR5IGxpbmVzIHNob3VsZCBiZSB0cmVhdGVkXG4gICAqICAgICBhcyB3b3Jkcy5cbiAgICogQHJldHVybiB7e2Zyb206bnVtYmVyLCB0bzpudW1iZXIsIGxpbmU6IG51bWJlcn18bnVsbH0gVGhlIGJvdW5kYXJpZXMgb2ZcbiAgICogICAgIHRoZSB3b3JkLCBvciBudWxsIGlmIHRoZXJlIGFyZSBubyBtb3JlIHdvcmRzLlxuICAgKi9cbiAgZnVuY3Rpb24gZmluZFdvcmQoY20sIGN1ciwgZm9yd2FyZCwgYmlnV29yZCwgZW1wdHlMaW5lSXNXb3JkKSB7XG4gICAgdmFyIGxpbmVOdW0gPSBjdXIubGluZTtcbiAgICB2YXIgcG9zID0gY3VyLmNoO1xuICAgIHZhciBsaW5lID0gY20uZ2V0TGluZShsaW5lTnVtKTtcbiAgICB2YXIgZGlyID0gZm9yd2FyZCA/IDEgOiAtMTtcbiAgICB2YXIgY2hhclRlc3RzID0gYmlnV29yZCA/IGJpZ1dvcmRDaGFyVGVzdDogd29yZENoYXJUZXN0O1xuXG4gICAgaWYgKGVtcHR5TGluZUlzV29yZCAmJiBsaW5lID09ICcnKSB7XG4gICAgICBsaW5lTnVtICs9IGRpcjtcbiAgICAgIGxpbmUgPSBjbS5nZXRMaW5lKGxpbmVOdW0pO1xuICAgICAgaWYgKCFpc0xpbmUoY20sIGxpbmVOdW0pKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgcG9zID0gKGZvcndhcmQpID8gMCA6IGxpbmUubGVuZ3RoO1xuICAgIH1cblxuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBpZiAoZW1wdHlMaW5lSXNXb3JkICYmIGxpbmUgPT0gJycpIHtcbiAgICAgICAgcmV0dXJuIHsgZnJvbTogMCwgdG86IDAsIGxpbmU6IGxpbmVOdW0gfTtcbiAgICAgIH1cbiAgICAgIHZhciBzdG9wID0gKGRpciA+IDApID8gbGluZS5sZW5ndGggOiAtMTtcbiAgICAgIHZhciB3b3JkU3RhcnQgPSBzdG9wLCB3b3JkRW5kID0gc3RvcDtcbiAgICAgIC8vIEZpbmQgYm91bmRzIG9mIG5leHQgd29yZC5cbiAgICAgIHdoaWxlIChwb3MgIT0gc3RvcCkge1xuICAgICAgICB2YXIgZm91bmRXb3JkID0gZmFsc2U7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hhclRlc3RzLmxlbmd0aCAmJiAhZm91bmRXb3JkOyArK2kpIHtcbiAgICAgICAgICBpZiAoY2hhclRlc3RzW2ldKGxpbmUuY2hhckF0KHBvcykpKSB7XG4gICAgICAgICAgICB3b3JkU3RhcnQgPSBwb3M7XG4gICAgICAgICAgICAvLyBBZHZhbmNlIHRvIGVuZCBvZiB3b3JkLlxuICAgICAgICAgICAgd2hpbGUgKHBvcyAhPSBzdG9wICYmIGNoYXJUZXN0c1tpXShsaW5lLmNoYXJBdChwb3MpKSkge1xuICAgICAgICAgICAgICBwb3MgKz0gZGlyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd29yZEVuZCA9IHBvcztcbiAgICAgICAgICAgIGZvdW5kV29yZCA9IHdvcmRTdGFydCAhPSB3b3JkRW5kO1xuICAgICAgICAgICAgaWYgKHdvcmRTdGFydCA9PSBjdXIuY2ggJiYgbGluZU51bSA9PSBjdXIubGluZSAmJlxuICAgICAgICAgICAgICAgIHdvcmRFbmQgPT0gd29yZFN0YXJ0ICsgZGlyKSB7XG4gICAgICAgICAgICAgIC8vIFdlIHN0YXJ0ZWQgYXQgdGhlIGVuZCBvZiBhIHdvcmQuIEZpbmQgdGhlIG5leHQgb25lLlxuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZnJvbTogTWF0aC5taW4od29yZFN0YXJ0LCB3b3JkRW5kICsgMSksXG4gICAgICAgICAgICAgICAgdG86IE1hdGgubWF4KHdvcmRTdGFydCwgd29yZEVuZCksXG4gICAgICAgICAgICAgICAgbGluZTogbGluZU51bSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIWZvdW5kV29yZCkge1xuICAgICAgICAgIHBvcyArPSBkaXI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIEFkdmFuY2UgdG8gbmV4dC9wcmV2IGxpbmUuXG4gICAgICBsaW5lTnVtICs9IGRpcjtcbiAgICAgIGlmICghaXNMaW5lKGNtLCBsaW5lTnVtKSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGxpbmUgPSBjbS5nZXRMaW5lKGxpbmVOdW0pO1xuICAgICAgcG9zID0gKGRpciA+IDApID8gMCA6IGxpbmUubGVuZ3RoO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAYXJnIHtDb2RlTWlycm9yfSBjbSBDb2RlTWlycm9yIG9iamVjdC5cbiAgICogQGFyZyB7UG9zfSBjdXIgVGhlIHBvc2l0aW9uIHRvIHN0YXJ0IGZyb20uXG4gICAqIEBhcmcge251bWJlcn0gcmVwZWF0IE51bWJlciBvZiB3b3JkcyB0byBtb3ZlIHBhc3QuXG4gICAqIEBhcmcge2Jvb2xlYW59IGZvcndhcmQgVHJ1ZSB0byBzZWFyY2ggZm9yd2FyZC4gRmFsc2UgdG8gc2VhcmNoXG4gICAqICAgICBiYWNrd2FyZC5cbiAgICogQGFyZyB7Ym9vbGVhbn0gd29yZEVuZCBUcnVlIHRvIG1vdmUgdG8gZW5kIG9mIHdvcmQuIEZhbHNlIHRvIG1vdmUgdG9cbiAgICogICAgIGJlZ2lubmluZyBvZiB3b3JkLlxuICAgKiBAYXJnIHtib29sZWFufSBiaWdXb3JkIFRydWUgaWYgcHVuY3R1YXRpb24gY291bnQgYXMgcGFydCBvZiB0aGUgd29yZC5cbiAgICogICAgIEZhbHNlIGlmIG9ubHkgYWxwaGFiZXQgY2hhcmFjdGVycyBjb3VudCBhcyBwYXJ0IG9mIHRoZSB3b3JkLlxuICAgKiBAcmV0dXJuIHtQb3N8dW5kZWZpbmVkfSBUaGUgcG9zaXRpb24gdGhlIGN1cnNvciBzaG91bGQgbW92ZSB0by5cbiAgICovXG4gIGZ1bmN0aW9uIG1vdmVUb1dvcmQoY20sIGN1ciwgcmVwZWF0LCBmb3J3YXJkLCB3b3JkRW5kLCBiaWdXb3JkKSB7XG4gICAgdmFyIGN1clN0YXJ0ID0gY29weUN1cnNvcihjdXIpO1xuICAgIHZhciB3b3JkcyA9IFtdO1xuICAgIGlmIChmb3J3YXJkICYmICF3b3JkRW5kIHx8ICFmb3J3YXJkICYmIHdvcmRFbmQpIHtcbiAgICAgIHJlcGVhdCsrO1xuICAgIH1cbiAgICAvLyBGb3IgJ2UnLCBlbXB0eSBsaW5lcyBhcmUgbm90IGNvbnNpZGVyZWQgd29yZHMsIGdvIGZpZ3VyZS5cbiAgICB2YXIgZW1wdHlMaW5lSXNXb3JkID0gIShmb3J3YXJkICYmIHdvcmRFbmQpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVwZWF0OyBpKyspIHtcbiAgICAgIHZhciB3b3JkID0gZmluZFdvcmQoY20sIGN1ciwgZm9yd2FyZCwgYmlnV29yZCwgZW1wdHlMaW5lSXNXb3JkKTtcbiAgICAgIGlmICghd29yZCkge1xuICAgICAgICB2YXIgZW9kQ2ggPSBsaW5lTGVuZ3RoKGNtLCBjbS5sYXN0TGluZSgpKTtcbiAgICAgICAgd29yZHMucHVzaChmb3J3YXJkXG4gICAgICAgICAgICA/IHtsaW5lOiBjbS5sYXN0TGluZSgpLCBmcm9tOiBlb2RDaCwgdG86IGVvZENofVxuICAgICAgICAgICAgOiB7bGluZTogMCwgZnJvbTogMCwgdG86IDB9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICB3b3Jkcy5wdXNoKHdvcmQpO1xuICAgICAgY3VyID0gbmV3IFBvcyh3b3JkLmxpbmUsIGZvcndhcmQgPyAod29yZC50byAtIDEpIDogd29yZC5mcm9tKTtcbiAgICB9XG4gICAgdmFyIHNob3J0Q2lyY3VpdCA9IHdvcmRzLmxlbmd0aCAhPSByZXBlYXQ7XG4gICAgdmFyIGZpcnN0V29yZCA9IHdvcmRzWzBdO1xuICAgIHZhciBsYXN0V29yZCA9IHdvcmRzLnBvcCgpO1xuICAgIGlmIChmb3J3YXJkICYmICF3b3JkRW5kKSB7XG4gICAgICAvLyB3XG4gICAgICBpZiAoIXNob3J0Q2lyY3VpdCAmJiAoZmlyc3RXb3JkLmZyb20gIT0gY3VyU3RhcnQuY2ggfHwgZmlyc3RXb3JkLmxpbmUgIT0gY3VyU3RhcnQubGluZSkpIHtcbiAgICAgICAgLy8gV2UgZGlkIG5vdCBzdGFydCBpbiB0aGUgbWlkZGxlIG9mIGEgd29yZC4gRGlzY2FyZCB0aGUgZXh0cmEgd29yZCBhdCB0aGUgZW5kLlxuICAgICAgICBsYXN0V29yZCA9IHdvcmRzLnBvcCgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGxhc3RXb3JkICYmIG5ldyBQb3MobGFzdFdvcmQubGluZSwgbGFzdFdvcmQuZnJvbSk7XG4gICAgfSBlbHNlIGlmIChmb3J3YXJkICYmIHdvcmRFbmQpIHtcbiAgICAgIHJldHVybiBsYXN0V29yZCAmJiBuZXcgUG9zKGxhc3RXb3JkLmxpbmUsIGxhc3RXb3JkLnRvIC0gMSk7XG4gICAgfSBlbHNlIGlmICghZm9yd2FyZCAmJiB3b3JkRW5kKSB7XG4gICAgICAvLyBnZVxuICAgICAgaWYgKCFzaG9ydENpcmN1aXQgJiYgKGZpcnN0V29yZC50byAhPSBjdXJTdGFydC5jaCB8fCBmaXJzdFdvcmQubGluZSAhPSBjdXJTdGFydC5saW5lKSkge1xuICAgICAgICAvLyBXZSBkaWQgbm90IHN0YXJ0IGluIHRoZSBtaWRkbGUgb2YgYSB3b3JkLiBEaXNjYXJkIHRoZSBleHRyYSB3b3JkIGF0IHRoZSBlbmQuXG4gICAgICAgIGxhc3RXb3JkID0gd29yZHMucG9wKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbGFzdFdvcmQgJiYgbmV3IFBvcyhsYXN0V29yZC5saW5lLCBsYXN0V29yZC50byk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGJcbiAgICAgIHJldHVybiBsYXN0V29yZCAmJiBuZXcgUG9zKGxhc3RXb3JkLmxpbmUsIGxhc3RXb3JkLmZyb20pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAYXJnIHtDb2RlTWlycm9yfSBjbSBcbiAgICogQGFyZyB7UG9zfSBoZWFkIFxuICAgKiBAYXJnIHtNb3Rpb25BcmdzfSBtb3Rpb25BcmdzIFxuICAgKiBAYXJnIHt2aW1TdGF0ZX0gdmltIFxuICAgKiBAYXJnIHtib29sZWFufSBrZWVwSFBvcyAqL1xuICBmdW5jdGlvbiBtb3ZlVG9Fb2woY20sIGhlYWQsIG1vdGlvbkFyZ3MsIHZpbSwga2VlcEhQb3MpIHtcbiAgICB2YXIgY3VyID0gaGVhZDtcbiAgICB2YXIgcmV0dmFsPSBuZXcgUG9zKGN1ci5saW5lICsgbW90aW9uQXJncy5yZXBlYXQgLSAxLCBJbmZpbml0eSk7XG4gICAgdmFyIGVuZD1jbS5jbGlwUG9zKHJldHZhbCk7XG4gICAgZW5kLmNoLS07XG4gICAgaWYgKCFrZWVwSFBvcykge1xuICAgICAgdmltLmxhc3RIUG9zID0gSW5maW5pdHk7XG4gICAgICB2aW0ubGFzdEhTUG9zID0gY20uY2hhckNvb3JkcyhlbmQsJ2RpdicpLmxlZnQ7XG4gICAgfVxuICAgIHJldHVybiByZXR2YWw7XG4gIH1cblxuICAvKiogXG4gICAqIEBhcmcge0NvZGVNaXJyb3J9IGNtIFxuICAgKiBAYXJnIHtudW1iZXJ9IHJlcGVhdCBcbiAgICogQGFyZyB7Ym9vbGVhbn0gW2ZvcndhcmRdXG4gICAqIEBhcmcge3N0cmluZ30gW2NoYXJhY3Rlcl1cbiAgICogQGFyZyB7UG9zfSBbaGVhZF1cbiAgICovXG4gIGZ1bmN0aW9uIG1vdmVUb0NoYXJhY3RlcihjbSwgcmVwZWF0LCBmb3J3YXJkLCBjaGFyYWN0ZXIsIGhlYWQpIHtcbiAgICBpZiAoIWNoYXJhY3RlcikgcmV0dXJuO1xuICAgIHZhciBjdXIgPSBoZWFkIHx8IGNtLmdldEN1cnNvcigpO1xuICAgIHZhciBzdGFydCA9IGN1ci5jaDtcbiAgICB2YXIgaWR4O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVwZWF0OyBpICsrKSB7XG4gICAgICB2YXIgbGluZSA9IGNtLmdldExpbmUoY3VyLmxpbmUpO1xuICAgICAgaWR4ID0gY2hhcklkeEluTGluZShzdGFydCwgbGluZSwgY2hhcmFjdGVyLCBmb3J3YXJkKTtcbiAgICAgIGlmIChpZHggPT0gLTEpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIHN0YXJ0ID0gaWR4O1xuICAgIH1cbiAgICBpZiAoaWR4ICE9IHVuZGVmaW5lZClcbiAgICAgIHJldHVybiBuZXcgUG9zKGNtLmdldEN1cnNvcigpLmxpbmUsIGlkeCk7XG4gIH1cblxuICAvKiogQGFyZyB7Q29kZU1pcnJvclZ9IGNtIEBhcmcge251bWJlcn0gcmVwZWF0ICovXG4gIGZ1bmN0aW9uIG1vdmVUb0NvbHVtbihjbSwgcmVwZWF0KSB7XG4gICAgLy8gcmVwZWF0IGlzIGFsd2F5cyA+PSAxLCBzbyByZXBlYXQgLSAxIGFsd2F5cyBjb3JyZXNwb25kc1xuICAgIC8vIHRvIHRoZSBjb2x1bW4gd2Ugd2FudCB0byBnbyB0by5cbiAgICB2YXIgbGluZSA9IGNtLmdldEN1cnNvcigpLmxpbmU7XG4gICAgcmV0dXJuIGNsaXBDdXJzb3JUb0NvbnRlbnQoY20sIG5ldyBQb3MobGluZSwgcmVwZWF0IC0gMSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBhcmcge0NvZGVNaXJyb3J9IGNtIFxuICAgKiBAYXJnIHt2aW1TdGF0ZX0gdmltIFxuICAgKiBAYXJnIHtzdHJpbmd9IG1hcmtOYW1lIFxuICAgKiBAYXJnIHtQb3N9IHBvcyAqL1xuICBmdW5jdGlvbiB1cGRhdGVNYXJrKGNtLCB2aW0sIG1hcmtOYW1lLCBwb3MpIHtcbiAgICBpZiAoIWluQXJyYXkobWFya05hbWUsIHZhbGlkTWFya3MpICYmICFsYXRpbkNoYXJSZWdleC50ZXN0KG1hcmtOYW1lKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodmltLm1hcmtzW21hcmtOYW1lXSkge1xuICAgICAgdmltLm1hcmtzW21hcmtOYW1lXS5jbGVhcigpO1xuICAgIH1cbiAgICB2aW0ubWFya3NbbWFya05hbWVdID0gY20uc2V0Qm9va21hcmsocG9zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAYXJnIHtudW1iZXJ9IHN0YXJ0IFxuICAgKiBAYXJnIHtzdHJpbmcgfCBhbnlbXX0gbGluZSBcbiAgICogQGFyZyB7YW55fSBjaGFyYWN0ZXIgXG4gICAqIEBhcmcge2Jvb2xlYW59IFtmb3J3YXJkXSBcbiAgICogQGFyZyB7Ym9vbGVhbn0gW2luY2x1ZGVDaGFyXSAqL1xuICBmdW5jdGlvbiBjaGFySWR4SW5MaW5lKHN0YXJ0LCBsaW5lLCBjaGFyYWN0ZXIsIGZvcndhcmQsIGluY2x1ZGVDaGFyKSB7XG4gICAgLy8gU2VhcmNoIGZvciBjaGFyIGluIGxpbmUuXG4gICAgLy8gbW90aW9uX29wdGlvbnM6IHtmb3J3YXJkLCBpbmNsdWRlQ2hhcn1cbiAgICAvLyBJZiBpbmNsdWRlQ2hhciA9IHRydWUsIGluY2x1ZGUgaXQgdG9vLlxuICAgIC8vIElmIGZvcndhcmQgPSB0cnVlLCBzZWFyY2ggZm9yd2FyZCwgZWxzZSBzZWFyY2ggYmFja3dhcmRzLlxuICAgIC8vIElmIGNoYXIgaXMgbm90IGZvdW5kIG9uIHRoaXMgbGluZSwgZG8gbm90aGluZ1xuICAgIHZhciBpZHg7XG4gICAgaWYgKGZvcndhcmQpIHtcbiAgICAgIGlkeCA9IGxpbmUuaW5kZXhPZihjaGFyYWN0ZXIsIHN0YXJ0ICsgMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlkeCA9IGxpbmUubGFzdEluZGV4T2YoY2hhcmFjdGVyLCBzdGFydCAtIDEpO1xuICAgIH1cbiAgICByZXR1cm4gaWR4O1xuICB9XG5cbiAgLyoqIEBhcmcge0NvZGVNaXJyb3JWfSBjbSBcbiAgICogQGFyZyB7UG9zfSBoZWFkIFxuICAgKiBAYXJnIHtudW1iZXJ9IHJlcGVhdCBcbiAgICogQGFyZyB7bnVtYmVyfSBkaXIgXG4gICAqIEBhcmcge2Jvb2xlYW59IFtpbmNsdXNpdmVdICovXG4gIGZ1bmN0aW9uIGZpbmRQYXJhZ3JhcGgoY20sIGhlYWQsIHJlcGVhdCwgZGlyLCBpbmNsdXNpdmUpIHtcbiAgICB2YXIgbGluZSA9IGhlYWQubGluZTtcbiAgICB2YXIgbWluID0gY20uZmlyc3RMaW5lKCk7XG4gICAgdmFyIG1heCA9IGNtLmxhc3RMaW5lKCk7XG4gICAgdmFyIHN0YXJ0LCBlbmQsIGkgPSBsaW5lO1xuICAgIC8qKiBAYXJnIHtudW1iZXJ9IGkgKi9cbiAgICBmdW5jdGlvbiBpc0VtcHR5KGkpIHsgcmV0dXJuICFjbS5nZXRMaW5lKGkpOyB9XG4gICAgLyoqIEBhcmcge251bWJlcn0gaSBAYXJnIHtudW1iZXJ9IGRpciBAYXJnIHtib29sZWFufSBbYW55XSAqL1xuICAgIGZ1bmN0aW9uIGlzQm91bmRhcnkoaSwgZGlyLCBhbnkpIHtcbiAgICAgIGlmIChhbnkpIHsgcmV0dXJuIGlzRW1wdHkoaSkgIT0gaXNFbXB0eShpICsgZGlyKTsgfVxuICAgICAgcmV0dXJuICFpc0VtcHR5KGkpICYmIGlzRW1wdHkoaSArIGRpcik7XG4gICAgfVxuICAgIGlmIChkaXIpIHtcbiAgICAgIHdoaWxlIChtaW4gPD0gaSAmJiBpIDw9IG1heCAmJiByZXBlYXQgPiAwKSB7XG4gICAgICAgIGlmIChpc0JvdW5kYXJ5KGksIGRpcikpIHsgcmVwZWF0LS07IH1cbiAgICAgICAgaSArPSBkaXI7XG4gICAgICB9XG4gICAgICByZXR1cm4ge3N0YXJ0OiBuZXcgUG9zKGksIDApLCBlbmQ6IGhlYWR9O1xuICAgIH1cblxuICAgIHZhciB2aW0gPSBjbS5zdGF0ZS52aW07XG4gICAgaWYgKHZpbS52aXN1YWxMaW5lICYmIGlzQm91bmRhcnkobGluZSwgMSwgdHJ1ZSkpIHtcbiAgICAgIHZhciBhbmNob3IgPSB2aW0uc2VsLmFuY2hvcjtcbiAgICAgIGlmIChpc0JvdW5kYXJ5KGFuY2hvci5saW5lLCAtMSwgdHJ1ZSkpIHtcbiAgICAgICAgaWYgKCFpbmNsdXNpdmUgfHwgYW5jaG9yLmxpbmUgIT0gbGluZSkge1xuICAgICAgICAgIGxpbmUgKz0gMTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICB2YXIgc3RhcnRTdGF0ZSA9IGlzRW1wdHkobGluZSk7XG4gICAgZm9yIChpID0gbGluZTsgaSA8PSBtYXggJiYgcmVwZWF0OyBpKyspIHtcbiAgICAgIGlmIChpc0JvdW5kYXJ5KGksIDEsIHRydWUpKSB7XG4gICAgICAgIGlmICghaW5jbHVzaXZlIHx8IGlzRW1wdHkoaSkgIT0gc3RhcnRTdGF0ZSkge1xuICAgICAgICAgIHJlcGVhdC0tO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGVuZCA9IG5ldyBQb3MoaSwgMCk7XG4gICAgLy8gc2VsZWN0IGJvdW5kYXJ5IGJlZm9yZSBwYXJhZ3JhcGggZm9yIHRoZSBsYXN0IG9uZVxuICAgIGlmIChpID4gbWF4ICYmICFzdGFydFN0YXRlKSB7IHN0YXJ0U3RhdGUgPSB0cnVlOyB9XG4gICAgZWxzZSB7IGluY2x1c2l2ZSA9IGZhbHNlOyB9XG4gICAgZm9yIChpID0gbGluZTsgaSA+IG1pbjsgaS0tKSB7XG4gICAgICBpZiAoIWluY2x1c2l2ZSB8fCBpc0VtcHR5KGkpID09IHN0YXJ0U3RhdGUgfHwgaSA9PSBsaW5lKSB7XG4gICAgICAgIGlmIChpc0JvdW5kYXJ5KGksIC0xLCB0cnVlKSkgeyBicmVhazsgfVxuICAgICAgfVxuICAgIH1cbiAgICBzdGFydCA9IG5ldyBQb3MoaSwgMCk7XG4gICAgcmV0dXJuIHsgc3RhcnQ6IHN0YXJ0LCBlbmQ6IGVuZCB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEJhc2VkIG9uIHtAbGluayBmaW5kU2VudGVuY2V9LiBUaGUgaW50ZXJuYWwgZnVuY3Rpb25zIGhhdmUgdGhlIHNhbWUgbmFtZXMsXG4gICAqIGJ1dCB0aGVpciBiZWhhdmlvdXIgaXMgZGlmZmVyZW50LiBmaW5kU2VudGVuY2UoKSBjcm9zc2VzIGxpbmUgYnJlYWtzIGFuZCBcbiAgICogaXMgdXNlZCBmb3IganVtcGluZyB0byBzZW50ZW5jZSBiZWdpbm5pbmdzIGJlZm9yZSBvciBhZnRlciB0aGUgY3VycmVudCBjdXJzb3IgcG9zaXRpb24sIFxuICAgKiB3aGVyZWFzIGdldFNlbnRlbmNlKCkgaXMgZm9yIGdldHRpbmcgdGhlIGJlZ2lubmluZyBvciBlbmQgb2YgdGhlIHNlbnRlbmNlIFxuICAgKiBhdCB0aGUgY3VycmVudCBjdXJzb3IgcG9zaXRpb24sIGVpdGhlciBpbmNsdWRpbmcgKGEpIG9yIGV4Y2x1ZGluZyAoaSkgd2hpdGVzcGFjZS5cbiAgICogQGFyZyB7Q29kZU1pcnJvcn0gY21cbiAgICogQGFyZyB7UG9zfSBjdXJcbiAgICogQGFyZyB7bnVtYmVyfSByZXBlYXRcbiAgICogQGFyZyB7MXwtMX0gZGlyXG4gICAqIEBhcmcge2Jvb2xlYW59IGluY2x1c2l2ZVxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0U2VudGVuY2UoY20sIGN1ciwgcmVwZWF0LCBkaXIsIGluY2x1c2l2ZSAvKmluY2x1ZGVzIHdoaXRlc3BhY2UqLykge1xuXG4gICAgLyoqXG4gICAgICBUYWtlcyBhbiBpbmRleCBvYmplY3RcbiAgICAgIEBhcmcge3tcbiAgICAgICAgbGluZTogc3RyaW5nfG51bGwsXG4gICAgICAgIGxuOiAgbnVtYmVyLFxuICAgICAgICBwb3M6IG51bWJlcixcbiAgICAgICAgZGlyOiAtMXwxXG4gICAgICB9fSBjdXJyXG4gICAgICBhbmQgbW9kaWZpZXMgdGhlIHBvcyBtZW1iZXIgdG8gcmVwcmVzZW50IHRoZVxuICAgICAgbmV4dCB2YWxpZCBwb3NpdGlvbiBvciBzZXRzIHRoZSBsaW5lIHRvIG51bGwgaWYgdGhlcmUgYXJlXG4gICAgICBubyBtb3JlIHZhbGlkIHBvc2l0aW9ucy5cbiAgICAgICovXG4gICAgZnVuY3Rpb24gbmV4dENoYXIoY3Vycikge1xuICAgICAgaWYgKGN1cnIubGluZSA9PT0gbnVsbCkgcmV0dXJuO1xuICAgICAgaWYgKGN1cnIucG9zICsgY3Vyci5kaXIgPCAwIHx8IGN1cnIucG9zICsgY3Vyci5kaXIgPj0gY3Vyci5saW5lLmxlbmd0aCkge1xuICAgICAgICBjdXJyLmxpbmUgPSBudWxsO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGN1cnIucG9zICs9IGN1cnIuZGlyO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtcyBvbmUgaXRlcmF0aW9uIG9mIHRyYXZlcnNhbCBpbiBmb3J3YXJkIGRpcmVjdGlvblxuICAgICAqIFJldHVybnMgYW4gaW5kZXggb2JqZWN0IG9mIHRoZSBzZW50ZW5jZSBlbmRcbiAgICAgKiBAYXJnIHtDb2RlTWlycm9yfSBjbVxuICAgICAqIEBhcmcge251bWJlcn0gbG5cbiAgICAgKiBAYXJnIHtudW1iZXJ9IHBvc1xuICAgICAqIEBhcmcgezF8LTF9IGRpclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZvcndhcmQoY20sIGxuLCBwb3MsIGRpcikge1xuICAgICAgdmFyIGxpbmUgPSBjbS5nZXRMaW5lKGxuKTtcblxuICAgICAgdmFyIGN1cnIgPSB7XG4gICAgICAgIGxpbmU6IGxpbmUsXG4gICAgICAgIGxuOiBsbixcbiAgICAgICAgcG9zOiBwb3MsXG4gICAgICAgIGRpcjogZGlyLFxuICAgICAgfTtcblxuICAgICAgaWYgKGN1cnIubGluZSA9PT0gXCJcIikge1xuICAgICAgICByZXR1cm4geyBsbjogY3Vyci5sbiwgcG9zOiBjdXJyLnBvcyB9O1xuICAgICAgfVxuXG4gICAgICB2YXIgbGFzdFNlbnRlbmNlUG9zID0gY3Vyci5wb3M7XG5cbiAgICAgIC8vIE1vdmUgb25lIHN0ZXAgdG8gc2tpcCBjaGFyYWN0ZXIgd2Ugc3RhcnQgb25cbiAgICAgIG5leHRDaGFyKGN1cnIpO1xuXG4gICAgICB3aGlsZSAoY3Vyci5saW5lICE9PSBudWxsKSB7XG4gICAgICAgIGxhc3RTZW50ZW5jZVBvcyA9IGN1cnIucG9zO1xuICAgICAgICBpZiAoaXNFbmRPZlNlbnRlbmNlU3ltYm9sKGN1cnIubGluZVtjdXJyLnBvc10pKSB7XG4gICAgICAgICAgaWYgKCFpbmNsdXNpdmUpIHtcbiAgICAgICAgICAgIHJldHVybiB7IGxuOiBjdXJyLmxuLCBwb3M6IGN1cnIucG9zICsgMSB9O1xuICAgICAgICAgIH0gXG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBuZXh0Q2hhcihjdXJyKTtcbiAgICAgICAgICAgIHdoaWxlIChjdXJyLmxpbmUgIT09IG51bGwgKSB7XG4gICAgICAgICAgICAgIGlmIChpc1doaXRlU3BhY2VTdHJpbmcoY3Vyci5saW5lW2N1cnIucG9zXSkpIHtcbiAgICAgICAgICAgICAgICBsYXN0U2VudGVuY2VQb3MgPSBjdXJyLnBvcztcbiAgICAgICAgICAgICAgICBuZXh0Q2hhcihjdXJyKTtcbiAgICAgICAgICAgICAgfSBcbiAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7IGxuOiBjdXJyLmxuLCBwb3M6IGxhc3RTZW50ZW5jZVBvcyArIDEgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbmV4dENoYXIoY3Vycik7XG4gICAgICB9XG4gICAgICByZXR1cm4geyBsbjogY3Vyci5sbiwgcG9zOiBsYXN0U2VudGVuY2VQb3MgKyAxIH07XG4gICAgfVxuXG4gICAgLyoqIFxuICAgICAqIFBlcmZvcm1zIG9uZSBpdGVyYXRpb24gb2YgdHJhdmVyc2FsIGluIHJldmVyc2UgZGlyZWN0aW9uXG4gICAgICogUmV0dXJucyBhbiBpbmRleCBvYmplY3Qgb2YgdGhlIHNlbnRlbmNlIHN0YXJ0XG4gICAgICogQGFyZyB7Q29kZU1pcnJvcn0gY20gIFxuICAgICAqIEBhcmcge251bWJlcn0gbG4gIFxuICAgICAqIEBhcmcge251bWJlcn0gcG9zICBcbiAgICAgKiBAYXJnIHsxfC0xfSBkaXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZXZlcnNlKGNtLCBsbiwgcG9zLCBkaXIpIHtcbiAgICAgIHZhciBsaW5lID0gY20uZ2V0TGluZShsbik7XG5cbiAgICAgIHZhciBjdXJyID0ge1xuICAgICAgICBsaW5lOiBsaW5lLFxuICAgICAgICBsbjogbG4sXG4gICAgICAgIHBvczogcG9zLFxuICAgICAgICBkaXI6IGRpcixcbiAgICAgIH07XG5cbiAgICAgIGlmIChjdXJyLmxpbmUgPT09IFwiXCIpIHtcbiAgICAgICAgcmV0dXJuIHsgbG46IGN1cnIubG4sIHBvczogY3Vyci5wb3MgfTtcbiAgICAgIH1cblxuICAgICAgdmFyIGxhc3RTZW50ZW5jZVBvcyA9IGN1cnIucG9zO1xuXG4gICAgICAvLyBNb3ZlIG9uZSBzdGVwIHRvIHNraXAgY2hhcmFjdGVyIHdlIHN0YXJ0IG9uXG4gICAgICBuZXh0Q2hhcihjdXJyKTtcblxuICAgICAgd2hpbGUgKGN1cnIubGluZSAhPT0gbnVsbCkge1xuICAgICAgICBpZiAoIWlzV2hpdGVTcGFjZVN0cmluZyhjdXJyLmxpbmVbY3Vyci5wb3NdKSAmJiAhaXNFbmRPZlNlbnRlbmNlU3ltYm9sKGN1cnIubGluZVtjdXJyLnBvc10pKSB7XG4gICAgICAgICAgbGFzdFNlbnRlbmNlUG9zID0gY3Vyci5wb3M7XG4gICAgICAgIH1cblxuICAgICAgICBlbHNlIGlmIChpc0VuZE9mU2VudGVuY2VTeW1ib2woY3Vyci5saW5lW2N1cnIucG9zXSkgKSB7XG4gICAgICAgICAgaWYgKCFpbmNsdXNpdmUpIHtcbiAgICAgICAgICAgIHJldHVybiB7IGxuOiBjdXJyLmxuLCBwb3M6IGxhc3RTZW50ZW5jZVBvcyB9O1xuICAgICAgICAgIH0gXG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoaXNXaGl0ZVNwYWNlU3RyaW5nKGN1cnIubGluZVtjdXJyLnBvcyArIDFdKSkge1xuICAgICAgICAgICAgICByZXR1cm4geyBsbjogY3Vyci5sbiwgcG9zOiBjdXJyLnBvcyArIDEgfTtcbiAgICAgICAgICAgIH0gXG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHsgbG46IGN1cnIubG4sIHBvczogbGFzdFNlbnRlbmNlUG9zIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbmV4dENoYXIoY3Vycik7XG4gICAgICB9XG4gICAgICBjdXJyLmxpbmUgPSBsaW5lO1xuICAgICAgaWYgKGluY2x1c2l2ZSAmJiBpc1doaXRlU3BhY2VTdHJpbmcoY3Vyci5saW5lW2N1cnIucG9zXSkpIHtcbiAgICAgICAgcmV0dXJuIHsgbG46IGN1cnIubG4sIHBvczogY3Vyci5wb3MgfTtcbiAgICAgIH0gXG4gICAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHsgbG46IGN1cnIubG4sIHBvczogbGFzdFNlbnRlbmNlUG9zIH07XG4gICAgICB9XG5cbiAgICB9XG5cbiAgICB2YXIgY3Vycl9pbmRleCA9IHtcbiAgICAgIGxuOiBjdXIubGluZSxcbiAgICAgIHBvczogY3VyLmNoLFxuICAgIH07XG5cbiAgICB3aGlsZSAocmVwZWF0ID4gMCkge1xuICAgICAgaWYgKGRpciA8IDApIHtcbiAgICAgICAgY3Vycl9pbmRleCA9IHJldmVyc2UoY20sIGN1cnJfaW5kZXgubG4sIGN1cnJfaW5kZXgucG9zLCBkaXIpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGN1cnJfaW5kZXggPSBmb3J3YXJkKGNtLCBjdXJyX2luZGV4LmxuLCBjdXJyX2luZGV4LnBvcywgZGlyKTtcbiAgICAgIH1cbiAgICAgIHJlcGVhdC0tO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgUG9zKGN1cnJfaW5kZXgubG4sIGN1cnJfaW5kZXgucG9zKTtcbiAgfVxuICAvKipcbiAgICogQGFyZyB7Q29kZU1pcnJvcn0gY21cbiAgICogQGFyZyB7UG9zfSBjdXJcbiAgICogQGFyZyB7bnVtYmVyfSByZXBlYXRcbiAgICogQGFyZyB7bnVtYmVyfSBkaXJcbiAgICovXG4gIGZ1bmN0aW9uIGZpbmRTZW50ZW5jZShjbSwgY3VyLCByZXBlYXQsIGRpcikge1xuXG4gICAgICAvKipcbiAgICAgICAqIEBhcmcge0NvZGVNaXJyb3J9IGNtXG4gICAgICAgIFRha2VzIGFuIGluZGV4IG9iamVjdFxuICAgICAgICBAYXJnIHsge1xuICAgICAgICAgIGxpbmU6IHN0cmluZ3xudWxsLFxuICAgICAgICAgIGxuOiBudW1iZXIsIC8vIGxpbmUgbnVtYmVyXG4gICAgICAgICAgcG9zOiBudW1iZXIsIC8vIGluZGV4IGluIGxpbmUsXG4gICAgICAgICAgZGlyOiBudW1iZXIgLy8gZGlyZWN0aW9uIG9mIHRyYXZlcnNhbCAoLTEgb3IgMSlcbiAgICAgICAgfX0gaWR4XG4gICAgICAgIGFuZCBtb2RpZmllcyB0aGUgbGluZSwgbG4sIGFuZCBwb3MgbWVtYmVycyB0byByZXByZXNlbnQgdGhlXG4gICAgICAgIG5leHQgdmFsaWQgcG9zaXRpb24gb3Igc2V0cyB0aGVtIHRvIG51bGwgaWYgdGhlcmUgYXJlXG4gICAgICAgIG5vIG1vcmUgdmFsaWQgcG9zaXRpb25zLlxuICAgICAgKi9cbiAgICBmdW5jdGlvbiBuZXh0Q2hhcihjbSwgaWR4KSB7XG4gICAgICBpZiAoaWR4LmxpbmUgPT09IG51bGwpIHJldHVybjtcbiAgICAgIGlmIChpZHgucG9zICsgaWR4LmRpciA8IDAgfHwgaWR4LnBvcyArIGlkeC5kaXIgPj0gaWR4LmxpbmUubGVuZ3RoKSB7XG4gICAgICAgIGlkeC5sbiArPSBpZHguZGlyO1xuICAgICAgICBpZiAoIWlzTGluZShjbSwgaWR4LmxuKSkge1xuICAgICAgICAgIGlkeC5saW5lID0gbnVsbDtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWR4LmxpbmUgPSBjbS5nZXRMaW5lKGlkeC5sbik7XG4gICAgICAgIGlkeC5wb3MgPSAoaWR4LmRpciA+IDApID8gMCA6IGlkeC5saW5lLmxlbmd0aCAtIDE7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgaWR4LnBvcyArPSBpZHguZGlyO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qXG4gICAgICBQZXJmb3JtcyBvbmUgaXRlcmF0aW9uIG9mIHRyYXZlcnNhbCBpbiBmb3J3YXJkIGRpcmVjdGlvblxuICAgICAgUmV0dXJucyBhbiBpbmRleCBvYmplY3Qgb2YgdGhlIG5ldyBsb2NhdGlvblxuICAgICAgKi9cbiAgICAvKiogQGFyZyB7Q29kZU1pcnJvcn0gY20gQGFyZyB7bnVtYmVyfSBsbiAgQGFyZyB7bnVtYmVyfSBwb3MgIEBhcmcge251bWJlcn0gZGlyICovXG4gICAgZnVuY3Rpb24gZm9yd2FyZChjbSwgbG4sIHBvcywgZGlyKSB7XG4gICAgICB2YXIgbGluZSA9IGNtLmdldExpbmUobG4pO1xuICAgICAgdmFyIHN0b3AgPSAobGluZSA9PT0gXCJcIik7XG5cbiAgICAgIHZhciBjdXJyID0ge1xuICAgICAgICBsaW5lOiBsaW5lLFxuICAgICAgICBsbjogbG4sXG4gICAgICAgIHBvczogcG9zLFxuICAgICAgICBkaXI6IGRpcixcbiAgICAgIH07XG5cbiAgICAgIHZhciBsYXN0X3ZhbGlkID0ge1xuICAgICAgICBsbjogY3Vyci5sbixcbiAgICAgICAgcG9zOiBjdXJyLnBvcyxcbiAgICAgIH07XG5cbiAgICAgIHZhciBza2lwX2VtcHR5X2xpbmVzID0gKGN1cnIubGluZSA9PT0gXCJcIik7XG5cbiAgICAgIC8vIE1vdmUgb25lIHN0ZXAgdG8gc2tpcCBjaGFyYWN0ZXIgd2Ugc3RhcnQgb25cbiAgICAgIG5leHRDaGFyKGNtLCBjdXJyKTtcblxuICAgICAgd2hpbGUgKGN1cnIubGluZSAhPT0gbnVsbCkge1xuICAgICAgICBsYXN0X3ZhbGlkLmxuID0gY3Vyci5sbjtcbiAgICAgICAgbGFzdF92YWxpZC5wb3MgPSBjdXJyLnBvcztcblxuICAgICAgICBpZiAoY3Vyci5saW5lID09PSBcIlwiICYmICFza2lwX2VtcHR5X2xpbmVzKSB7XG4gICAgICAgICAgcmV0dXJuIHsgbG46IGN1cnIubG4sIHBvczogY3Vyci5wb3MsIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc3RvcCAmJiBjdXJyLmxpbmUgIT09IFwiXCIgJiYgIWlzV2hpdGVTcGFjZVN0cmluZyhjdXJyLmxpbmVbY3Vyci5wb3NdKSkge1xuICAgICAgICAgIHJldHVybiB7IGxuOiBjdXJyLmxuLCBwb3M6IGN1cnIucG9zLCB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzRW5kT2ZTZW50ZW5jZVN5bWJvbChjdXJyLmxpbmVbY3Vyci5wb3NdKVxuICAgICAgICAgICYmICFzdG9wXG4gICAgICAgICAgJiYgKGN1cnIucG9zID09PSBjdXJyLmxpbmUubGVuZ3RoIC0gMVxuICAgICAgICAgICAgfHwgaXNXaGl0ZVNwYWNlU3RyaW5nKGN1cnIubGluZVtjdXJyLnBvcyArIDFdKSkpIHtcbiAgICAgICAgICBzdG9wID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIG5leHRDaGFyKGNtLCBjdXJyKTtcbiAgICAgIH1cblxuICAgICAgLypcbiAgICAgICAgU2V0IHRoZSBwb3NpdGlvbiB0byB0aGUgbGFzdCBub24gd2hpdGVzcGFjZSBjaGFyYWN0ZXIgb24gdGhlIGxhc3RcbiAgICAgICAgdmFsaWQgbGluZSBpbiB0aGUgY2FzZSB0aGF0IHdlIHJlYWNoIHRoZSBlbmQgb2YgdGhlIGRvY3VtZW50LlxuICAgICAgKi9cbiAgICAgIHZhciBsaW5lID0gY20uZ2V0TGluZShsYXN0X3ZhbGlkLmxuKTtcbiAgICAgIGxhc3RfdmFsaWQucG9zID0gMDtcbiAgICAgIGZvcih2YXIgaSA9IGxpbmUubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgaWYgKCFpc1doaXRlU3BhY2VTdHJpbmcobGluZVtpXSkpIHtcbiAgICAgICAgICBsYXN0X3ZhbGlkLnBvcyA9IGk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGxhc3RfdmFsaWQ7XG5cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtcyBvbmUgaXRlcmF0aW9uIG9mIHRyYXZlcnNhbCBpbiByZXZlcnNlIGRpcmVjdGlvblxuICAgICAqIFJldHVybnMgYW4gaW5kZXggb2JqZWN0IG9mIHRoZSBuZXcgbG9jYXRpb25cbiAgICAgKiBAYXJnIHtDb2RlTWlycm9yfSBjbSAgQGFyZyB7bnVtYmVyfSBsbiAgQGFyZyB7bnVtYmVyfSBwb3MgIEBhcmcge251bWJlcn0gZGlyXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmV2ZXJzZShjbSwgbG4sIHBvcywgZGlyKSB7XG4gICAgICB2YXIgbGluZSA9IGNtLmdldExpbmUobG4pO1xuXG4gICAgICB2YXIgY3VyciA9IHtcbiAgICAgICAgbGluZTogbGluZSxcbiAgICAgICAgbG46IGxuLFxuICAgICAgICBwb3M6IHBvcyxcbiAgICAgICAgZGlyOiBkaXIsXG4gICAgICB9O1xuXG4gICAgICB2YXIgbGFzdF92YWxpZF9sbiA9IGN1cnIubG47XG4gICAgICAvKipAdHlwZXtudW1iZXJ8bnVsbH0qL3ZhciBsYXN0X3ZhbGlkX3BvcyA9IG51bGw7XG5cbiAgICAgIHZhciBza2lwX2VtcHR5X2xpbmVzID0gKGN1cnIubGluZSA9PT0gXCJcIik7XG5cbiAgICAgIC8vIE1vdmUgb25lIHN0ZXAgdG8gc2tpcCBjaGFyYWN0ZXIgd2Ugc3RhcnQgb25cbiAgICAgIG5leHRDaGFyKGNtLCBjdXJyKTtcblxuICAgICAgd2hpbGUgKGN1cnIubGluZSAhPT0gbnVsbCkge1xuXG4gICAgICAgIGlmIChjdXJyLmxpbmUgPT09IFwiXCIgJiYgIXNraXBfZW1wdHlfbGluZXMpIHtcbiAgICAgICAgICBpZiAobGFzdF92YWxpZF9wb3MgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB7IGxuOiBsYXN0X3ZhbGlkX2xuLCBwb3M6IGxhc3RfdmFsaWRfcG9zIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHsgbG46IGN1cnIubG4sIHBvczogY3Vyci5wb3MgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNFbmRPZlNlbnRlbmNlU3ltYm9sKGN1cnIubGluZVtjdXJyLnBvc10pXG4gICAgICAgICAgICAmJiBsYXN0X3ZhbGlkX3BvcyAhPT0gbnVsbFxuICAgICAgICAgICAgJiYgIShjdXJyLmxuID09PSBsYXN0X3ZhbGlkX2xuICYmIGN1cnIucG9zICsgMSA9PT0gbGFzdF92YWxpZF9wb3MpKSB7XG4gICAgICAgICAgcmV0dXJuIHsgbG46IGxhc3RfdmFsaWRfbG4sIHBvczogbGFzdF92YWxpZF9wb3MgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY3Vyci5saW5lICE9PSBcIlwiICYmICFpc1doaXRlU3BhY2VTdHJpbmcoY3Vyci5saW5lW2N1cnIucG9zXSkpIHtcbiAgICAgICAgICBza2lwX2VtcHR5X2xpbmVzID0gZmFsc2U7XG4gICAgICAgICAgbGFzdF92YWxpZF9sbiA9IGN1cnIubG47XG4gICAgICAgICAgbGFzdF92YWxpZF9wb3MgPSBjdXJyLnBvcztcbiAgICAgICAgfVxuXG4gICAgICAgIG5leHRDaGFyKGNtLCBjdXJyKTtcbiAgICAgIH1cblxuICAgICAgLypcbiAgICAgICAgU2V0IHRoZSBwb3NpdGlvbiB0byB0aGUgZmlyc3Qgbm9uIHdoaXRlc3BhY2UgY2hhcmFjdGVyIG9uIHRoZSBsYXN0XG4gICAgICAgIHZhbGlkIGxpbmUgaW4gdGhlIGNhc2UgdGhhdCB3ZSByZWFjaCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBkb2N1bWVudC5cbiAgICAgICovXG4gICAgICB2YXIgbGluZSA9IGNtLmdldExpbmUobGFzdF92YWxpZF9sbik7XG4gICAgICBsYXN0X3ZhbGlkX3BvcyA9IDA7XG4gICAgICBmb3IodmFyIGkgPSAwOyBpIDwgbGluZS5sZW5ndGg7ICsraSkge1xuICAgICAgICBpZiAoIWlzV2hpdGVTcGFjZVN0cmluZyhsaW5lW2ldKSkge1xuICAgICAgICAgIGxhc3RfdmFsaWRfcG9zID0gaTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHsgbG46IGxhc3RfdmFsaWRfbG4sIHBvczogbGFzdF92YWxpZF9wb3MgfTtcbiAgICB9XG5cbiAgICB2YXIgY3Vycl9pbmRleCA9IHtcbiAgICAgIGxuOiBjdXIubGluZSxcbiAgICAgIHBvczogY3VyLmNoLFxuICAgIH07XG5cbiAgICB3aGlsZSAocmVwZWF0ID4gMCkge1xuICAgICAgaWYgKGRpciA8IDApIHtcbiAgICAgICAgY3Vycl9pbmRleCA9IHJldmVyc2UoY20sIGN1cnJfaW5kZXgubG4sIGN1cnJfaW5kZXgucG9zLCBkaXIpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGN1cnJfaW5kZXggPSBmb3J3YXJkKGNtLCBjdXJyX2luZGV4LmxuLCBjdXJyX2luZGV4LnBvcywgZGlyKTtcbiAgICAgIH1cbiAgICAgIHJlcGVhdC0tO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgUG9zKGN1cnJfaW5kZXgubG4sIGN1cnJfaW5kZXgucG9zKTtcbiAgfVxuXG4gIC8vIFRPRE86IHBlcmhhcHMgdGhpcyBmaW5hZ2xpbmcgb2Ygc3RhcnQgYW5kIGVuZCBwb3NpdGlvbnMgYmVsb25nc1xuICAvLyBpbiBjb2RlbWlycm9yL3JlcGxhY2VSYW5nZT9cbiAgLyoqIEBhcmcge0NvZGVNaXJyb3J9IGNtICBAYXJnIHtQb3N9IGhlYWQgQGFyZyB7c3RyaW5nIHwgbnVtYmVyfSBzeW1iIEBhcmcge2Jvb2xlYW59IGluY2x1c2l2ZSAqL1xuICBmdW5jdGlvbiBzZWxlY3RDb21wYW5pb25PYmplY3QoY20sIGhlYWQsIHN5bWIsIGluY2x1c2l2ZSkge1xuICAgIHZhciBjdXIgPSBoZWFkO1xuXG4gICAgdmFyIGJyYWNrZXRSZWdleHAgPSAoe1xuICAgICAgJygnOiAvWygpXS8sICcpJzogL1soKV0vLFxuICAgICAgJ1snOiAvW1tcXF1dLywgJ10nOiAvW1tcXF1dLyxcbiAgICAgICd7JzogL1t7fV0vLCAnfSc6IC9be31dLyxcbiAgICAgICc8JzogL1s8Pl0vLCAnPic6IC9bPD5dL30pW3N5bWJdO1xuICAgIHZhciBvcGVuU3ltID0gKHtcbiAgICAgICcoJzogJygnLCAnKSc6ICcoJyxcbiAgICAgICdbJzogJ1snLCAnXSc6ICdbJyxcbiAgICAgICd7JzogJ3snLCAnfSc6ICd7JyxcbiAgICAgICc8JzogJzwnLCAnPic6ICc8J30pW3N5bWJdO1xuICAgIHZhciBjdXJDaGFyID0gY20uZ2V0TGluZShjdXIubGluZSkuY2hhckF0KGN1ci5jaCk7XG4gICAgLy8gRHVlIHRvIHRoZSBiZWhhdmlvciBvZiBzY2FuRm9yQnJhY2tldCwgd2UgbmVlZCB0byBhZGQgYW4gb2Zmc2V0IGlmIHRoZVxuICAgIC8vIGN1cnNvciBpcyBvbiBhIG1hdGNoaW5nIG9wZW4gYnJhY2tldC5cbiAgICB2YXIgb2Zmc2V0ID0gY3VyQ2hhciA9PT0gb3BlblN5bSA/IDEgOiAwO1xuXG4gICAgdmFyIHN0YXJ0QnJhY2tldCA9IGNtLnNjYW5Gb3JCcmFja2V0KG5ldyBQb3MoY3VyLmxpbmUsIGN1ci5jaCArIG9mZnNldCksIC0xLCB1bmRlZmluZWQsIHsnYnJhY2tldFJlZ2V4JzogYnJhY2tldFJlZ2V4cH0pO1xuICAgIHZhciBlbmRCcmFja2V0ID0gY20uc2NhbkZvckJyYWNrZXQobmV3IFBvcyhjdXIubGluZSwgY3VyLmNoICsgb2Zmc2V0KSwgMSwgdW5kZWZpbmVkLCB7J2JyYWNrZXRSZWdleCc6IGJyYWNrZXRSZWdleHB9KTtcblxuICAgIGlmICghc3RhcnRCcmFja2V0IHx8ICFlbmRCcmFja2V0KSByZXR1cm4gbnVsbDtcblxuICAgIHZhciBzdGFydCA9IHN0YXJ0QnJhY2tldC5wb3M7IFxuICAgIHZhciBlbmQgPSBlbmRCcmFja2V0LnBvcztcblxuICAgIGlmICgoc3RhcnQubGluZSA9PSBlbmQubGluZSAmJiBzdGFydC5jaCA+IGVuZC5jaClcbiAgICAgICAgfHwgKHN0YXJ0LmxpbmUgPiBlbmQubGluZSkpIHtcbiAgICAgIHZhciB0bXAgPSBzdGFydDtcbiAgICAgIHN0YXJ0ID0gZW5kO1xuICAgICAgZW5kID0gdG1wO1xuICAgIH1cblxuICAgIGlmIChpbmNsdXNpdmUpIHtcbiAgICAgIGVuZC5jaCArPSAxO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGFydC5jaCArPSAxO1xuICAgIH1cblxuICAgIHJldHVybiB7IHN0YXJ0OiBzdGFydCwgZW5kOiBlbmQgfTtcbiAgfVxuXG4gIC8vIFRha2VzIGluIGEgc3ltYm9sIGFuZCBhIGN1cnNvciBhbmQgdHJpZXMgdG8gc2ltdWxhdGUgdGV4dCBvYmplY3RzIHRoYXRcbiAgLy8gaGF2ZSBpZGVudGljYWwgb3BlbmluZyBhbmQgY2xvc2luZyBzeW1ib2xzXG4gIC8vIFRPRE8gc3VwcG9ydCBhY3Jvc3MgbXVsdGlwbGUgbGluZXNcbiAgLyoqIEBhcmcge0NvZGVNaXJyb3J9IGNtICBAYXJnIHtQb3N9IGhlYWQgIEBhcmcge3N0cmluZ30gc3ltYiBAYXJnIHtib29sZWFufSBpbmNsdXNpdmUgKi9cbiAgZnVuY3Rpb24gZmluZEJlZ2lubmluZ0FuZEVuZChjbSwgaGVhZCwgc3ltYiwgaW5jbHVzaXZlKSB7XG4gICAgdmFyIGN1ciA9IGNvcHlDdXJzb3IoaGVhZCk7XG4gICAgdmFyIGxpbmUgPSBjbS5nZXRMaW5lKGN1ci5saW5lKTtcbiAgICB2YXIgY2hhcnMgPSBsaW5lLnNwbGl0KCcnKTtcbiAgICB2YXIgc3RhcnQsIGVuZCwgaSwgbGVuO1xuICAgIHZhciBmaXJzdEluZGV4ID0gY2hhcnMuaW5kZXhPZihzeW1iKTtcblxuICAgIC8vIHRoZSBkZWNpc2lvbiB0cmVlIGlzIHRvIGFsd2F5cyBsb29rIGJhY2t3YXJkcyBmb3IgdGhlIGJlZ2lubmluZyBmaXJzdCxcbiAgICAvLyBidXQgaWYgdGhlIGN1cnNvciBpcyBpbiBmcm9udCBvZiB0aGUgZmlyc3QgaW5zdGFuY2Ugb2YgdGhlIHN5bWIsXG4gICAgLy8gdGhlbiBtb3ZlIHRoZSBjdXJzb3IgZm9yd2FyZFxuICAgIGlmIChjdXIuY2ggPCBmaXJzdEluZGV4KSB7XG4gICAgICBjdXIuY2ggPSBmaXJzdEluZGV4O1xuICAgIH1cbiAgICAvLyBvdGhlcndpc2UgaWYgdGhlIGN1cnNvciBpcyBjdXJyZW50bHkgb24gdGhlIGNsb3Npbmcgc3ltYm9sXG4gICAgZWxzZSBpZiAoZmlyc3RJbmRleCA8IGN1ci5jaCAmJiBjaGFyc1tjdXIuY2hdID09IHN5bWIpIHtcbiAgICAgIHZhciBzdHJpbmdBZnRlciA9IC9zdHJpbmcvLnRlc3QoY20uZ2V0VG9rZW5UeXBlQXQob2Zmc2V0Q3Vyc29yKGhlYWQsIDAsIDEpKSk7XG4gICAgICB2YXIgc3RyaW5nQmVmb3JlID0gL3N0cmluZy8udGVzdChjbS5nZXRUb2tlblR5cGVBdChoZWFkKSk7XG4gICAgICB2YXIgaXNTdHJpbmdTdGFydCA9IHN0cmluZ0FmdGVyICYmICFzdHJpbmdCZWZvcmU7XG4gICAgICBpZiAoIWlzU3RyaW5nU3RhcnQpIHtcbiAgICAgICAgZW5kID0gY3VyLmNoOyAvLyBhc3NpZ24gZW5kIHRvIHRoZSBjdXJyZW50IGN1cnNvclxuICAgICAgICAtLWN1ci5jaDsgLy8gbWFrZSBzdXJlIHRvIGxvb2sgYmFja3dhcmRzXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gaWYgd2UncmUgY3VycmVudGx5IG9uIHRoZSBzeW1ib2wsIHdlJ3ZlIGdvdCBhIHN0YXJ0XG4gICAgaWYgKGNoYXJzW2N1ci5jaF0gPT0gc3ltYiAmJiAhZW5kKSB7XG4gICAgICBzdGFydCA9IGN1ci5jaCArIDE7IC8vIGFzc2lnbiBzdGFydCB0byBhaGVhZCBvZiB0aGUgY3Vyc29yXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGdvIGJhY2t3YXJkcyB0byBmaW5kIHRoZSBzdGFydFxuICAgICAgZm9yIChpID0gY3VyLmNoOyBpID4gLTEgJiYgIXN0YXJ0OyBpLS0pIHtcbiAgICAgICAgaWYgKGNoYXJzW2ldID09IHN5bWIpIHtcbiAgICAgICAgICBzdGFydCA9IGkgKyAxO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gbG9vayBmb3J3YXJkcyBmb3IgdGhlIGVuZCBzeW1ib2xcbiAgICBpZiAoc3RhcnQgJiYgIWVuZCkge1xuICAgICAgZm9yIChpID0gc3RhcnQsIGxlbiA9IGNoYXJzLmxlbmd0aDsgaSA8IGxlbiAmJiAhZW5kOyBpKyspIHtcbiAgICAgICAgaWYgKGNoYXJzW2ldID09IHN5bWIpIHtcbiAgICAgICAgICBlbmQgPSBpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gbm90aGluZyBmb3VuZFxuICAgIGlmICghc3RhcnQgfHwgIWVuZCkge1xuICAgICAgcmV0dXJuIHsgc3RhcnQ6IGN1ciwgZW5kOiBjdXIgfTtcbiAgICB9XG5cbiAgICAvLyBpbmNsdWRlIHRoZSBzeW1ib2xzXG4gICAgaWYgKGluY2x1c2l2ZSkge1xuICAgICAgLS1zdGFydDsgKytlbmQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHN0YXJ0OiBuZXcgUG9zKGN1ci5saW5lLCBzdGFydCksXG4gICAgICBlbmQ6IG5ldyBQb3MoY3VyLmxpbmUsIGVuZClcbiAgICB9O1xuICB9XG5cbiAgLy8gU2VhcmNoIGZ1bmN0aW9uc1xuICBkZWZpbmVPcHRpb24oJ3BjcmUnLCB0cnVlLCAnYm9vbGVhbicpO1xuICBcbiAgLyoqQHR5cGUge1NlYXJjaFN0YXRlSW50ZXJmYWNlfSAqL1xuICBjbGFzcyBTZWFyY2hTdGF0ZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAvKipAdHlwZXtudW1iZXJ8dW5kZWZpbmVkfSAqL1xuICAgICAgdGhpcy5oaWdobGlnaHRUaW1lb3V0O1xuICAgIH1cbiAgICBnZXRRdWVyeSgpIHtcbiAgICAgIHJldHVybiB2aW1HbG9iYWxTdGF0ZS5xdWVyeTtcbiAgICB9O1xuICAgIHNldFF1ZXJ5KHF1ZXJ5KSB7XG4gICAgICB2aW1HbG9iYWxTdGF0ZS5xdWVyeSA9IHF1ZXJ5O1xuICAgIH07XG4gICAgZ2V0T3ZlcmxheSgpIHtcbiAgICAgIHJldHVybiB0aGlzLnNlYXJjaE92ZXJsYXk7XG4gICAgfTtcbiAgICBzZXRPdmVybGF5KG92ZXJsYXkpIHtcbiAgICAgIHRoaXMuc2VhcmNoT3ZlcmxheSA9IG92ZXJsYXk7XG4gICAgfTtcbiAgICBpc1JldmVyc2VkKCkge1xuICAgICAgcmV0dXJuIHZpbUdsb2JhbFN0YXRlLmlzUmV2ZXJzZWQ7XG4gICAgfTtcbiAgICBzZXRSZXZlcnNlZChyZXZlcnNlZCkge1xuICAgICAgdmltR2xvYmFsU3RhdGUuaXNSZXZlcnNlZCA9IHJldmVyc2VkO1xuICAgIH07XG4gICAgZ2V0U2Nyb2xsYmFyQW5ub3RhdGUoKSB7XG4gICAgICByZXR1cm4gdGhpcy5hbm5vdGF0ZTtcbiAgICB9O1xuICAgIHNldFNjcm9sbGJhckFubm90YXRlKGFubm90YXRlKSB7XG4gICAgICB0aGlzLmFubm90YXRlID0gYW5ub3RhdGU7XG4gICAgfTtcbiAgfSAgLyoqIEBhcmcge0NvZGVNaXJyb3JWfSBjbSBAcmV0dXJucyB7U2VhcmNoU3RhdGVJbnRlcmZhY2V9ICovXG4gIGZ1bmN0aW9uIGdldFNlYXJjaFN0YXRlKGNtKSB7XG4gICAgdmFyIHZpbSA9IGNtLnN0YXRlLnZpbTtcbiAgICByZXR1cm4gdmltLnNlYXJjaFN0YXRlXyB8fCAodmltLnNlYXJjaFN0YXRlXyA9IG5ldyBTZWFyY2hTdGF0ZSgpKTtcbiAgfVxuICAvKiogQGFyZyB7c3RyaW5nfSBhcmdTdHJpbmcgKi9cbiAgZnVuY3Rpb24gc3BsaXRCeVNsYXNoKGFyZ1N0cmluZykge1xuICAgIHJldHVybiBzcGxpdEJ5U2VwYXJhdG9yKGFyZ1N0cmluZywgJy8nKTtcbiAgfVxuXG4gIC8qKiBAYXJnIHtzdHJpbmd9IGFyZ1N0cmluZyAqL1xuICBmdW5jdGlvbiBmaW5kVW5lc2NhcGVkU2xhc2hlcyhhcmdTdHJpbmcpIHtcbiAgICByZXR1cm4gZmluZFVuZXNjYXBlZFNlcGFyYXRvcnMoYXJnU3RyaW5nLCAnLycpO1xuICB9XG5cbiAgLyoqIEBhcmcge3N0cmluZ30gYXJnU3RyaW5nICBAYXJnIHtzdHJpbmd9IHNlcGFyYXRvciAqL1xuICBmdW5jdGlvbiBzcGxpdEJ5U2VwYXJhdG9yKGFyZ1N0cmluZywgc2VwYXJhdG9yKSB7XG4gICAgdmFyIHNsYXNoZXMgPSBmaW5kVW5lc2NhcGVkU2VwYXJhdG9ycyhhcmdTdHJpbmcsIHNlcGFyYXRvcikgfHwgW107XG4gICAgaWYgKCFzbGFzaGVzLmxlbmd0aCkgcmV0dXJuIFtdO1xuICAgIHZhciB0b2tlbnMgPSBbXTtcbiAgICAvLyBpbiBjYXNlIG9mIHN0cmluZ3MgbGlrZSBmb28vYmFyXG4gICAgaWYgKHNsYXNoZXNbMF0gIT09IDApIHJldHVybjtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNsYXNoZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICh0eXBlb2Ygc2xhc2hlc1tpXSA9PSAnbnVtYmVyJylcbiAgICAgICAgdG9rZW5zLnB1c2goYXJnU3RyaW5nLnN1YnN0cmluZyhzbGFzaGVzW2ldICsgMSwgc2xhc2hlc1tpKzFdKSk7XG4gICAgfVxuICAgIHJldHVybiB0b2tlbnM7XG4gIH1cblxuICAvKiogQGFyZyB7c3RyaW5nfSBzdHIgIEBhcmcge3N0cmluZ30gc2VwYXJhdG9yICovXG4gIGZ1bmN0aW9uIGZpbmRVbmVzY2FwZWRTZXBhcmF0b3JzKHN0ciwgc2VwYXJhdG9yKSB7XG4gICAgaWYgKCFzZXBhcmF0b3IpXG4gICAgICBzZXBhcmF0b3IgPSAnLyc7XG5cbiAgICB2YXIgZXNjYXBlTmV4dENoYXIgPSBmYWxzZTtcbiAgICB2YXIgc2xhc2hlcyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgYyA9IHN0ci5jaGFyQXQoaSk7XG4gICAgICBpZiAoIWVzY2FwZU5leHRDaGFyICYmIGMgPT0gc2VwYXJhdG9yKSB7XG4gICAgICAgIHNsYXNoZXMucHVzaChpKTtcbiAgICAgIH1cbiAgICAgIGVzY2FwZU5leHRDaGFyID0gIWVzY2FwZU5leHRDaGFyICYmIChjID09ICdcXFxcJyk7XG4gICAgfVxuICAgIHJldHVybiBzbGFzaGVzO1xuICB9XG5cbiAgLy8gVHJhbnNsYXRlcyBhIHNlYXJjaCBzdHJpbmcgZnJvbSBleCAodmltKSBzeW50YXggaW50byBqYXZhc2NyaXB0IGZvcm0uXG4gIC8qKiBAYXJnIHtzdHJpbmd9IHN0ciAqL1xuICBmdW5jdGlvbiB0cmFuc2xhdGVSZWdleChzdHIpIHtcbiAgICAvLyBXaGVuIHRoZXNlIG1hdGNoLCBhZGQgYSAnXFwnIGlmIHVuZXNjYXBlZCBvciByZW1vdmUgb25lIGlmIGVzY2FwZWQuXG4gICAgdmFyIG1vZGVzID0ge1xuICAgICAgVjogJ3woKXsrPyouWyReJywgLy8gdmVyeW5vbWFnaWNcbiAgICAgIE06ICd8KCl7Kz8qLlsnLCAvLyBub21hZ2ljXG4gICAgICBtOiAnfCgpeys/JywgLy8gbWFnaWNcbiAgICAgIHY6ICc8PicsIC8vIHZlcnltYWdpY1xuICAgIH07XG4gICAgdmFyIGVzY2FwZXMgPSB7XG4gICAgICAnPic6ICcoPzw9W1xcXFx3XSkoPz1bXlxcXFx3XXwkKScsXG4gICAgICAnPCc6ICcoPzw9W15cXFxcd118XikoPz1bXFxcXHddKScsXG4gICAgfTtcbiAgICB2YXIgc3BlY2lhbHMgPSBtb2Rlcy5tO1xuICAgIHZhciByZWdleCA9IHN0ci5yZXBsYWNlKC9cXFxcLnxbXFxbfCgpeysqPy4kXjw+XS9nLCBmdW5jdGlvbihtYXRjaCkge1xuICAgICAgaWYgKG1hdGNoWzBdID09PSAnXFxcXCcpIHtcbiAgICAgICAgdmFyIG5leHRDaGFyID0gbWF0Y2hbMV07XG4gICAgICAgIGlmIChuZXh0Q2hhciA9PT0gJ30nIHx8IHNwZWNpYWxzLmluZGV4T2YobmV4dENoYXIpICE9IC0xKSB7XG4gICAgICAgICAgcmV0dXJuIG5leHRDaGFyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuZXh0Q2hhciBpbiBtb2Rlcykge1xuICAgICAgICAgICBzcGVjaWFscyA9IG1vZGVzW25leHRDaGFyXTtcbiAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuZXh0Q2hhciBpbiBlc2NhcGVzKSB7XG4gICAgICAgICAgcmV0dXJuIGVzY2FwZXNbbmV4dENoYXJdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYXRjaDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChzcGVjaWFscy5pbmRleE9mKG1hdGNoKSAhPSAtMSkge1xuICAgICAgICAgIHJldHVybiBlc2NhcGVzW21hdGNoXSB8fCAnXFxcXCcgKyBtYXRjaDsgXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1hdGNoO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdmFyIGkgPSByZWdleC5pbmRleE9mKCdcXFxcenMnKTtcbiAgICBpZiAoaSAhPSAtMSkge1xuICAgICAgcmVnZXggPSAnKD88PScgKyByZWdleC5zbGljZSgwLCBpKSArICcpJyArIHJlZ2V4LnNsaWNlKGkgKyAzKTtcbiAgICB9XG4gICAgaSA9IHJlZ2V4LmluZGV4T2YoJ1xcXFx6ZScpO1xuICAgIGlmIChpICE9IC0xKSB7XG4gICAgICByZWdleCA9IHJlZ2V4LnNsaWNlKDAsIGkpICsgICcoPz0nICsgcmVnZXguc2xpY2UoaSArIDMpICsgJyknO1xuICAgIH1cblxuICAgIHJldHVybiByZWdleDtcbiAgfVxuXG4gIC8vIFRyYW5zbGF0ZXMgdGhlIHJlcGxhY2UgcGFydCBvZiBhIHNlYXJjaCBhbmQgcmVwbGFjZSBmcm9tIGV4ICh2aW0pIHN5bnRheCBpbnRvXG4gIC8vIGphdmFzY3JpcHQgZm9ybS4gIFNpbWlsYXIgdG8gdHJhbnNsYXRlUmVnZXgsIGJ1dCBhZGRpdGlvbmFsbHkgZml4ZXMgYmFjayByZWZlcmVuY2VzXG4gIC8vICh0cmFuc2xhdGVzICdcXFswLi45XScgdG8gJyRbMC4uOV0nKSBhbmQgZm9sbG93cyBkaWZmZXJlbnQgcnVsZXMgZm9yIGVzY2FwaW5nICckJy5cbiAgLyoqIEB0eXBle09iamVjdDxzdHJpbmcsIHN0cmluZz59ICovXG4gIHZhciBjaGFyVW5lc2NhcGVzID0geydcXFxcbic6ICdcXG4nLCAnXFxcXHInOiAnXFxyJywgJ1xcXFx0JzogJ1xcdCd9O1xuICAvKiogQGFyZyB7c3RyaW5nfSBzdHIgKi9cbiAgZnVuY3Rpb24gdHJhbnNsYXRlUmVnZXhSZXBsYWNlKHN0cikge1xuICAgIHZhciBlc2NhcGVOZXh0Q2hhciA9IGZhbHNlO1xuICAgIHZhciBvdXQgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gLTE7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjID0gc3RyLmNoYXJBdChpKSB8fCAnJztcbiAgICAgIHZhciBuID0gc3RyLmNoYXJBdChpKzEpIHx8ICcnO1xuICAgICAgaWYgKGNoYXJVbmVzY2FwZXNbYyArIG5dKSB7XG4gICAgICAgIG91dC5wdXNoKGNoYXJVbmVzY2FwZXNbYytuXSk7XG4gICAgICAgIGkrKztcbiAgICAgIH0gZWxzZSBpZiAoZXNjYXBlTmV4dENoYXIpIHtcbiAgICAgICAgLy8gQXQgYW55IHBvaW50IGluIHRoZSBsb29wLCBlc2NhcGVOZXh0Q2hhciBpcyB0cnVlIGlmIHRoZSBwcmV2aW91c1xuICAgICAgICAvLyBjaGFyYWN0ZXIgd2FzIGEgJ1xcJyBhbmQgd2FzIG5vdCBlc2NhcGVkLlxuICAgICAgICBvdXQucHVzaChjKTtcbiAgICAgICAgZXNjYXBlTmV4dENoYXIgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChjID09PSAnXFxcXCcpIHtcbiAgICAgICAgICBlc2NhcGVOZXh0Q2hhciA9IHRydWU7XG4gICAgICAgICAgaWYgKChpc051bWJlcihuKSB8fCBuID09PSAnJCcpKSB7XG4gICAgICAgICAgICBvdXQucHVzaCgnJCcpO1xuICAgICAgICAgIH0gZWxzZSBpZiAobiAhPT0gJy8nICYmIG4gIT09ICdcXFxcJykge1xuICAgICAgICAgICAgb3V0LnB1c2goJ1xcXFwnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGMgPT09ICckJykge1xuICAgICAgICAgICAgb3V0LnB1c2goJyQnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgb3V0LnB1c2goYyk7XG4gICAgICAgICAgaWYgKG4gPT09ICcvJykge1xuICAgICAgICAgICAgb3V0LnB1c2goJ1xcXFwnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG91dC5qb2luKCcnKTtcbiAgfVxuXG4gIC8vIFVuZXNjYXBlIFxcIGFuZCAvIGluIHRoZSByZXBsYWNlIHBhcnQsIGZvciBQQ1JFIG1vZGUuXG4gIC8qKiBAdHlwZXtSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+fSAqL1xuICB2YXIgdW5lc2NhcGVzID0geydcXFxcLyc6ICcvJywgJ1xcXFxcXFxcJzogJ1xcXFwnLCAnXFxcXG4nOiAnXFxuJywgJ1xcXFxyJzogJ1xccicsICdcXFxcdCc6ICdcXHQnLCAnXFxcXCYnOicmJ307XG4gIC8qKiBAYXJnIHtzdHJpbmd9IHN0ciAqL1xuICBmdW5jdGlvbiB1bmVzY2FwZVJlZ2V4UmVwbGFjZShzdHIpIHtcbiAgICB2YXIgc3RyZWFtID0gbmV3IENNLlN0cmluZ1N0cmVhbShzdHIpO1xuICAgIHZhciBvdXRwdXQgPSBbXTtcbiAgICB3aGlsZSAoIXN0cmVhbS5lb2woKSkge1xuICAgICAgLy8gU2VhcmNoIGZvciBcXC5cbiAgICAgIHdoaWxlIChzdHJlYW0ucGVlaygpICYmIHN0cmVhbS5wZWVrKCkgIT0gJ1xcXFwnKSB7XG4gICAgICAgIG91dHB1dC5wdXNoKHN0cmVhbS5uZXh0KCkpO1xuICAgICAgfVxuICAgICAgdmFyIG1hdGNoZWQgPSBmYWxzZTtcbiAgICAgIGZvciAodmFyIG1hdGNoZXIgaW4gdW5lc2NhcGVzKSB7XG4gICAgICAgIGlmIChzdHJlYW0ubWF0Y2gobWF0Y2hlciwgdHJ1ZSkpIHtcbiAgICAgICAgICBtYXRjaGVkID0gdHJ1ZTtcbiAgICAgICAgICBvdXRwdXQucHVzaCh1bmVzY2FwZXNbbWF0Y2hlcl0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIW1hdGNoZWQpIHtcbiAgICAgICAgLy8gRG9uJ3QgY2hhbmdlIGFueXRoaW5nXG4gICAgICAgIG91dHB1dC5wdXNoKHN0cmVhbS5uZXh0KCkpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb3V0cHV0LmpvaW4oJycpO1xuICB9XG5cbiAgLyoqXG4gICAqIEV4dHJhY3QgdGhlIHJlZ3VsYXIgZXhwcmVzc2lvbiBmcm9tIHRoZSBxdWVyeSBhbmQgcmV0dXJuIGEgUmVnZXhwIG9iamVjdC5cbiAgICogUmV0dXJucyBudWxsIGlmIHRoZSBxdWVyeSBpcyBibGFuay5cbiAgICogSWYgaWdub3JlQ2FzZSBpcyBwYXNzZWQgaW4sIHRoZSBSZWdleHAgb2JqZWN0IHdpbGwgaGF2ZSB0aGUgJ2knIGZsYWcgc2V0LlxuICAgKiBJZiBzbWFydENhc2UgaXMgcGFzc2VkIGluLCBhbmQgdGhlIHF1ZXJ5IGNvbnRhaW5zIHVwcGVyIGNhc2UgbGV0dGVycyxcbiAgICogICB0aGVuIGlnbm9yZUNhc2UgaXMgb3ZlcnJpZGRlbiwgYW5kIHRoZSAnaScgZmxhZyB3aWxsIG5vdCBiZSBzZXQuXG4gICAqIElmIHRoZSBxdWVyeSBjb250YWlucyB0aGUgL2kgaW4gdGhlIGZsYWcgcGFydCBvZiB0aGUgcmVndWxhciBleHByZXNzaW9uLFxuICAgKiAgIHRoZW4gYm90aCBpZ25vcmVDYXNlIGFuZCBzbWFydENhc2UgYXJlIGlnbm9yZWQsIGFuZCAnaScgd2lsbCBiZSBwYXNzZWRcbiAgICogICB0aHJvdWdoIHRvIHRoZSBSZWdleCBvYmplY3QuXG4gICAqIEBhcmcge3N0cmluZ30gcXVlcnlcbiAgICogQGFyZyB7Ym9vbGVhbn0gaWdub3JlQ2FzZVxuICAgKiBAYXJnIHtib29sZWFufSBzbWFydENhc2VcbiAgICovXG4gIGZ1bmN0aW9uIHBhcnNlUXVlcnkocXVlcnksIGlnbm9yZUNhc2UsIHNtYXJ0Q2FzZSkge1xuICAgIC8vIEZpcnN0IHVwZGF0ZSB0aGUgbGFzdCBzZWFyY2ggcmVnaXN0ZXJcbiAgICB2YXIgbGFzdFNlYXJjaFJlZ2lzdGVyID0gdmltR2xvYmFsU3RhdGUucmVnaXN0ZXJDb250cm9sbGVyLmdldFJlZ2lzdGVyKCcvJyk7XG4gICAgbGFzdFNlYXJjaFJlZ2lzdGVyLnNldFRleHQocXVlcnkpO1xuICAgIC8vIEZpcnN0IHRyeSB0byBleHRyYWN0IHJlZ2V4ICsgZmxhZ3MgZnJvbSB0aGUgaW5wdXQuIElmIG5vIGZsYWdzIGZvdW5kLFxuICAgIC8vIGV4dHJhY3QganVzdCB0aGUgcmVnZXguIElFIGRvZXMgbm90IGFjY2VwdCBmbGFncyBkaXJlY3RseSBkZWZpbmVkIGluXG4gICAgLy8gdGhlIHJlZ2V4IHN0cmluZyBpbiB0aGUgZm9ybSAvcmVnZXgvZmxhZ3NcbiAgICB2YXIgc2xhc2hlcyA9IGZpbmRVbmVzY2FwZWRTbGFzaGVzKHF1ZXJ5KTtcbiAgICB2YXIgcmVnZXhQYXJ0O1xuICAgIHZhciBmb3JjZUlnbm9yZUNhc2U7XG4gICAgaWYgKCFzbGFzaGVzLmxlbmd0aCkge1xuICAgICAgLy8gUXVlcnkgbG9va3MgbGlrZSAncmVnZXhwJ1xuICAgICAgcmVnZXhQYXJ0ID0gcXVlcnk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFF1ZXJ5IGxvb2tzIGxpa2UgJ3JlZ2V4cC8uLi4nXG4gICAgICByZWdleFBhcnQgPSBxdWVyeS5zdWJzdHJpbmcoMCwgc2xhc2hlc1swXSk7XG4gICAgICB2YXIgZmxhZ3NQYXJ0ID0gcXVlcnkuc3Vic3RyaW5nKHNsYXNoZXNbMF0pO1xuICAgICAgZm9yY2VJZ25vcmVDYXNlID0gKGZsYWdzUGFydC5pbmRleE9mKCdpJykgIT0gLTEpO1xuICAgIH1cbiAgICBpZiAoIXJlZ2V4UGFydCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmICghZ2V0T3B0aW9uKCdwY3JlJykpIHtcbiAgICAgIHJlZ2V4UGFydCA9IHRyYW5zbGF0ZVJlZ2V4KHJlZ2V4UGFydCk7XG4gICAgfVxuICAgIGlmIChzbWFydENhc2UpIHtcbiAgICAgIGlnbm9yZUNhc2UgPSAoL15bXkEtWl0qJC8pLnRlc3QocmVnZXhQYXJ0KTtcbiAgICB9XG4gICAgdmFyIHJlZ2V4cCA9IG5ldyBSZWdFeHAocmVnZXhQYXJ0LFxuICAgICAgICAoaWdub3JlQ2FzZSB8fCBmb3JjZUlnbm9yZUNhc2UpID8gJ2ltJyA6ICdtJyk7XG4gICAgcmV0dXJuIHJlZ2V4cDtcbiAgfVxuXG4gIC8qKlxuICAgKiBkb20gLSBEb2N1bWVudCBPYmplY3QgTWFuaXB1bGF0b3JcbiAgICogVXNhZ2U6XG4gICAqICAgZG9tKCc8dGFnPid8PG5vZGU+WywgLi4uezxhdHRyaWJ1dGVzPnw8JHN0eWxlcz59fDxjaGlsZC1ub2RlPnwnPHRleHQ+J10pXG4gICAqIEV4YW1wbGVzOlxuICAgKiAgIGRvbSgnZGl2Jywge2lkOid4eXonfSwgZG9tKCdwJywgJ0NNIHJvY2tzIScsIHskY29sb3I6J3JlZCd9KSlcbiAgICogICBkb20oZG9jdW1lbnQuaGVhZCwgZG9tKCdzY3JpcHQnLCAnYWxlcnQoXCJoZWxsbyFcIiknKSlcbiAgICogTm90IHN1cHBvcnRlZDpcbiAgICogICBkb20oJ3AnLCBbJ2FycmF5cyBhcmUgb2JqZWN0cyddLCBFcnJvcignb2JqZWN0cyBzcGVjaWZ5IGF0dHJpYnV0ZXMnKSlcbiAgICogQGFyZyB7c3RyaW5nIHwgSFRNTEVsZW1lbnQgfSBuXG4gICAqL1xuICBmdW5jdGlvbiBkb20obikge1xuICAgIGlmICh0eXBlb2YgbiA9PT0gJ3N0cmluZycpIG4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KG4pO1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgYSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgIGlmICghYSkgY29udGludWU7XG4gICAgICBpZiAodHlwZW9mIGEgIT09ICdvYmplY3QnKSBhID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoYSk7XG4gICAgICBpZiAoYS5ub2RlVHlwZSkgbi5hcHBlbmRDaGlsZChhKTtcbiAgICAgIGVsc2UgZm9yICh2YXIga2V5IGluIGEpIHtcbiAgICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYSwga2V5KSkgY29udGludWU7XG4gICAgICAgIGlmIChrZXlbMF0gPT09ICckJykgbi5zdHlsZVtrZXkuc2xpY2UoMSldID0gYVtrZXldO1xuICAgICAgICBlbHNlIGlmICh0eXBlb2YgYVtrZXldID09IFwiZnVuY3Rpb25cIikgbltrZXldID0gYVtrZXldO1xuICAgICAgICBlbHNlIG4uc2V0QXR0cmlidXRlKGtleSwgYVtrZXldKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG47XG4gIH1cblxuICAvKiogQGFyZyB7Q29kZU1pcnJvcn0gY20gIEBhcmcge2FueX0gdGVtcGxhdGUgIEBhcmcge2Jvb2xlYW59IFtsb25nXSovXG4gIGZ1bmN0aW9uIHNob3dDb25maXJtKGNtLCB0ZW1wbGF0ZSwgbG9uZykge1xuICAgIHZhciBwcmUgPSBkb20oJ2RpdicsIHskY29sb3I6ICdyZWQnLCAkd2hpdGVTcGFjZTogJ3ByZScsIGNsYXNzOiAnY20tdmltLW1lc3NhZ2UnfSwgdGVtcGxhdGUpO1xuICAgIGlmIChjbS5vcGVuTm90aWZpY2F0aW9uKSB7XG4gICAgICBpZiAobG9uZykge1xuICAgICAgICBwcmUgPSBkb20oJ2RpdicsIHt9LCBwcmUsIGRvbSgnZGl2Jywge30sICdQcmVzcyBFTlRFUiBvciB0eXBlIGNvbW1hbmQgdG8gY29udGludWUnKSk7XG4gICAgICAgIGlmIChjbS5zdGF0ZS5jbG9zZVZpbU5vdGlmaWNhdGlvbikge1xuICAgICAgICAgIGNtLnN0YXRlLmNsb3NlVmltTm90aWZpY2F0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgICAgY20uc3RhdGUuY2xvc2VWaW1Ob3RpZmljYXRpb24gPSBjbS5vcGVuTm90aWZpY2F0aW9uKHByZSwge2JvdHRvbTogdHJ1ZSwgZHVyYXRpb246IDB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNtLm9wZW5Ob3RpZmljYXRpb24ocHJlLCB7Ym90dG9tOiB0cnVlLCBkdXJhdGlvbjogMTUwMDB9KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgYWxlcnQocHJlLmlubmVyVGV4dCk7XG4gICAgfVxuICB9XG4gIC8qKiBAYXJnIHtzdHJpbmd8SFRNTEVsZW1lbnR9IHByZWZpeCAgQGFyZyB7c3RyaW5nfEhUTUxFbGVtZW50fSBbZGVzY10gKi9cbiAgZnVuY3Rpb24gbWFrZVByb21wdChwcmVmaXgsIGRlc2MpIHtcbiAgICByZXR1cm4gZG9tKCdkaXYnLCB7JGRpc3BsYXk6ICdmbGV4JywgJGZsZXg6IDF9LFxuICAgICAgICAgICAgICBkb20oJ3NwYW4nLCB7JGZvbnRGYW1pbHk6ICdtb25vc3BhY2UnLCAkd2hpdGVTcGFjZTogJ3ByZScsICRmbGV4OiAxLCAkZGlzcGxheTogJ2ZsZXgnfSxcbiAgICAgICAgICAgICAgICBwcmVmaXgsXG4gICAgICAgICAgICAgICAgZG9tKCdpbnB1dCcsIHt0eXBlOiAndGV4dCcsIGF1dG9jb3JyZWN0OiAnb2ZmJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF1dG9jYXBpdGFsaXplOiAnb2ZmJywgc3BlbGxjaGVjazogJ2ZhbHNlJywgJGZsZXg6IDF9KSksXG4gICAgICAgICAgICAgIGRlc2MgJiYgZG9tKCdzcGFuJywgeyRjb2xvcjogJyM4ODgnfSwgZGVzYykpO1xuICB9XG4gIC8qKlxuICAgKiBAYXJnIHtDb2RlTWlycm9yfSBjbSBcbiAgICogQGFyZyB7aW1wb3J0KFwiLi90eXBlc1wiKS5Qcm9tcHRPcHRpb25zfSBvcHRpb25zIFxuICAgKi9cbiAgZnVuY3Rpb24gc2hvd1Byb21wdChjbSwgb3B0aW9ucykge1xuICAgIGlmIChrZXlUb0tleVN0YWNrLmxlbmd0aCkge1xuICAgICAgaWYgKCFvcHRpb25zLnZhbHVlKSBvcHRpb25zLnZhbHVlID0gJyc7XG4gICAgICB2aXJ0dWFsUHJvbXB0ID0gb3B0aW9ucztcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRlbXBsYXRlID0gbWFrZVByb21wdChvcHRpb25zLnByZWZpeCwgb3B0aW9ucy5kZXNjKTtcbiAgICBpZiAoY20ub3BlbkRpYWxvZykge1xuICAgICAgY20ub3BlbkRpYWxvZyh0ZW1wbGF0ZSwgb3B0aW9ucy5vbkNsb3NlLCB7XG4gICAgICAgIG9uS2V5RG93bjogb3B0aW9ucy5vbktleURvd24sIG9uS2V5VXA6IG9wdGlvbnMub25LZXlVcCxcbiAgICAgICAgYm90dG9tOiB0cnVlLCBzZWxlY3RWYWx1ZU9uT3BlbjogZmFsc2UsIHZhbHVlOiBvcHRpb25zLnZhbHVlXG4gICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB2YXIgc2hvcnRUZXh0ID0gJyc7XG4gICAgICBpZiAodHlwZW9mIG9wdGlvbnMucHJlZml4ICE9IFwic3RyaW5nXCIgJiYgb3B0aW9ucy5wcmVmaXgpIHNob3J0VGV4dCArPSBvcHRpb25zLnByZWZpeC50ZXh0Q29udGVudDtcbiAgICAgIGlmIChvcHRpb25zLmRlc2MpIHNob3J0VGV4dCArPSBcIiBcIiArIG9wdGlvbnMuZGVzYztcbiAgICAgIG9wdGlvbnMub25DbG9zZT8uKHByb21wdChzaG9ydFRleHQsICcnKSk7XG4gICAgfVxuICB9XG5cbiAgLyoqIEBhcmcge1JlZ0V4cHx1bmtub3dufSByMSAgQGFyZyB7UmVnRXhwfHVua25vd259IHIyICovXG4gIGZ1bmN0aW9uIHJlZ2V4RXF1YWwocjEsIHIyKSB7XG4gICAgaWYgKHIxIGluc3RhbmNlb2YgUmVnRXhwICYmIHIyIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICByZXR1cm4gcjEuZmxhZ3MgPT0gcjIuZmxhZ3MgJiYgcjEuc291cmNlID09IHIyLnNvdXJjZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vIFJldHVybnMgdHJ1ZSBpZiB0aGUgcXVlcnkgaXMgdmFsaWQuXG4gIC8qKlxuICAgKiBAYXJnIHtDb2RlTWlycm9yVn0gY20gXG4gICAqIEBhcmcge3N0cmluZyB9IHJhd1F1ZXJ5IFxuICAgKiBAYXJnIHtib29sZWFuIHwgdW5kZWZpbmVkfSBbaWdub3JlQ2FzZV0gXG4gICAqIEBhcmcge2Jvb2xlYW4gfCB1bmRlZmluZWR9IFtzbWFydENhc2VdXG4gICovXG4gIGZ1bmN0aW9uIHVwZGF0ZVNlYXJjaFF1ZXJ5KGNtLCByYXdRdWVyeSwgaWdub3JlQ2FzZSwgc21hcnRDYXNlKSB7XG4gICAgaWYgKCFyYXdRdWVyeSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgc3RhdGUgPSBnZXRTZWFyY2hTdGF0ZShjbSk7XG4gICAgdmFyIHF1ZXJ5ID0gcGFyc2VRdWVyeShyYXdRdWVyeSwgISFpZ25vcmVDYXNlLCAhIXNtYXJ0Q2FzZSk7XG4gICAgaWYgKCFxdWVyeSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBoaWdobGlnaHRTZWFyY2hNYXRjaGVzKGNtLCBxdWVyeSk7XG4gICAgaWYgKHJlZ2V4RXF1YWwocXVlcnksIHN0YXRlLmdldFF1ZXJ5KCkpKSB7XG4gICAgICByZXR1cm4gcXVlcnk7XG4gICAgfVxuICAgIHN0YXRlLnNldFF1ZXJ5KHF1ZXJ5KTtcbiAgICByZXR1cm4gcXVlcnk7XG4gIH1cbiAgLyoqIEBhcmcge1JlZ0V4cH0gcXVlcnkgKi9cbiAgZnVuY3Rpb24gc2VhcmNoT3ZlcmxheShxdWVyeSkge1xuICAgIGlmIChxdWVyeS5zb3VyY2UuY2hhckF0KDApID09ICdeJykge1xuICAgICAgdmFyIG1hdGNoU29sID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHRva2VuOiBmdW5jdGlvbihzdHJlYW0pIHtcbiAgICAgICAgaWYgKG1hdGNoU29sICYmICFzdHJlYW0uc29sKCkpIHtcbiAgICAgICAgICBzdHJlYW0uc2tpcFRvRW5kKCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBtYXRjaCA9IHN0cmVhbS5tYXRjaChxdWVyeSwgZmFsc2UpO1xuICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICBpZiAobWF0Y2hbMF0ubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgIC8vIE1hdGNoZWQgZW1wdHkgc3RyaW5nLCBza2lwIHRvIG5leHQuXG4gICAgICAgICAgICBzdHJlYW0ubmV4dCgpO1xuICAgICAgICAgICAgcmV0dXJuICdzZWFyY2hpbmcnO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIXN0cmVhbS5zb2woKSkge1xuICAgICAgICAgICAgLy8gQmFja3RyYWNrIDEgdG8gbWF0Y2ggXFxiXG4gICAgICAgICAgICBzdHJlYW0uYmFja1VwKDEpO1xuICAgICAgICAgICAgaWYgKCFxdWVyeS5leGVjKHN0cmVhbS5uZXh0KCkgKyBtYXRjaFswXSkpIHtcbiAgICAgICAgICAgICAgc3RyZWFtLm5leHQoKTtcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHN0cmVhbS5tYXRjaChxdWVyeSk7XG4gICAgICAgICAgcmV0dXJuICdzZWFyY2hpbmcnO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlICghc3RyZWFtLmVvbCgpKSB7XG4gICAgICAgICAgc3RyZWFtLm5leHQoKTtcbiAgICAgICAgICBpZiAoc3RyZWFtLm1hdGNoKHF1ZXJ5LCBmYWxzZSkpIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgcXVlcnk6IHF1ZXJ5XG4gICAgfTtcbiAgfVxuICB2YXIgaGlnaGxpZ2h0VGltZW91dCA9IDA7XG4gIC8qKiBAYXJnIHtDb2RlTWlycm9yVn0gY20gIEBhcmcge1JlZ0V4cH0gcXVlcnkgKi9cbiAgZnVuY3Rpb24gaGlnaGxpZ2h0U2VhcmNoTWF0Y2hlcyhjbSwgcXVlcnkpIHtcbiAgICBjbGVhclRpbWVvdXQoaGlnaGxpZ2h0VGltZW91dCk7XG4gICAgdmFyIHNlYXJjaFN0YXRlID0gZ2V0U2VhcmNoU3RhdGUoY20pO1xuICAgIHNlYXJjaFN0YXRlLmhpZ2hsaWdodFRpbWVvdXQgPSBoaWdobGlnaHRUaW1lb3V0O1xuICAgIGhpZ2hsaWdodFRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKCFjbS5zdGF0ZS52aW0pIHJldHVybjtcbiAgICAgIHZhciBzZWFyY2hTdGF0ZSA9IGdldFNlYXJjaFN0YXRlKGNtKTtcbiAgICAgIHNlYXJjaFN0YXRlLmhpZ2hsaWdodFRpbWVvdXQgPSB1bmRlZmluZWQ7XG4gICAgICB2YXIgb3ZlcmxheSA9IHNlYXJjaFN0YXRlLmdldE92ZXJsYXkoKTtcbiAgICAgIGlmICghb3ZlcmxheSB8fCBxdWVyeSAhPSBvdmVybGF5LnF1ZXJ5KSB7XG4gICAgICAgIGlmIChvdmVybGF5KSB7XG4gICAgICAgICAgY20ucmVtb3ZlT3ZlcmxheShvdmVybGF5KTtcbiAgICAgICAgfVxuICAgICAgICBvdmVybGF5ID0gc2VhcmNoT3ZlcmxheShxdWVyeSk7XG4gICAgICAgIGNtLmFkZE92ZXJsYXkob3ZlcmxheSk7XG4gICAgICAgIGlmIChjbS5zaG93TWF0Y2hlc09uU2Nyb2xsYmFyKSB7XG4gICAgICAgICAgaWYgKHNlYXJjaFN0YXRlLmdldFNjcm9sbGJhckFubm90YXRlKCkpIHtcbiAgICAgICAgICAgIHNlYXJjaFN0YXRlLmdldFNjcm9sbGJhckFubm90YXRlKCkuY2xlYXIoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc2VhcmNoU3RhdGUuc2V0U2Nyb2xsYmFyQW5ub3RhdGUoY20uc2hvd01hdGNoZXNPblNjcm9sbGJhcihxdWVyeSkpO1xuICAgICAgICB9XG4gICAgICAgIHNlYXJjaFN0YXRlLnNldE92ZXJsYXkob3ZlcmxheSk7XG4gICAgICB9XG4gICAgfSwgNTApO1xuICB9XG4gIC8qKiBAYXJnIHtDb2RlTWlycm9yfSBjbSBAYXJnIHtib29sZWFufSBwcmV2IEBhcmcge1JlZ0V4cH0gcXVlcnkgQGFyZyB7bnVtYmVyIHwgdW5kZWZpbmVkfSBbcmVwZWF0XSAqL1xuICBmdW5jdGlvbiBmaW5kTmV4dChjbSwgcHJldiwgcXVlcnksIHJlcGVhdCkge1xuICAgIHJldHVybiBjbS5vcGVyYXRpb24oZnVuY3Rpb24oKSB7XG4gICAgICBpZiAocmVwZWF0ID09PSB1bmRlZmluZWQpIHsgcmVwZWF0ID0gMTsgfVxuICAgICAgdmFyIHBvcyA9IGNtLmdldEN1cnNvcigpO1xuICAgICAgdmFyIGN1cnNvciA9IGNtLmdldFNlYXJjaEN1cnNvcihxdWVyeSwgcG9zKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVwZWF0OyBpKyspIHtcbiAgICAgICAgdmFyIGZvdW5kID0gY3Vyc29yLmZpbmQocHJldik7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgaWYgKGkgPT0gMCAmJiBmb3VuZCAmJiBjdXJzb3JFcXVhbChjdXJzb3IuZnJvbSgpLCBwb3MpKSB7XG4gICAgICAgICAgdmFyIGxhc3RFbmRQb3MgPSBwcmV2ID8gY3Vyc29yLmZyb20oKSA6IGN1cnNvci50bygpO1xuICAgICAgICAgIGZvdW5kID0gY3Vyc29yLmZpbmQocHJldik7XG4gICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgIGlmIChmb3VuZCAmJiAhZm91bmRbMF0gJiYgY3Vyc29yRXF1YWwoY3Vyc29yLmZyb20oKSwgbGFzdEVuZFBvcykpIHtcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIGlmIChjbS5nZXRMaW5lKGxhc3RFbmRQb3MubGluZSkubGVuZ3RoID09IGxhc3RFbmRQb3MuY2gpXG4gICAgICAgICAgICAgIGZvdW5kID0gY3Vyc29yLmZpbmQocHJldik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghZm91bmQpIHtcbiAgICAgICAgICAvLyBTZWFyY2hDdXJzb3IgbWF5IGhhdmUgcmV0dXJuZWQgbnVsbCBiZWNhdXNlIGl0IGhpdCBFT0YsIHdyYXBcbiAgICAgICAgICAvLyBhcm91bmQgYW5kIHRyeSBhZ2Fpbi5cbiAgICAgICAgICBjdXJzb3IgPSBjbS5nZXRTZWFyY2hDdXJzb3IocXVlcnksXG4gICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgICAgKHByZXYpID8gbmV3IFBvcyhjbS5sYXN0TGluZSgpKSA6IG5ldyBQb3MoY20uZmlyc3RMaW5lKCksIDApICk7XG4gICAgICAgICAgaWYgKCFjdXJzb3IuZmluZChwcmV2KSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGN1cnNvci5mcm9tKCk7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFByZXR0eSBtdWNoIHRoZSBzYW1lIGFzIGBmaW5kTmV4dGAsIGV4Y2VwdCBmb3IgdGhlIGZvbGxvd2luZyBkaWZmZXJlbmNlczpcbiAgICpcbiAgICogMS4gQmVmb3JlIHN0YXJ0aW5nIHRoZSBzZWFyY2gsIG1vdmUgdG8gdGhlIHByZXZpb3VzIHNlYXJjaC4gVGhpcyB3YXkgaWYgb3VyIGN1cnNvciBpc1xuICAgKiBhbHJlYWR5IGluc2lkZSBhIG1hdGNoLCB3ZSBzaG91bGQgcmV0dXJuIHRoZSBjdXJyZW50IG1hdGNoLlxuICAgKiAyLiBSYXRoZXIgdGhhbiBvbmx5IHJldHVybmluZyB0aGUgY3Vyc29yJ3MgZnJvbSwgd2UgcmV0dXJuIHRoZSBjdXJzb3IncyBmcm9tIGFuZCB0byBhcyBhIHR1cGxlLlxuICAgKiBAYXJnIHtDb2RlTWlycm9yfSBjbVxuICAgKiBAYXJnIHtib29sZWFufSBwcmV2XG4gICAqIEBhcmcge1JlZ0V4cH0gcXVlcnlcbiAgICogQGFyZyB7bnVtYmVyIHwgdW5kZWZpbmVkfSByZXBlYXRcbiAgICogQGFyZyB7dmltU3RhdGV9IHZpbVxuICAgKiBAcmV0dXJucyB7W1BvcywgUG9zXSB8IHVuZGVmaW5lZH1cbiAgICovXG4gIGZ1bmN0aW9uIGZpbmROZXh0RnJvbUFuZFRvSW5jbHVzaXZlKGNtLCBwcmV2LCBxdWVyeSwgcmVwZWF0LCB2aW0pIHtcbiAgICByZXR1cm4gY20ub3BlcmF0aW9uKGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHJlcGVhdCA9PT0gdW5kZWZpbmVkKSB7IHJlcGVhdCA9IDE7IH1cbiAgICAgIHZhciBwb3MgPSBjbS5nZXRDdXJzb3IoKTtcbiAgICAgIHZhciBjdXJzb3IgPSBjbS5nZXRTZWFyY2hDdXJzb3IocXVlcnksIHBvcyk7XG5cbiAgICAgIC8vIEdvIGJhY2sgb25lIHJlc3VsdCB0byBlbnN1cmUgdGhhdCBpZiB0aGUgY3Vyc29yIGlzIGN1cnJlbnRseSBhIG1hdGNoLCB3ZSBrZWVwIGl0LlxuICAgICAgdmFyIGZvdW5kID0gY3Vyc29yLmZpbmQoIXByZXYpO1xuXG4gICAgICAvLyBJZiB3ZSBoYXZlbid0IG1vdmVkLCBnbyBiYWNrIG9uZSBtb3JlIChzaW1pbGFyIHRvIGlmIGk9PTAgbG9naWMgaW4gZmluZE5leHQpLlxuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgaWYgKCF2aW0udmlzdWFsTW9kZSAmJiBmb3VuZCAmJiBjdXJzb3JFcXVhbChjdXJzb3IuZnJvbSgpLCBwb3MpKSB7XG4gICAgICAgIGN1cnNvci5maW5kKCFwcmV2KTtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXBlYXQ7IGkrKykge1xuICAgICAgICBmb3VuZCA9IGN1cnNvci5maW5kKHByZXYpO1xuICAgICAgICBpZiAoIWZvdW5kKSB7XG4gICAgICAgICAgLy8gU2VhcmNoQ3Vyc29yIG1heSBoYXZlIHJldHVybmVkIG51bGwgYmVjYXVzZSBpdCBoaXQgRU9GLCB3cmFwXG4gICAgICAgICAgLy8gYXJvdW5kIGFuZCB0cnkgYWdhaW4uXG4gICAgICAgICAgY3Vyc29yID0gY20uZ2V0U2VhcmNoQ3Vyc29yKHF1ZXJ5LFxuICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAgIChwcmV2KSA/IG5ldyBQb3MoY20ubGFzdExpbmUoKSkgOiBuZXcgUG9zKGNtLmZpcnN0TGluZSgpLCAwKSApO1xuICAgICAgICAgIGlmICghY3Vyc29yLmZpbmQocHJldikpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciBmcm9tID0gY3Vyc29yLmZyb20oKTtcbiAgICAgIHZhciB0byA9IGN1cnNvci50bygpO1xuICAgICAgcmV0dXJuIGZyb20gJiYgdG8gJiYgW2Zyb20sIHRvXTtcbiAgICB9KTtcbiAgfVxuICAvKiogQGFyZyB7Q29kZU1pcnJvclZ9IGNtICovXG4gIGZ1bmN0aW9uIGNsZWFyU2VhcmNoSGlnaGxpZ2h0KGNtKSB7XG4gICAgdmFyIHN0YXRlID0gZ2V0U2VhcmNoU3RhdGUoY20pO1xuICAgIGlmIChzdGF0ZS5oaWdobGlnaHRUaW1lb3V0KSB7XG4gICAgICBjbGVhclRpbWVvdXQoc3RhdGUuaGlnaGxpZ2h0VGltZW91dCk7XG4gICAgICBzdGF0ZS5oaWdobGlnaHRUaW1lb3V0ID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBjbS5yZW1vdmVPdmVybGF5KGdldFNlYXJjaFN0YXRlKGNtKS5nZXRPdmVybGF5KCkpO1xuICAgIHN0YXRlLnNldE92ZXJsYXkobnVsbCk7XG4gICAgaWYgKHN0YXRlLmdldFNjcm9sbGJhckFubm90YXRlKCkpIHtcbiAgICAgIHN0YXRlLmdldFNjcm9sbGJhckFubm90YXRlKCkuY2xlYXIoKTtcbiAgICAgIHN0YXRlLnNldFNjcm9sbGJhckFubm90YXRlKG51bGwpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogQ2hlY2sgaWYgcG9zIGlzIGluIHRoZSBzcGVjaWZpZWQgcmFuZ2UsIElOQ0xVU0lWRS5cbiAgICogUmFuZ2UgY2FuIGJlIHNwZWNpZmllZCB3aXRoIDEgb3IgMiBhcmd1bWVudHMuXG4gICAqIElmIHRoZSBmaXJzdCByYW5nZSBhcmd1bWVudCBpcyBhbiBhcnJheSwgdHJlYXQgaXQgYXMgYW4gYXJyYXkgb2YgbGluZVxuICAgKiBudW1iZXJzLiBNYXRjaCBwb3MgYWdhaW5zdCBhbnkgb2YgdGhlIGxpbmVzLlxuICAgKiBJZiB0aGUgZmlyc3QgcmFuZ2UgYXJndW1lbnQgaXMgYSBudW1iZXIsXG4gICAqICAgaWYgdGhlcmUgaXMgb25seSAxIHJhbmdlIGFyZ3VtZW50LCBjaGVjayBpZiBwb3MgaGFzIHRoZSBzYW1lIGxpbmVcbiAgICogICAgICAgbnVtYmVyXG4gICAqICAgaWYgdGhlcmUgYXJlIDIgcmFuZ2UgYXJndW1lbnRzLCB0aGVuIGNoZWNrIGlmIHBvcyBpcyBpbiBiZXR3ZWVuIHRoZSB0d29cbiAgICogICAgICAgcmFuZ2UgYXJndW1lbnRzLlxuICAgKiBAYXJnIHtudW1iZXJ8UG9zfSBwb3NcbiAgICogQGFyZyB7bnVtYmVyfG51bWJlcltdfSBzdGFydFxuICAgKiBAYXJnIHtudW1iZXJ9IGVuZFxuICAgKi9cbiAgZnVuY3Rpb24gaXNJblJhbmdlKHBvcywgc3RhcnQsIGVuZCkge1xuICAgIGlmICh0eXBlb2YgcG9zICE9ICdudW1iZXInKSB7XG4gICAgICAvLyBBc3N1bWUgaXQgaXMgYSBjdXJzb3IgcG9zaXRpb24uIEdldCB0aGUgbGluZSBudW1iZXIuXG4gICAgICBwb3MgPSBwb3MubGluZTtcbiAgICB9XG4gICAgaWYgKHN0YXJ0IGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgIHJldHVybiBpbkFycmF5KHBvcywgc3RhcnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodHlwZW9mIGVuZCA9PSAnbnVtYmVyJykge1xuICAgICAgICByZXR1cm4gKHBvcyA+PSBzdGFydCAmJiBwb3MgPD0gZW5kKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBwb3MgPT0gc3RhcnQ7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qKiBAYXJnIHtDb2RlTWlycm9yfSBjbSAqL1xuICBmdW5jdGlvbiBnZXRVc2VyVmlzaWJsZUxpbmVzKGNtKSB7XG4gICAgdmFyIHNjcm9sbEluZm8gPSBjbS5nZXRTY3JvbGxJbmZvKCk7XG4gICAgdmFyIG9jY2x1ZGVUb2xlcmFuY2VUb3AgPSA2O1xuICAgIHZhciBvY2NsdWRlVG9sZXJhbmNlQm90dG9tID0gMTA7XG4gICAgdmFyIGZyb20gPSBjbS5jb29yZHNDaGFyKHtsZWZ0OjAsIHRvcDogb2NjbHVkZVRvbGVyYW5jZVRvcCArIHNjcm9sbEluZm8udG9wfSwgJ2xvY2FsJyk7XG4gICAgdmFyIGJvdHRvbVkgPSBzY3JvbGxJbmZvLmNsaWVudEhlaWdodCAtIG9jY2x1ZGVUb2xlcmFuY2VCb3R0b20gKyBzY3JvbGxJbmZvLnRvcDtcbiAgICB2YXIgdG8gPSBjbS5jb29yZHNDaGFyKHtsZWZ0OjAsIHRvcDogYm90dG9tWX0sICdsb2NhbCcpO1xuICAgIHJldHVybiB7dG9wOiBmcm9tLmxpbmUsIGJvdHRvbTogdG8ubGluZX07XG4gIH1cblxuICAvKiogQGFyZyB7Q29kZU1pcnJvcn0gY20gQGFyZyB7dmltU3RhdGV9IHZpbSAgQGFyZyB7c3RyaW5nfSBtYXJrTmFtZSAqL1xuICBmdW5jdGlvbiBnZXRNYXJrUG9zKGNtLCB2aW0sIG1hcmtOYW1lKSB7XG4gICAgaWYgKG1hcmtOYW1lID09ICdcXCcnIHx8IG1hcmtOYW1lID09ICdgJykge1xuICAgICAgcmV0dXJuIHZpbUdsb2JhbFN0YXRlLmp1bXBMaXN0LmZpbmQoY20sIC0xKSB8fCBuZXcgUG9zKDAsIDApO1xuICAgIH0gZWxzZSBpZiAobWFya05hbWUgPT0gJy4nKSB7XG4gICAgICByZXR1cm4gZ2V0TGFzdEVkaXRQb3MoY20pO1xuICAgIH1cblxuICAgIHZhciBtYXJrID0gdmltLm1hcmtzW21hcmtOYW1lXTtcbiAgICByZXR1cm4gbWFyayAmJiBtYXJrLmZpbmQoKTtcbiAgfVxuXG4gIC8qKiBAYXJnIHtDb2RlTWlycm9yfSBjbSAqL1xuICBmdW5jdGlvbiBnZXRMYXN0RWRpdFBvcyhjbSkge1xuICAgIGlmIChjbS5nZXRMYXN0RWRpdEVuZCkge1xuICAgICAgcmV0dXJuIGNtLmdldExhc3RFZGl0RW5kKCk7XG4gICAgfVxuICAgIC8vIGZvciBvbGQgY21cbiAgICB2YXIgZG9uZSA9IC8qKkB0eXBle2FueX0qLyhjbSkuZG9jLmhpc3RvcnkuZG9uZTtcbiAgICBmb3IgKHZhciBpID0gZG9uZS5sZW5ndGg7IGktLTspIHtcbiAgICAgIGlmIChkb25lW2ldLmNoYW5nZXMpIHtcbiAgICAgICAgcmV0dXJuIGNvcHlDdXJzb3IoZG9uZVtpXS5jaGFuZ2VzWzBdLnRvKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBjbGFzcyBFeENvbW1hbmREaXNwYXRjaGVyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgIC8qKkB0eXBlIHtSZWNvcmQ8c3RyaW5nLCBpbXBvcnQoXCIuL3R5cGVzXCIpLmV4Q29tbWFuZERlZmluaXRpb24+fSAqL1xuICAgICAgdGhpcy5jb21tYW5kTWFwXztcbiAgICAgIHRoaXMuYnVpbGRDb21tYW5kTWFwXygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAYXJnIHtDb2RlTWlycm9yVn0gY21cbiAgICAgKiBAYXJnIHtzdHJpbmd9IGlucHV0XG4gICAgICogQGFyZyB7eyBjYWxsYmFjazogKCkgPT4gdm9pZDsgfSB8IHVuZGVmaW5lZH0gW29wdF9wYXJhbXNdXG4gICAgICovXG4gICAgcHJvY2Vzc0NvbW1hbmQoY20sIGlucHV0LCBvcHRfcGFyYW1zKSB7XG4gICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICBjbS5vcGVyYXRpb24oZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoY20uY3VyT3ApIGNtLmN1ck9wLmlzVmltT3AgPSB0cnVlO1xuICAgICAgICB0aGF0Ll9wcm9jZXNzQ29tbWFuZChjbSwgaW5wdXQsIG9wdF9wYXJhbXMpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBhcmcge0NvZGVNaXJyb3JWfSBjbVxuICAgICAqIEBhcmcge3N0cmluZ30gaW5wdXRcbiAgICAgKiBAYXJnIHt7IGNhbGxiYWNrPzogKCkgPT4gdm9pZDsgaW5wdXQ/OiBzdHJpbmcsIGxpbmU/OiBzdHJpbmcsIGNvbW1hbmROYW1lPzogc3RyaW5nICB9IH0gW29wdF9wYXJhbXNdXG4gICAgICovXG4gICAgX3Byb2Nlc3NDb21tYW5kKGNtLCBpbnB1dCwgb3B0X3BhcmFtcykge1xuICAgICAgdmFyIHZpbSA9IGNtLnN0YXRlLnZpbTtcbiAgICAgIHZhciBjb21tYW5kSGlzdG9yeVJlZ2lzdGVyID0gdmltR2xvYmFsU3RhdGUucmVnaXN0ZXJDb250cm9sbGVyLmdldFJlZ2lzdGVyKCc6Jyk7XG4gICAgICB2YXIgcHJldmlvdXNDb21tYW5kID0gY29tbWFuZEhpc3RvcnlSZWdpc3Rlci50b1N0cmluZygpO1xuICAgICAgdmFyIGlucHV0U3RyZWFtID0gbmV3IENNLlN0cmluZ1N0cmVhbShpbnB1dCk7XG4gICAgICAvLyB1cGRhdGUgXCI6IHdpdGggdGhlIGxhdGVzdCBjb21tYW5kIHdoZXRoZXIgdmFsaWQgb3IgaW52YWxpZFxuICAgICAgY29tbWFuZEhpc3RvcnlSZWdpc3Rlci5zZXRUZXh0KGlucHV0KTtcbiAgICAgIHZhciBwYXJhbXMgPSBvcHRfcGFyYW1zIHx8IHt9O1xuICAgICAgcGFyYW1zLmlucHV0ID0gaW5wdXQ7XG4gICAgICB0cnkge1xuICAgICAgICB0aGlzLnBhcnNlSW5wdXRfKGNtLCBpbnB1dFN0cmVhbSwgcGFyYW1zKTtcbiAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICBzaG93Q29uZmlybShjbSwgZSArIFwiXCIpO1xuICAgICAgICB0aHJvdyBlO1xuICAgICAgfVxuXG4gICAgICBpZiAodmltLnZpc3VhbE1vZGUpIHtcbiAgICAgICAgZXhpdFZpc3VhbE1vZGUoY20pO1xuICAgICAgfVxuXG4gICAgICB2YXIgY29tbWFuZDtcbiAgICAgIHZhciBjb21tYW5kTmFtZTtcbiAgICAgIGlmICghcGFyYW1zLmNvbW1hbmROYW1lKSB7XG4gICAgICAgIC8vIElmIG9ubHkgYSBsaW5lIHJhbmdlIGlzIGRlZmluZWQsIG1vdmUgdG8gdGhlIGxpbmUuXG4gICAgICAgIGlmIChwYXJhbXMubGluZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgY29tbWFuZE5hbWUgPSAnbW92ZSc7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbW1hbmQgPSB0aGlzLm1hdGNoQ29tbWFuZF8ocGFyYW1zLmNvbW1hbmROYW1lKTtcbiAgICAgICAgaWYgKGNvbW1hbmQpIHtcbiAgICAgICAgICBjb21tYW5kTmFtZSA9IGNvbW1hbmQubmFtZTtcbiAgICAgICAgICBpZiAoY29tbWFuZC5leGNsdWRlRnJvbUNvbW1hbmRIaXN0b3J5KSB7XG4gICAgICAgICAgICBjb21tYW5kSGlzdG9yeVJlZ2lzdGVyLnNldFRleHQocHJldmlvdXNDb21tYW5kKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5wYXJzZUNvbW1hbmRBcmdzXyhpbnB1dFN0cmVhbSwgcGFyYW1zLCBjb21tYW5kKTtcbiAgICAgICAgICBpZiAoY29tbWFuZC50eXBlID09ICdleFRvS2V5Jykge1xuICAgICAgICAgICAgLy8gSGFuZGxlIEV4IHRvIEtleSBtYXBwaW5nLlxuICAgICAgICAgICAgZG9LZXlUb0tleShjbSwgY29tbWFuZC50b0tleXMgfHwgJycsIGNvbW1hbmQpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH0gZWxzZSBpZiAoY29tbWFuZC50eXBlID09ICdleFRvRXgnKSB7XG4gICAgICAgICAgICAvLyBIYW5kbGUgRXggdG8gRXggbWFwcGluZy5cbiAgICAgICAgICAgIHRoaXMucHJvY2Vzc0NvbW1hbmQoY20sIGNvbW1hbmQudG9JbnB1dCB8fCAnJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIWNvbW1hbmROYW1lKSB7XG4gICAgICAgIHNob3dDb25maXJtKGNtLCAnTm90IGFuIGVkaXRvciBjb21tYW5kIFwiOicgKyBpbnB1dCArICdcIicpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0cnkge1xuICAgICAgICBleENvbW1hbmRzW2NvbW1hbmROYW1lXShjbSwgcGFyYW1zKTtcbiAgICAgICAgLy8gUG9zc2libHkgYXN5bmNocm9ub3VzIGNvbW1hbmRzIChlLmcuIHN1YnN0aXR1dGUsIHdoaWNoIG1pZ2h0IGhhdmUgYVxuICAgICAgICAvLyB1c2VyIGNvbmZpcm1hdGlvbiksIGFyZSByZXNwb25zaWJsZSBmb3IgY2FsbGluZyB0aGUgY2FsbGJhY2sgd2hlblxuICAgICAgICAvLyBkb25lLiBBbGwgb3RoZXJzIGhhdmUgaXQgdGFrZW4gY2FyZSBvZiBmb3IgdGhlbSBoZXJlLlxuICAgICAgICBpZiAoKCFjb21tYW5kIHx8ICFjb21tYW5kLnBvc3NpYmx5QXN5bmMpICYmIHBhcmFtcy5jYWxsYmFjaykge1xuICAgICAgICAgIHBhcmFtcy5jYWxsYmFjaygpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgc2hvd0NvbmZpcm0oY20sIGUgKyBcIlwiKTtcbiAgICAgICAgdGhyb3cgZTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtDb2RlTWlycm9yVn0gY21cbiAgICAgKiBAcGFyYW0ge2ltcG9ydChcIkBjb2RlbWlycm9yL2xhbmd1YWdlXCIpLlN0cmluZ1N0cmVhbX0gaW5wdXRTdHJlYW1cbiAgICAgKiBAcGFyYW0ge3sgY2FsbGJhY2s/OiAoKCkgPT4gdm9pZCkgfCB1bmRlZmluZWQ7IGlucHV0Pzogc3RyaW5nIHwgdW5kZWZpbmVkOyBsaW5lPzogYW55OyBjb21tYW5kTmFtZT86IGFueTsgbGluZUVuZD86IGFueTsgc2VsZWN0aW9uTGluZT86IGFueTsgc2VsZWN0aW9uTGluZUVuZD86IGFueTsgfX0gcmVzdWx0XG4gICAgICovXG4gICAgcGFyc2VJbnB1dF8oY20sIGlucHV0U3RyZWFtLCByZXN1bHQpIHtcbiAgICAgIGlucHV0U3RyZWFtLmVhdFdoaWxlKCc6Jyk7XG4gICAgICAvLyBQYXJzZSByYW5nZS5cbiAgICAgIGlmIChpbnB1dFN0cmVhbS5lYXQoJyUnKSkge1xuICAgICAgICByZXN1bHQubGluZSA9IGNtLmZpcnN0TGluZSgpO1xuICAgICAgICByZXN1bHQubGluZUVuZCA9IGNtLmxhc3RMaW5lKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHQubGluZSA9IHRoaXMucGFyc2VMaW5lU3BlY18oY20sIGlucHV0U3RyZWFtKTtcbiAgICAgICAgaWYgKHJlc3VsdC5saW5lICE9PSB1bmRlZmluZWQgJiYgaW5wdXRTdHJlYW0uZWF0KCcsJykpIHtcbiAgICAgICAgICByZXN1bHQubGluZUVuZCA9IHRoaXMucGFyc2VMaW5lU3BlY18oY20sIGlucHV0U3RyZWFtKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAocmVzdWx0LmxpbmUgPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChjbS5zdGF0ZS52aW0udmlzdWFsTW9kZSkge1xuICAgICAgICAgIHJlc3VsdC5zZWxlY3Rpb25MaW5lID0gZ2V0TWFya1BvcyhjbSwgY20uc3RhdGUudmltLCAnPCcpPy5saW5lO1xuICAgICAgICAgIHJlc3VsdC5zZWxlY3Rpb25MaW5lRW5kID0gZ2V0TWFya1BvcyhjbSwgY20uc3RhdGUudmltLCAnPicpPy5saW5lO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdC5zZWxlY3Rpb25MaW5lID0gY20uZ2V0Q3Vyc29yKCkubGluZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0LnNlbGVjdGlvbkxpbmUgPSByZXN1bHQubGluZTtcbiAgICAgICAgcmVzdWx0LnNlbGVjdGlvbkxpbmVFbmQgPSByZXN1bHQubGluZUVuZDtcbiAgICAgIH1cblxuICAgICAgLy8gUGFyc2UgY29tbWFuZCBuYW1lLlxuICAgICAgdmFyIGNvbW1hbmRNYXRjaCA9IGlucHV0U3RyZWFtLm1hdGNoKC9eKFxcdyt8ISF8QEB8WyEjJio8PT5Afl0pLyk7XG4gICAgICBpZiAoY29tbWFuZE1hdGNoKSB7XG4gICAgICAgIHJlc3VsdC5jb21tYW5kTmFtZSA9IGNvbW1hbmRNYXRjaFsxXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdC5jb21tYW5kTmFtZSA9IChpbnB1dFN0cmVhbS5tYXRjaCgvLiovKSB8fCBbXCJcIl0pWzBdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0NvZGVNaXJyb3JWfSBjbVxuICAgICAqIEBwYXJhbSB7aW1wb3J0KFwiQGNvZGVtaXJyb3IvbGFuZ3VhZ2VcIikuU3RyaW5nU3RyZWFtfSBpbnB1dFN0cmVhbVxuICAgICAqL1xuICAgIHBhcnNlTGluZVNwZWNfKGNtLCBpbnB1dFN0cmVhbSkge1xuICAgICAgdmFyIG51bWJlck1hdGNoID0gaW5wdXRTdHJlYW0ubWF0Y2goL14oXFxkKykvKTtcbiAgICAgIGlmIChudW1iZXJNYXRjaCkge1xuICAgICAgICAvLyBBYnNvbHV0ZSBsaW5lIG51bWJlciBwbHVzIG9mZnNldCAoTitNIG9yIE4tTSkgaXMgcHJvYmFibHkgYSB0eXBvLFxuICAgICAgICAvLyBub3Qgc29tZXRoaW5nIHRoZSB1c2VyIGFjdHVhbGx5IHdhbnRlZC4gKE5COiB2aW0gZG9lcyBhbGxvdyB0aGlzLilcbiAgICAgICAgcmV0dXJuIHBhcnNlSW50KG51bWJlck1hdGNoWzFdLCAxMCkgLSAxO1xuICAgICAgfVxuICAgICAgc3dpdGNoIChpbnB1dFN0cmVhbS5uZXh0KCkpIHtcbiAgICAgICAgY2FzZSAnLic6XG4gICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VMaW5lU3BlY09mZnNldF8oaW5wdXRTdHJlYW0sIGNtLmdldEN1cnNvcigpLmxpbmUpO1xuICAgICAgICBjYXNlICckJzpcbiAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUxpbmVTcGVjT2Zmc2V0XyhpbnB1dFN0cmVhbSwgY20ubGFzdExpbmUoKSk7XG4gICAgICAgIGNhc2UgJ1xcJyc6XG4gICAgICAgICAgdmFyIG1hcmtOYW1lID0gaW5wdXRTdHJlYW0ubmV4dCgpIHx8IFwiXCI7XG4gICAgICAgICAgdmFyIG1hcmtQb3MgPSBnZXRNYXJrUG9zKGNtLCBjbS5zdGF0ZS52aW0sIG1hcmtOYW1lKTtcbiAgICAgICAgICBpZiAoIW1hcmtQb3MpIHRocm93IG5ldyBFcnJvcignTWFyayBub3Qgc2V0Jyk7XG4gICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VMaW5lU3BlY09mZnNldF8oaW5wdXRTdHJlYW0sIG1hcmtQb3MubGluZSk7XG4gICAgICAgIGNhc2UgJy0nOlxuICAgICAgICBjYXNlICcrJzpcbiAgICAgICAgICBpbnB1dFN0cmVhbS5iYWNrVXAoMSk7XG4gICAgICAgICAgLy8gT2Zmc2V0IGlzIHJlbGF0aXZlIHRvIGN1cnJlbnQgbGluZSBpZiBub3Qgb3RoZXJ3aXNlIHNwZWNpZmllZC5cbiAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUxpbmVTcGVjT2Zmc2V0XyhpbnB1dFN0cmVhbSwgY20uZ2V0Q3Vyc29yKCkubGluZSk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgaW5wdXRTdHJlYW0uYmFja1VwKDEpO1xuICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nIHwgaW1wb3J0KFwiQGNvZGVtaXJyb3IvbGFuZ3VhZ2VcIikuU3RyaW5nU3RyZWFtfSBpbnB1dFN0cmVhbVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsaW5lXG4gICAgICovXG4gICAgcGFyc2VMaW5lU3BlY09mZnNldF8oaW5wdXRTdHJlYW0sIGxpbmUpIHtcbiAgICAgIHZhciBvZmZzZXRNYXRjaCA9IGlucHV0U3RyZWFtLm1hdGNoKC9eKFsrLV0pPyhcXGQrKS8pO1xuICAgICAgaWYgKG9mZnNldE1hdGNoKSB7XG4gICAgICAgIHZhciBvZmZzZXQgPSBwYXJzZUludChvZmZzZXRNYXRjaFsyXSwgMTApO1xuICAgICAgICBpZiAob2Zmc2V0TWF0Y2hbMV0gPT0gXCItXCIpIHtcbiAgICAgICAgICBsaW5lIC09IG9mZnNldDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsaW5lICs9IG9mZnNldDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGxpbmU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7aW1wb3J0KFwiQGNvZGVtaXJyb3IvbGFuZ3VhZ2VcIikuU3RyaW5nU3RyZWFtfSBpbnB1dFN0cmVhbVxuICAgICAqIEBwYXJhbSB7aW1wb3J0KFwiLi90eXBlc1wiKS5leENvbW1hbmRBcmdzfSBwYXJhbXNcbiAgICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vdHlwZXNcIikuZXhDb21tYW5kRGVmaW5pdGlvbn0gY29tbWFuZFxuICAgICAqL1xuICAgIHBhcnNlQ29tbWFuZEFyZ3NfKGlucHV0U3RyZWFtLCBwYXJhbXMsIGNvbW1hbmQpIHtcbiAgICAgIGlmIChpbnB1dFN0cmVhbS5lb2woKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBwYXJhbXMuYXJnU3RyaW5nID0gaW5wdXRTdHJlYW0ubWF0Y2goLy4qLyk/LlswXTtcbiAgICAgIC8vIFBhcnNlIGNvbW1hbmQtbGluZSBhcmd1bWVudHNcbiAgICAgIHZhciBkZWxpbSA9IGNvbW1hbmQuYXJnRGVsaW1pdGVyIHx8IC9cXHMrLztcbiAgICAgIHZhciBhcmdzID0gdHJpbShwYXJhbXMuYXJnU3RyaW5nIHx8IFwiXCIpLnNwbGl0KGRlbGltKTtcbiAgICAgIGlmIChhcmdzLmxlbmd0aCAmJiBhcmdzWzBdKSB7XG4gICAgICAgIHBhcmFtcy5hcmdzID0gYXJncztcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQGFyZyB7c3RyaW5nfSBjb21tYW5kTmFtZVxuICAgICAqL1xuICAgIG1hdGNoQ29tbWFuZF8oY29tbWFuZE5hbWUpIHtcbiAgICAgIC8vIFJldHVybiB0aGUgY29tbWFuZCBpbiB0aGUgY29tbWFuZCBtYXAgdGhhdCBtYXRjaGVzIHRoZSBzaG9ydGVzdFxuICAgICAgLy8gcHJlZml4IG9mIHRoZSBwYXNzZWQgaW4gY29tbWFuZCBuYW1lLiBUaGUgbWF0Y2ggaXMgZ3VhcmFudGVlZCB0byBiZVxuICAgICAgLy8gdW5hbWJpZ3VvdXMgaWYgdGhlIGRlZmF1bHRFeENvbW1hbmRNYXAncyBzaG9ydE5hbWVzIGFyZSBzZXQgdXBcbiAgICAgIC8vIGNvcnJlY3RseS4gKHNlZSBAY29kZXtkZWZhdWx0RXhDb21tYW5kTWFwfSkuXG4gICAgICBmb3IgKHZhciBpID0gY29tbWFuZE5hbWUubGVuZ3RoOyBpID4gMDsgaS0tKSB7XG4gICAgICAgIHZhciBwcmVmaXggPSBjb21tYW5kTmFtZS5zdWJzdHJpbmcoMCwgaSk7XG4gICAgICAgIGlmICh0aGlzLmNvbW1hbmRNYXBfW3ByZWZpeF0pIHtcbiAgICAgICAgICB2YXIgY29tbWFuZCA9IHRoaXMuY29tbWFuZE1hcF9bcHJlZml4XTtcbiAgICAgICAgICBpZiAoY29tbWFuZC5uYW1lLmluZGV4T2YoY29tbWFuZE5hbWUpID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gY29tbWFuZDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgYnVpbGRDb21tYW5kTWFwXygpIHtcbiAgICAgIHRoaXMuY29tbWFuZE1hcF8gPSB7fTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGVmYXVsdEV4Q29tbWFuZE1hcC5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY29tbWFuZCA9IGRlZmF1bHRFeENvbW1hbmRNYXBbaV07XG4gICAgICAgIHZhciBrZXkgPSBjb21tYW5kLnNob3J0TmFtZSB8fCBjb21tYW5kLm5hbWU7XG4gICAgICAgIHRoaXMuY29tbWFuZE1hcF9ba2V5XSA9IGNvbW1hbmQ7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKkB0eXBlIHsobGhzOiBzdHJpbmcsIHJoczogc3RyaW5nLCBjdHg6IHN0cmluZ3x2b2lkLCBub3JlbWFwPzogYm9vbGVhbikgPT4gdm9pZH0gKi9cbiAgICBtYXAobGhzLCByaHMsIGN0eCwgbm9yZW1hcCkge1xuICAgICAgaWYgKGxocyAhPSAnOicgJiYgbGhzLmNoYXJBdCgwKSA9PSAnOicpIHtcbiAgICAgICAgaWYgKGN0eCkgeyB0aHJvdyBFcnJvcignTW9kZSBub3Qgc3VwcG9ydGVkIGZvciBleCBtYXBwaW5ncycpOyB9XG4gICAgICAgIHZhciBjb21tYW5kTmFtZSA9IGxocy5zdWJzdHJpbmcoMSk7XG4gICAgICAgIGlmIChyaHMgIT0gJzonICYmIHJocy5jaGFyQXQoMCkgPT0gJzonKSB7XG4gICAgICAgICAgLy8gRXggdG8gRXggbWFwcGluZ1xuICAgICAgICAgIHRoaXMuY29tbWFuZE1hcF9bY29tbWFuZE5hbWVdID0ge1xuICAgICAgICAgICAgbmFtZTogY29tbWFuZE5hbWUsXG4gICAgICAgICAgICB0eXBlOiAnZXhUb0V4JyxcbiAgICAgICAgICAgIHRvSW5wdXQ6IHJocy5zdWJzdHJpbmcoMSksXG4gICAgICAgICAgICB1c2VyOiB0cnVlXG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBFeCB0byBrZXkgbWFwcGluZ1xuICAgICAgICAgIHRoaXMuY29tbWFuZE1hcF9bY29tbWFuZE5hbWVdID0ge1xuICAgICAgICAgICAgbmFtZTogY29tbWFuZE5hbWUsXG4gICAgICAgICAgICB0eXBlOiAnZXhUb0tleScsXG4gICAgICAgICAgICB0b0tleXM6IHJocyxcbiAgICAgICAgICAgIHVzZXI6IHRydWVcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBLZXkgdG8ga2V5IG9yIGV4IG1hcHBpbmdcbiAgICAgICAgLyoqQHR5cGUge3ZpbUtleX0gKi9cbiAgICAgICAgdmFyIG1hcHBpbmcgPSB7XG4gICAgICAgICAga2V5czogbGhzLFxuICAgICAgICAgIHR5cGU6ICdrZXlUb0tleScsXG4gICAgICAgICAgdG9LZXlzOiByaHMsXG4gICAgICAgICAgbm9yZW1hcDogISFub3JlbWFwXG4gICAgICAgIH07XG4gICAgICAgIGlmIChjdHgpIHsgbWFwcGluZy5jb250ZXh0ID0gY3R4OyB9XG4gICAgICAgIF9tYXBDb21tYW5kKG1hcHBpbmcpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipAdHlwZSB7KGxoczogc3RyaW5nLCBjdHg6IHN0cmluZykgPT4gYm9vbGVhbnx2b2lkfSAqL1xuICAgIHVubWFwKGxocywgY3R4KSB7XG4gICAgICBpZiAobGhzICE9ICc6JyAmJiBsaHMuY2hhckF0KDApID09ICc6Jykge1xuICAgICAgICAvLyBFeCB0byBFeCBvciBFeCB0byBrZXkgbWFwcGluZ1xuICAgICAgICBpZiAoY3R4KSB7IHRocm93IEVycm9yKCdNb2RlIG5vdCBzdXBwb3J0ZWQgZm9yIGV4IG1hcHBpbmdzJyk7IH1cbiAgICAgICAgdmFyIGNvbW1hbmROYW1lID0gbGhzLnN1YnN0cmluZygxKTtcbiAgICAgICAgaWYgKHRoaXMuY29tbWFuZE1hcF9bY29tbWFuZE5hbWVdICYmIHRoaXMuY29tbWFuZE1hcF9bY29tbWFuZE5hbWVdLnVzZXIpIHtcbiAgICAgICAgICBkZWxldGUgdGhpcy5jb21tYW5kTWFwX1tjb21tYW5kTmFtZV07XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEtleSB0byBFeCBvciBrZXkgdG8ga2V5IG1hcHBpbmdcbiAgICAgICAgdmFyIGtleXMgPSBsaHM7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGVmYXVsdEtleW1hcC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmIChrZXlzID09IGRlZmF1bHRLZXltYXBbaV0ua2V5c1xuICAgICAgICAgICAgICAmJiBkZWZhdWx0S2V5bWFwW2ldLmNvbnRleHQgPT09IGN0eCkge1xuICAgICAgICAgICAgZGVmYXVsdEtleW1hcC5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICByZW1vdmVVc2VkS2V5cyhrZXlzKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKiBAdHlwZWRlZiB7IGltcG9ydChcIi4vdHlwZXNcIikuRXhQYXJhbXN9IEV4UGFyYW1zICovXG4gIHZhciBleENvbW1hbmRzID0ge1xuICAgIC8qKiBAYXJnIHtDb2RlTWlycm9yVn0gY20gQGFyZyB7RXhQYXJhbXN9IHBhcmFtcyovXG4gICAgY29sb3JzY2hlbWU6IGZ1bmN0aW9uKGNtLCBwYXJhbXMpIHtcbiAgICAgIGlmICghcGFyYW1zLmFyZ3MgfHwgcGFyYW1zLmFyZ3MubGVuZ3RoIDwgMSkge1xuICAgICAgICBzaG93Q29uZmlybShjbSwgY20uZ2V0T3B0aW9uKCd0aGVtZScpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY20uc2V0T3B0aW9uKCd0aGVtZScsIHBhcmFtcy5hcmdzWzBdKTtcbiAgICB9LFxuICAgIC8qKiBAYXJnIHtDb2RlTWlycm9yVn0gY20gQGFyZyB7RXhQYXJhbXN9IHBhcmFtcyBAYXJnIHsnaW5zZXJ0J3wnbm9ybWFsJ3xzdHJpbmd9IFtjdHhdIEBhcmcge2Jvb2xlYW59IFtkZWZhdWx0T25seV0qL1xuICAgIG1hcDogZnVuY3Rpb24oY20sIHBhcmFtcywgY3R4LCBkZWZhdWx0T25seSkge1xuICAgICAgdmFyIG1hcEFyZ3MgPSBwYXJhbXMuYXJncztcbiAgICAgIGlmICghbWFwQXJncyB8fCBtYXBBcmdzLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgaWYgKGNtKSB7XG4gICAgICAgICAgc2hvd0NvbmZpcm0oY20sICdJbnZhbGlkIG1hcHBpbmc6ICcgKyBwYXJhbXMuaW5wdXQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGV4Q29tbWFuZERpc3BhdGNoZXIubWFwKG1hcEFyZ3NbMF0sIG1hcEFyZ3NbMV0sIGN0eCwgZGVmYXVsdE9ubHkpO1xuICAgIH0sXG4gICAgLyoqIEBhcmcge0NvZGVNaXJyb3JWfSBjbSBAYXJnIHtFeFBhcmFtc30gcGFyYW1zKi9cbiAgICBpbWFwOiBmdW5jdGlvbihjbSwgcGFyYW1zKSB7IHRoaXMubWFwKGNtLCBwYXJhbXMsICdpbnNlcnQnKTsgfSxcbiAgICAvKiogQGFyZyB7Q29kZU1pcnJvclZ9IGNtIEBhcmcge0V4UGFyYW1zfSBwYXJhbXMqL1xuICAgIG5tYXA6IGZ1bmN0aW9uKGNtLCBwYXJhbXMpIHsgdGhpcy5tYXAoY20sIHBhcmFtcywgJ25vcm1hbCcpOyB9LFxuICAgIC8qKiBAYXJnIHtDb2RlTWlycm9yVn0gY20gQGFyZyB7RXhQYXJhbXN9IHBhcmFtcyovXG4gICAgdm1hcDogZnVuY3Rpb24oY20sIHBhcmFtcykgeyB0aGlzLm1hcChjbSwgcGFyYW1zLCAndmlzdWFsJyk7IH0sXG4gICAgLyoqIEBhcmcge0NvZGVNaXJyb3JWfSBjbSBAYXJnIHtFeFBhcmFtc30gcGFyYW1zKi9cbiAgICBvbWFwOiBmdW5jdGlvbihjbSwgcGFyYW1zKSB7IHRoaXMubWFwKGNtLCBwYXJhbXMsICdvcGVyYXRvclBlbmRpbmcnKTsgfSxcbiAgICAvKiogQGFyZyB7Q29kZU1pcnJvclZ9IGNtIEBhcmcge0V4UGFyYW1zfSBwYXJhbXMqL1xuICAgIG5vcmVtYXA6IGZ1bmN0aW9uKGNtLCBwYXJhbXMpIHsgdGhpcy5tYXAoY20sIHBhcmFtcywgdW5kZWZpbmVkLCB0cnVlKTsgfSxcbiAgICAvKiogQGFyZyB7Q29kZU1pcnJvclZ9IGNtIEBhcmcge0V4UGFyYW1zfSBwYXJhbXMqL1xuICAgIGlub3JlbWFwOiBmdW5jdGlvbihjbSwgcGFyYW1zKSB7IHRoaXMubWFwKGNtLCBwYXJhbXMsICdpbnNlcnQnLCB0cnVlKTsgfSxcbiAgICAvKiogQGFyZyB7Q29kZU1pcnJvclZ9IGNtIEBhcmcge0V4UGFyYW1zfSBwYXJhbXMqL1xuICAgIG5ub3JlbWFwOiBmdW5jdGlvbihjbSwgcGFyYW1zKSB7IHRoaXMubWFwKGNtLCBwYXJhbXMsICdub3JtYWwnLCB0cnVlKTsgfSxcbiAgICAvKiogQGFyZyB7Q29kZU1pcnJvclZ9IGNtIEBhcmcge0V4UGFyYW1zfSBwYXJhbXMqL1xuICAgIHZub3JlbWFwOiBmdW5jdGlvbihjbSwgcGFyYW1zKSB7IHRoaXMubWFwKGNtLCBwYXJhbXMsICd2aXN1YWwnLCB0cnVlKTsgfSxcbiAgICAvKiogQGFyZyB7Q29kZU1pcnJvclZ9IGNtIEBhcmcge0V4UGFyYW1zfSBwYXJhbXMqL1xuICAgIG9ub3JlbWFwOiBmdW5jdGlvbihjbSwgcGFyYW1zKSB7IHRoaXMubWFwKGNtLCBwYXJhbXMsICdvcGVyYXRvclBlbmRpbmcnLCB0cnVlKTsgfSxcbiAgICAvKiogQGFyZyB7Q29kZU1pcnJvclZ9IGNtIEBhcmcge0V4UGFyYW1zfSBwYXJhbXMgQGFyZyB7c3RyaW5nfSBjdHgqL1xuICAgIHVubWFwOiBmdW5jdGlvbihjbSwgcGFyYW1zLCBjdHgpIHtcbiAgICAgIHZhciBtYXBBcmdzID0gcGFyYW1zLmFyZ3M7XG4gICAgICBpZiAoIW1hcEFyZ3MgfHwgbWFwQXJncy5sZW5ndGggPCAxIHx8ICFleENvbW1hbmREaXNwYXRjaGVyLnVubWFwKG1hcEFyZ3NbMF0sIGN0eCkpIHtcbiAgICAgICAgaWYgKGNtKSB7XG4gICAgICAgICAgc2hvd0NvbmZpcm0oY20sICdObyBzdWNoIG1hcHBpbmc6ICcgKyBwYXJhbXMuaW5wdXQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICAvKiogQGFyZyB7Q29kZU1pcnJvclZ9IGNtIEBhcmcge0V4UGFyYW1zfSBwYXJhbXMqL1xuICAgIG1hcGNsZWFyOiBmdW5jdGlvbihjbSwgcGFyYW1zKSB7IHZpbUFwaS5tYXBjbGVhcigpOyB9LFxuICAgIC8qKiBAYXJnIHtDb2RlTWlycm9yVn0gY20gQGFyZyB7RXhQYXJhbXN9IHBhcmFtcyovXG4gICAgaW1hcGNsZWFyOiBmdW5jdGlvbihjbSwgcGFyYW1zKSB7IHZpbUFwaS5tYXBjbGVhcignaW5zZXJ0Jyk7IH0sXG4gICAgLyoqIEBhcmcge0NvZGVNaXJyb3JWfSBjbSBAYXJnIHtFeFBhcmFtc30gcGFyYW1zKi9cbiAgICBubWFwY2xlYXI6IGZ1bmN0aW9uKGNtLCBwYXJhbXMpIHsgdmltQXBpLm1hcGNsZWFyKCdub3JtYWwnKTsgfSxcbiAgICAvKiogQGFyZyB7Q29kZU1pcnJvclZ9IGNtIEBhcmcge0V4UGFyYW1zfSBwYXJhbXMqL1xuICAgIHZtYXBjbGVhcjogZnVuY3Rpb24oY20sIHBhcmFtcykgeyB2aW1BcGkubWFwY2xlYXIoJ3Zpc3VhbCcpOyB9LFxuICAgIC8qKiBAYXJnIHtDb2RlTWlycm9yVn0gY20gQGFyZyB7RXhQYXJhbXN9IHBhcmFtcyovXG4gICAgb21hcGNsZWFyOiBmdW5jdGlvbihjbSwgcGFyYW1zKSB7IHZpbUFwaS5tYXBjbGVhcignb3BlcmF0b3JQZW5kaW5nJyk7IH0sXG4gICAgLyoqIEBhcmcge0NvZGVNaXJyb3JWfSBjbSBAYXJnIHtFeFBhcmFtc30gcGFyYW1zKi9cbiAgICBtb3ZlOiBmdW5jdGlvbihjbSwgcGFyYW1zKSB7XG4gICAgICBjb21tYW5kRGlzcGF0Y2hlci5wcm9jZXNzQ29tbWFuZChjbSwgY20uc3RhdGUudmltLCB7XG4gICAgICAgIGtleXM6IFwiXCIsXG4gICAgICAgIHR5cGU6ICdtb3Rpb24nLFxuICAgICAgICBtb3Rpb246ICdtb3ZlVG9MaW5lT3JFZGdlT2ZEb2N1bWVudCcsXG4gICAgICAgIG1vdGlvbkFyZ3M6IHsgZm9yd2FyZDogZmFsc2UsIGV4cGxpY2l0UmVwZWF0OiB0cnVlLCBsaW5ld2lzZTogdHJ1ZSB9LFxuICAgICAgICByZXBlYXRPdmVycmlkZTogcGFyYW1zLmxpbmUrMVxuICAgICAgfSk7XG4gICAgfSxcbiAgICAvKiogQGFyZyB7Q29kZU1pcnJvclZ9IGNtIEBhcmcge0V4UGFyYW1zfSBwYXJhbXMqL1xuICAgIHNldDogZnVuY3Rpb24oY20sIHBhcmFtcykge1xuICAgICAgdmFyIHNldEFyZ3MgPSBwYXJhbXMuYXJncztcbiAgICAgIC8vIE9wdGlvbnMgcGFzc2VkIHRocm91Z2ggdG8gdGhlIHNldE9wdGlvbi9nZXRPcHRpb24gY2FsbHMuIE1heSBiZSBwYXNzZWQgaW4gYnkgdGhlXG4gICAgICAvLyBsb2NhbC9nbG9iYWwgdmVyc2lvbnMgb2YgdGhlIHNldCBjb21tYW5kXG4gICAgICB2YXIgc2V0Q2ZnID0gcGFyYW1zLnNldENmZyB8fCB7fTtcbiAgICAgIGlmICghc2V0QXJncyB8fCBzZXRBcmdzLmxlbmd0aCA8IDEpIHtcbiAgICAgICAgaWYgKGNtKSB7XG4gICAgICAgICAgc2hvd0NvbmZpcm0oY20sICdJbnZhbGlkIG1hcHBpbmc6ICcgKyBwYXJhbXMuaW5wdXQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBleHByID0gc2V0QXJnc1swXS5zcGxpdCgnPScpO1xuICAgICAgdmFyIG9wdGlvbk5hbWUgPSBleHByLnNoaWZ0KCkgfHwgXCJcIjtcbiAgICAgIC8qKkB0eXBlIHtzdHJpbmd8Ym9vbGVhbnx1bmRlZmluZWR9ICovXG4gICAgICB2YXIgdmFsdWUgPSBleHByLmxlbmd0aCA+IDAgPyBleHByLmpvaW4oJz0nKSA6IHVuZGVmaW5lZDtcbiAgICAgIHZhciBmb3JjZUdldCA9IGZhbHNlO1xuICAgICAgdmFyIGZvcmNlVG9nZ2xlID0gZmFsc2U7XG5cbiAgICAgIGlmIChvcHRpb25OYW1lLmNoYXJBdChvcHRpb25OYW1lLmxlbmd0aCAtIDEpID09ICc/Jykge1xuICAgICAgICAvLyBJZiBwb3N0LWZpeGVkIHdpdGggPywgdGhlbiB0aGUgc2V0IGlzIGFjdHVhbGx5IGEgZ2V0LlxuICAgICAgICBpZiAodmFsdWUpIHsgdGhyb3cgRXJyb3IoJ1RyYWlsaW5nIGNoYXJhY3RlcnM6ICcgKyBwYXJhbXMuYXJnU3RyaW5nKTsgfVxuICAgICAgICBvcHRpb25OYW1lID0gb3B0aW9uTmFtZS5zdWJzdHJpbmcoMCwgb3B0aW9uTmFtZS5sZW5ndGggLSAxKTtcbiAgICAgICAgZm9yY2VHZXQgPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmIChvcHRpb25OYW1lLmNoYXJBdChvcHRpb25OYW1lLmxlbmd0aCAtIDEpID09ICchJykge1xuICAgICAgICBvcHRpb25OYW1lID0gb3B0aW9uTmFtZS5zdWJzdHJpbmcoMCwgb3B0aW9uTmFtZS5sZW5ndGggLSAxKTtcbiAgICAgICAgZm9yY2VUb2dnbGUgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQgJiYgb3B0aW9uTmFtZS5zdWJzdHJpbmcoMCwgMikgPT0gJ25vJykge1xuICAgICAgICAvLyBUbyBzZXQgYm9vbGVhbiBvcHRpb25zIHRvIGZhbHNlLCB0aGUgb3B0aW9uIG5hbWUgaXMgcHJlZml4ZWQgd2l0aFxuICAgICAgICAvLyAnbm8nLlxuICAgICAgICBvcHRpb25OYW1lID0gb3B0aW9uTmFtZS5zdWJzdHJpbmcoMik7XG4gICAgICAgIHZhbHVlID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHZhciBvcHRpb25Jc0Jvb2xlYW4gPSBvcHRpb25zW29wdGlvbk5hbWVdICYmIG9wdGlvbnNbb3B0aW9uTmFtZV0udHlwZSA9PSAnYm9vbGVhbic7XG4gICAgICBpZiAob3B0aW9uSXNCb29sZWFuKSB7XG4gICAgICAgIGlmIChmb3JjZVRvZ2dsZSkge1xuICAgICAgICAgIHZhbHVlID0gIWdldE9wdGlvbihvcHRpb25OYW1lLCBjbSwgc2V0Q2ZnKTtcbiAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSA9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAvLyBDYWxsaW5nIHNldCB3aXRoIGEgYm9vbGVhbiBvcHRpb24gc2V0cyBpdCB0byB0cnVlLlxuICAgICAgICAgIHZhbHVlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gSWYgbm8gdmFsdWUgaXMgcHJvdmlkZWQsIHRoZW4gd2UgYXNzdW1lIHRoaXMgaXMgYSBnZXQuXG4gICAgICBpZiAoIW9wdGlvbklzQm9vbGVhbiAmJiB2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IGZvcmNlR2V0KSB7XG4gICAgICAgIHZhciBvbGRWYWx1ZSA9IGdldE9wdGlvbihvcHRpb25OYW1lLCBjbSwgc2V0Q2ZnKTtcbiAgICAgICAgaWYgKG9sZFZhbHVlIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICBzaG93Q29uZmlybShjbSwgb2xkVmFsdWUubWVzc2FnZSk7XG4gICAgICAgIH0gZWxzZSBpZiAob2xkVmFsdWUgPT09IHRydWUgfHwgb2xkVmFsdWUgPT09IGZhbHNlKSB7XG4gICAgICAgICAgc2hvd0NvbmZpcm0oY20sICcgJyArIChvbGRWYWx1ZSA/ICcnIDogJ25vJykgKyBvcHRpb25OYW1lKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzaG93Q29uZmlybShjbSwgJyAgJyArIG9wdGlvbk5hbWUgKyAnPScgKyBvbGRWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBzZXRPcHRpb25SZXR1cm4gPSBzZXRPcHRpb24ob3B0aW9uTmFtZSwgdmFsdWUsIGNtLCBzZXRDZmcpO1xuICAgICAgICBpZiAoc2V0T3B0aW9uUmV0dXJuIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICBzaG93Q29uZmlybShjbSwgc2V0T3B0aW9uUmV0dXJuLm1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICAvKiogQGFyZyB7Q29kZU1pcnJvclZ9IGNtIEBhcmcge0V4UGFyYW1zfSBwYXJhbXMqL1xuICAgIHNldGxvY2FsOiBmdW5jdGlvbiAoY20sIHBhcmFtcykge1xuICAgICAgLy8gc2V0Q2ZnIGlzIHBhc3NlZCB0aHJvdWdoIHRvIHNldE9wdGlvblxuICAgICAgcGFyYW1zLnNldENmZyA9IHtzY29wZTogJ2xvY2FsJ307XG4gICAgICB0aGlzLnNldChjbSwgcGFyYW1zKTtcbiAgICB9LFxuICAgIC8qKiBAYXJnIHtDb2RlTWlycm9yVn0gY20gQGFyZyB7RXhQYXJhbXN9IHBhcmFtcyovXG4gICAgc2V0Z2xvYmFsOiBmdW5jdGlvbiAoY20sIHBhcmFtcykge1xuICAgICAgLy8gc2V0Q2ZnIGlzIHBhc3NlZCB0aHJvdWdoIHRvIHNldE9wdGlvblxuICAgICAgcGFyYW1zLnNldENmZyA9IHtzY29wZTogJ2dsb2JhbCd9O1xuICAgICAgdGhpcy5zZXQoY20sIHBhcmFtcyk7XG4gICAgfSxcbiAgICAvKiogQGFyZyB7Q29kZU1pcnJvclZ9IGNtIEBhcmcge0V4UGFyYW1zfSBwYXJhbXMqL1xuICAgIHJlZ2lzdGVyczogZnVuY3Rpb24oY20sIHBhcmFtcykge1xuICAgICAgdmFyIHJlZ0FyZ3MgPSBwYXJhbXMuYXJncztcbiAgICAgIHZhciByZWdpc3RlcnMgPSB2aW1HbG9iYWxTdGF0ZS5yZWdpc3RlckNvbnRyb2xsZXIucmVnaXN0ZXJzO1xuICAgICAgdmFyIHJlZ0luZm8gPSAnLS0tLS0tLS0tLVJlZ2lzdGVycy0tLS0tLS0tLS1cXG5cXG4nO1xuICAgICAgaWYgKCFyZWdBcmdzKSB7XG4gICAgICAgIGZvciAodmFyIHJlZ2lzdGVyTmFtZSBpbiByZWdpc3RlcnMpIHtcbiAgICAgICAgICB2YXIgdGV4dCA9IHJlZ2lzdGVyc1tyZWdpc3Rlck5hbWVdLnRvU3RyaW5nKCk7XG4gICAgICAgICAgaWYgKHRleHQubGVuZ3RoKSB7XG4gICAgICAgICAgICByZWdJbmZvICs9ICdcIicgKyByZWdpc3Rlck5hbWUgKyAnICAgICcgKyB0ZXh0ICsgJ1xcbic7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgcmVnaXN0ZXJOYW1lcyA9IHJlZ0FyZ3Muam9pbignJyk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVnaXN0ZXJOYW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciByZWdpc3Rlck5hbWUgPSByZWdpc3Rlck5hbWVzLmNoYXJBdChpKTtcbiAgICAgICAgICBpZiAoIXZpbUdsb2JhbFN0YXRlLnJlZ2lzdGVyQ29udHJvbGxlci5pc1ZhbGlkUmVnaXN0ZXIocmVnaXN0ZXJOYW1lKSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciByZWdpc3RlciA9IHJlZ2lzdGVyc1tyZWdpc3Rlck5hbWVdIHx8IG5ldyBSZWdpc3RlcigpO1xuICAgICAgICAgIHJlZ0luZm8gKz0gJ1wiJyArIHJlZ2lzdGVyTmFtZSArICcgICAgJyArIHJlZ2lzdGVyLnRvU3RyaW5nKCkgKyAnXFxuJztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgc2hvd0NvbmZpcm0oY20sIHJlZ0luZm8sIHRydWUpO1xuICAgIH0sXG4gICAgLyoqIEBhcmcge0NvZGVNaXJyb3JWfSBjbSBAYXJnIHtFeFBhcmFtc30gcGFyYW1zKi9cbiAgICBtYXJrczogZnVuY3Rpb24oY20sIHBhcmFtcykge1xuICAgICAgdmFyIGZpbHRlckFyZ3MgPSBwYXJhbXMuYXJncztcbiAgICAgIHZhciBtYXJrcyA9IGNtLnN0YXRlLnZpbS5tYXJrcztcbiAgICAgIHZhciByZWdJbmZvID0gJy0tLS0tLS0tLS0tTWFya3MtLS0tLS0tLS0tLVxcbm1hcmtcXHRsaW5lXFx0Y29sXFxuXFxuJztcbiAgICAgIGlmICghZmlsdGVyQXJncykge1xuICAgICAgICBmb3IgKHZhciBuYW1lIGluIG1hcmtzKSB7XG4gICAgICAgICAgdmFyIG1hcmtlciA9IG1hcmtzW25hbWVdICYmIG1hcmtzW25hbWVdLmZpbmQoKTtcbiAgICAgICAgICBpZiAobWFya2VyKSB7XG4gICAgICAgICAgICByZWdJbmZvICs9IG5hbWUgKyAnXFx0JyArIG1hcmtlci5saW5lICsgJ1xcdCcgKyBtYXJrZXIuY2ggKyAgJ1xcbic7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgcmVnaXN0ZXJOYW1lcyA9IGZpbHRlckFyZ3Muam9pbignJyk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVnaXN0ZXJOYW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBuYW1lID0gcmVnaXN0ZXJOYW1lcy5jaGFyQXQoaSk7XG4gICAgICAgICAgdmFyIG1hcmtlciA9IG1hcmtzW25hbWVdICYmIG1hcmtzW25hbWVdLmZpbmQoKTtcbiAgICAgICAgICBpZiAobWFya2VyKSB7XG4gICAgICAgICAgICByZWdJbmZvICs9IG5hbWUgKyAnXFx0JyArIG1hcmtlci5saW5lICsgJ1xcdCcgKyBtYXJrZXIuY2ggKyAgJ1xcbic7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBzaG93Q29uZmlybShjbSwgcmVnSW5mbywgdHJ1ZSk7XG4gICAgfSxcbiAgICAvKiogQGFyZyB7Q29kZU1pcnJvclZ9IGNtIEBhcmcge0V4UGFyYW1zfSBwYXJhbXMqL1xuICAgIHNvcnQ6IGZ1bmN0aW9uKGNtLCBwYXJhbXMpIHtcbiAgICAgIHZhciByZXZlcnNlLCBpZ25vcmVDYXNlLCB1bmlxdWUsIG51bWJlciwgcGF0dGVybjtcbiAgICAgIGZ1bmN0aW9uIHBhcnNlQXJncygpIHtcbiAgICAgICAgaWYgKHBhcmFtcy5hcmdTdHJpbmcpIHtcbiAgICAgICAgICB2YXIgYXJncyA9IG5ldyBDTS5TdHJpbmdTdHJlYW0ocGFyYW1zLmFyZ1N0cmluZyk7XG4gICAgICAgICAgaWYgKGFyZ3MuZWF0KCchJykpIHsgcmV2ZXJzZSA9IHRydWU7IH1cbiAgICAgICAgICBpZiAoYXJncy5lb2woKSkgeyByZXR1cm47IH1cbiAgICAgICAgICBpZiAoIWFyZ3MuZWF0U3BhY2UoKSkgeyByZXR1cm4gJ0ludmFsaWQgYXJndW1lbnRzJzsgfVxuICAgICAgICAgIHZhciBvcHRzID0gYXJncy5tYXRjaCgvKFtkaW51b3hdKyk/XFxzKihcXC8uK1xcLyk/XFxzKi8pO1xuICAgICAgICAgIGlmICghb3B0cyB8fCAhYXJncy5lb2woKSkgeyByZXR1cm4gJ0ludmFsaWQgYXJndW1lbnRzJzsgfVxuICAgICAgICAgIGlmIChvcHRzWzFdKSB7XG4gICAgICAgICAgICBpZ25vcmVDYXNlID0gb3B0c1sxXS5pbmRleE9mKCdpJykgIT0gLTE7XG4gICAgICAgICAgICB1bmlxdWUgPSBvcHRzWzFdLmluZGV4T2YoJ3UnKSAhPSAtMTtcbiAgICAgICAgICAgIHZhciBkZWNpbWFsID0gb3B0c1sxXS5pbmRleE9mKCdkJykgIT0gLTEgfHwgb3B0c1sxXS5pbmRleE9mKCduJykgIT0gLTE7XG4gICAgICAgICAgICB2YXIgaGV4ID0gb3B0c1sxXS5pbmRleE9mKCd4JykgIT0gLTE7XG4gICAgICAgICAgICB2YXIgb2N0YWwgPSBvcHRzWzFdLmluZGV4T2YoJ28nKSAhPSAtMTtcbiAgICAgICAgICAgIGlmIChOdW1iZXIoZGVjaW1hbCkgKyBOdW1iZXIoaGV4KSArIE51bWJlcihvY3RhbCkgPiAxKSB7IHJldHVybiAnSW52YWxpZCBhcmd1bWVudHMnOyB9XG4gICAgICAgICAgICBudW1iZXIgPSBkZWNpbWFsICYmICdkZWNpbWFsJyB8fCBoZXggJiYgJ2hleCcgfHwgb2N0YWwgJiYgJ29jdGFsJztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG9wdHNbMl0pIHtcbiAgICAgICAgICAgIHBhdHRlcm4gPSBuZXcgUmVnRXhwKG9wdHNbMl0uc3Vic3RyKDEsIG9wdHNbMl0ubGVuZ3RoIC0gMiksIGlnbm9yZUNhc2UgPyAnaScgOiAnJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgZXJyID0gcGFyc2VBcmdzKCk7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIHNob3dDb25maXJtKGNtLCBlcnIgKyAnOiAnICsgcGFyYW1zLmFyZ1N0cmluZyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBsaW5lU3RhcnQgPSBwYXJhbXMubGluZSB8fCBjbS5maXJzdExpbmUoKTtcbiAgICAgIHZhciBsaW5lRW5kID0gcGFyYW1zLmxpbmVFbmQgfHwgcGFyYW1zLmxpbmUgfHwgY20ubGFzdExpbmUoKTtcbiAgICAgIGlmIChsaW5lU3RhcnQgPT0gbGluZUVuZCkgeyByZXR1cm47IH1cbiAgICAgIHZhciBjdXJTdGFydCA9IG5ldyBQb3MobGluZVN0YXJ0LCAwKTtcbiAgICAgIHZhciBjdXJFbmQgPSBuZXcgUG9zKGxpbmVFbmQsIGxpbmVMZW5ndGgoY20sIGxpbmVFbmQpKTtcbiAgICAgIHZhciB0ZXh0ID0gY20uZ2V0UmFuZ2UoY3VyU3RhcnQsIGN1ckVuZCkuc3BsaXQoJ1xcbicpO1xuICAgICAgdmFyIG51bWJlclJlZ2V4ID1cbiAgICAgICAgICAobnVtYmVyID09ICdkZWNpbWFsJykgPyAvKC0/KShbXFxkXSspLyA6XG4gICAgICAgICAgKG51bWJlciA9PSAnaGV4JykgPyAvKC0/KSg/OjB4KT8oWzAtOWEtZl0rKS9pIDpcbiAgICAgICAgICAobnVtYmVyID09ICdvY3RhbCcpID8gLyhbMC03XSspLyA6IG51bGw7XG4gICAgICB2YXIgcmFkaXggPSAobnVtYmVyID09ICdkZWNpbWFsJykgPyAxMCA6IChudW1iZXIgPT0gJ2hleCcpID8gMTYgOiAobnVtYmVyID09ICdvY3RhbCcpID8gOCA6IHVuZGVmaW5lZDtcbiAgICAgIHZhciBudW1QYXJ0ID0gW10sIHRleHRQYXJ0ID0gW107XG4gICAgICBpZiAobnVtYmVyIHx8IHBhdHRlcm4pIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0ZXh0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIG1hdGNoUGFydCA9IHBhdHRlcm4gPyB0ZXh0W2ldLm1hdGNoKHBhdHRlcm4pIDogbnVsbDtcbiAgICAgICAgICBpZiAobWF0Y2hQYXJ0ICYmIG1hdGNoUGFydFswXSAhPSAnJykge1xuICAgICAgICAgICAgbnVtUGFydC5wdXNoKG1hdGNoUGFydCk7XG4gICAgICAgICAgfSBlbHNlIGlmIChudW1iZXJSZWdleCAmJiBudW1iZXJSZWdleC5leGVjKHRleHRbaV0pKSB7XG4gICAgICAgICAgICBudW1QYXJ0LnB1c2godGV4dFtpXSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRleHRQYXJ0LnB1c2godGV4dFtpXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0ZXh0UGFydCA9IHRleHQ7XG4gICAgICB9XG4gICAgICAvKiogQGFyZyB7c3RyaW5nfSBhICBAYXJnIHtzdHJpbmd9IGIgKi9cbiAgICAgIGZ1bmN0aW9uIGNvbXBhcmVGbihhLCBiKSB7XG4gICAgICAgIGlmIChyZXZlcnNlKSB7IHZhciB0bXA7IHRtcCA9IGE7IGEgPSBiOyBiID0gdG1wOyB9XG4gICAgICAgIGlmIChpZ25vcmVDYXNlKSB7IGEgPSBhLnRvTG93ZXJDYXNlKCk7IGIgPSBiLnRvTG93ZXJDYXNlKCk7IH1cbiAgICAgICAgdmFyIGFtYXRjaCA9IG51bWJlclJlZ2V4ICYmIG51bWJlclJlZ2V4LmV4ZWMoYSk7XG4gICAgICAgIHZhciBibWF0Y2ggPSBudW1iZXJSZWdleCAmJiBudW1iZXJSZWdleC5leGVjKGIpO1xuICAgICAgICBpZiAoIWFtYXRjaCB8fCAhYm1hdGNoKSB7IHJldHVybiBhIDwgYiA/IC0xIDogMTsgfVxuICAgICAgICB2YXIgYW51bSA9IHBhcnNlSW50KChhbWF0Y2hbMV0gKyBhbWF0Y2hbMl0pLnRvTG93ZXJDYXNlKCksIHJhZGl4KTtcbiAgICAgICAgdmFyIGJudW0gPSBwYXJzZUludCgoYm1hdGNoWzFdICsgYm1hdGNoWzJdKS50b0xvd2VyQ2FzZSgpLCByYWRpeCk7XG4gICAgICAgIHJldHVybiBhbnVtIC0gYm51bTtcbiAgICAgIH1cbiAgICAgIC8qKiBAYXJnIHtzdHJpbmdbXX0gYSAgQGFyZyB7c3RyaW5nW119IGIgKi9cbiAgICAgIGZ1bmN0aW9uIGNvbXBhcmVQYXR0ZXJuRm4oYSwgYikge1xuICAgICAgICBpZiAocmV2ZXJzZSkgeyB2YXIgdG1wOyB0bXAgPSBhOyBhID0gYjsgYiA9IHRtcDsgfVxuICAgICAgICBpZiAoaWdub3JlQ2FzZSkgeyBhWzBdID0gYVswXS50b0xvd2VyQ2FzZSgpOyBiWzBdID0gYlswXS50b0xvd2VyQ2FzZSgpOyB9XG4gICAgICAgIHJldHVybiAoYVswXSA8IGJbMF0pID8gLTEgOiAxO1xuICAgICAgfVxuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgbnVtUGFydC5zb3J0KHBhdHRlcm4gPyBjb21wYXJlUGF0dGVybkZuIDogY29tcGFyZUZuKTtcbiAgICAgIGlmIChwYXR0ZXJuKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtUGFydC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICBudW1QYXJ0W2ldID0gbnVtUGFydFtpXS5pbnB1dDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICghbnVtYmVyKSB7IHRleHRQYXJ0LnNvcnQoY29tcGFyZUZuKTsgfVxuICAgICAgdGV4dCA9ICghcmV2ZXJzZSkgPyB0ZXh0UGFydC5jb25jYXQobnVtUGFydCkgOiBudW1QYXJ0LmNvbmNhdCh0ZXh0UGFydCk7XG4gICAgICBpZiAodW5pcXVlKSB7IC8vIFJlbW92ZSBkdXBsaWNhdGUgbGluZXNcbiAgICAgICAgdmFyIHRleHRPbGQgPSB0ZXh0O1xuICAgICAgICB2YXIgbGFzdExpbmU7XG4gICAgICAgIHRleHQgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0ZXh0T2xkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKHRleHRPbGRbaV0gIT0gbGFzdExpbmUpIHtcbiAgICAgICAgICAgIHRleHQucHVzaCh0ZXh0T2xkW2ldKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbGFzdExpbmUgPSB0ZXh0T2xkW2ldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjbS5yZXBsYWNlUmFuZ2UodGV4dC5qb2luKCdcXG4nKSwgY3VyU3RhcnQsIGN1ckVuZCk7XG4gICAgfSxcbiAgICAvKiogQGFyZyB7Q29kZU1pcnJvclZ9IGNtIEBhcmcge0V4UGFyYW1zfSBwYXJhbXMqL1xuICAgIHZnbG9iYWw6IGZ1bmN0aW9uKGNtLCBwYXJhbXMpIHtcbiAgICAgIC8vIGdsb2JhbCBpbnNwZWN0cyBwYXJhbXMuY29tbWFuZE5hbWVcbiAgICAgIHRoaXMuZ2xvYmFsKGNtLCBwYXJhbXMpO1xuICAgIH0sXG4gICAgLyoqIEBhcmcge0NvZGVNaXJyb3JWfSBjbSBAYXJnIHtFeFBhcmFtc30gcGFyYW1zKi9cbiAgICBub3JtYWw6IGZ1bmN0aW9uKGNtLCBwYXJhbXMpIHtcbiAgICAgIHZhciBub3JlbWFwID0gZmFsc2U7XG4gICAgICB2YXIgYXJnU3RyaW5nID0gcGFyYW1zLmFyZ1N0cmluZztcbiAgICAgIGlmIChhcmdTdHJpbmcgJiYgYXJnU3RyaW5nWzBdID09ICchJykge1xuICAgICAgICAgIGFyZ1N0cmluZyA9IGFyZ1N0cmluZy5zbGljZSgxKTtcbiAgICAgICAgICBub3JlbWFwID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGFyZ1N0cmluZyA9IGFyZ1N0cmluZy50cmltU3RhcnQoKTtcbiAgICAgIGlmICghYXJnU3RyaW5nKSB7XG4gICAgICAgIHNob3dDb25maXJtKGNtLCAnQXJndW1lbnQgaXMgcmVxdWlyZWQuJyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBsaW5lID0gcGFyYW1zLmxpbmU7XG4gICAgICBpZiAodHlwZW9mIGxpbmUgPT0gJ251bWJlcicpIHtcbiAgICAgICAgdmFyIGxpbmVFbmQgPSBpc05hTihwYXJhbXMubGluZUVuZCkgPyBsaW5lIDogcGFyYW1zLmxpbmVFbmQ7XG4gICAgICAgIGZvciAodmFyIGkgPSBsaW5lOyBpIDw9IGxpbmVFbmQ7IGkrKykge1xuICAgICAgICAgIGNtLnNldEN1cnNvcihpLCAwKTtcbiAgICAgICAgICBkb0tleVRvS2V5KGNtLCBwYXJhbXMuYXJnU3RyaW5nLnRyaW1TdGFydCgpLCB7bm9yZW1hcH0pO1xuICAgICAgICAgIGlmIChjbS5zdGF0ZS52aW0uaW5zZXJ0TW9kZSkge1xuICAgICAgICAgICAgZXhpdEluc2VydE1vZGUoY20sIHRydWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZG9LZXlUb0tleShjbSwgcGFyYW1zLmFyZ1N0cmluZy50cmltU3RhcnQoKSwge25vcmVtYXB9KTtcbiAgICAgICAgaWYgKGNtLnN0YXRlLnZpbS5pbnNlcnRNb2RlKSB7XG4gICAgICAgICAgZXhpdEluc2VydE1vZGUoY20sIHRydWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICAvKiogQGFyZyB7Q29kZU1pcnJvclZ9IGNtIEBhcmcge0V4UGFyYW1zfSBwYXJhbXMqL1xuICAgIGdsb2JhbDogZnVuY3Rpb24oY20sIHBhcmFtcykge1xuICAgICAgLy8gYSBnbG9iYWwgY29tbWFuZCBpcyBvZiB0aGUgZm9ybVxuICAgICAgLy8gOltyYW5nZV1nL3BhdHRlcm4vW2NtZF1cbiAgICAgIC8vIGFyZ1N0cmluZyBob2xkcyB0aGUgc3RyaW5nIC9wYXR0ZXJuL1tjbWRdXG4gICAgICB2YXIgYXJnU3RyaW5nID0gcGFyYW1zLmFyZ1N0cmluZztcbiAgICAgIGlmICghYXJnU3RyaW5nKSB7XG4gICAgICAgIHNob3dDb25maXJtKGNtLCAnUmVndWxhciBFeHByZXNzaW9uIG1pc3NpbmcgZnJvbSBnbG9iYWwnKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIGludmVydGVkID0gcGFyYW1zLmNvbW1hbmROYW1lWzBdID09PSAndic7XG4gICAgICBpZiAoYXJnU3RyaW5nWzBdID09PSAnIScgJiYgcGFyYW1zLmNvbW1hbmROYW1lWzBdID09PSAnZycpIHtcbiAgICAgICAgaW52ZXJ0ZWQgPSB0cnVlO1xuICAgICAgICBhcmdTdHJpbmcgPSBhcmdTdHJpbmcuc2xpY2UoMSk7XG4gICAgICB9XG4gICAgICAvLyByYW5nZSBpcyBzcGVjaWZpZWQgaGVyZVxuICAgICAgdmFyIGxpbmVTdGFydCA9IChwYXJhbXMubGluZSAhPT0gdW5kZWZpbmVkKSA/IHBhcmFtcy5saW5lIDogY20uZmlyc3RMaW5lKCk7XG4gICAgICB2YXIgbGluZUVuZCA9IHBhcmFtcy5saW5lRW5kIHx8IHBhcmFtcy5saW5lIHx8IGNtLmxhc3RMaW5lKCk7XG4gICAgICAvLyBnZXQgdGhlIHRva2VucyBmcm9tIGFyZ1N0cmluZ1xuICAgICAgdmFyIHRva2VucyA9IHNwbGl0QnlTbGFzaChhcmdTdHJpbmcpO1xuICAgICAgdmFyIHJlZ2V4UGFydCA9IGFyZ1N0cmluZywgY21kID0gXCJcIjtcbiAgICAgIGlmICh0b2tlbnMgJiYgdG9rZW5zLmxlbmd0aCkge1xuICAgICAgICByZWdleFBhcnQgPSB0b2tlbnNbMF07XG4gICAgICAgIGNtZCA9IHRva2Vucy5zbGljZSgxLCB0b2tlbnMubGVuZ3RoKS5qb2luKCcvJyk7XG4gICAgICB9XG4gICAgICBpZiAocmVnZXhQYXJ0KSB7XG4gICAgICAgIC8vIElmIHJlZ2V4IHBhcnQgaXMgZW1wdHksIHRoZW4gdXNlIHRoZSBwcmV2aW91cyBxdWVyeS4gT3RoZXJ3aXNlXG4gICAgICAgIC8vIHVzZSB0aGUgcmVnZXggcGFydCBhcyB0aGUgbmV3IHF1ZXJ5LlxuICAgICAgICB0cnkge1xuICAgICAgICAgIHVwZGF0ZVNlYXJjaFF1ZXJ5KGNtLCByZWdleFBhcnQsIHRydWUgLyoqIGlnbm9yZUNhc2UgKi8sXG4gICAgICAgICAgICB0cnVlIC8qKiBzbWFydENhc2UgKi8pO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgc2hvd0NvbmZpcm0oY20sICdJbnZhbGlkIHJlZ2V4OiAnICsgcmVnZXhQYXJ0KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIG5vdyB0aGF0IHdlIGhhdmUgdGhlIHJlZ2V4UGFydCwgc2VhcmNoIGZvciByZWdleCBtYXRjaGVzIGluIHRoZVxuICAgICAgLy8gc3BlY2lmaWVkIHJhbmdlIG9mIGxpbmVzXG4gICAgICB2YXIgcXVlcnkgPSBnZXRTZWFyY2hTdGF0ZShjbSkuZ2V0UXVlcnkoKTtcbiAgICAgIC8qKkB0eXBlIHsoc3RyaW5nfGltcG9ydChcIi4vdHlwZXNcIikuTGluZUhhbmRsZSlbXX0qL1xuICAgICAgdmFyIG1hdGNoZWRMaW5lcyA9IFtdO1xuICAgICAgZm9yICh2YXIgaSA9IGxpbmVTdGFydDsgaSA8PSBsaW5lRW5kOyBpKyspIHtcbiAgICAgICAgdmFyIGxpbmUgPSBjbS5nZXRMaW5lKGkpO1xuICAgICAgICB2YXIgbWF0Y2hlZCA9IHF1ZXJ5LnRlc3QobGluZSk7XG4gICAgICAgIGlmIChtYXRjaGVkICE9PSBpbnZlcnRlZCkge1xuICAgICAgICAgIG1hdGNoZWRMaW5lcy5wdXNoKGNtZCA/IGNtLmdldExpbmVIYW5kbGUoaSkgOiBsaW5lKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gaWYgdGhlcmUgaXMgbm8gW2NtZF0sIGp1c3QgZGlzcGxheSB0aGUgbGlzdCBvZiBtYXRjaGVkIGxpbmVzXG4gICAgICBpZiAoIWNtZCkge1xuICAgICAgICBzaG93Q29uZmlybShjbSwgbWF0Y2hlZExpbmVzLmpvaW4oJ1xcbicpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIGluZGV4ID0gMDtcbiAgICAgIHZhciBuZXh0Q29tbWFuZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoaW5kZXggPCBtYXRjaGVkTGluZXMubGVuZ3RoKSB7XG4gICAgICAgICAgdmFyIGxpbmVIYW5kbGUgPSBtYXRjaGVkTGluZXNbaW5kZXgrK107XG4gICAgICAgICAgdmFyIGxpbmVOdW0gPSBjbS5nZXRMaW5lTnVtYmVyKGxpbmVIYW5kbGUpO1xuICAgICAgICAgIGlmIChsaW5lTnVtID09IG51bGwpIHtcbiAgICAgICAgICAgIG5leHRDb21tYW5kKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBjb21tYW5kID0gKGxpbmVOdW0gKyAxKSArIGNtZDtcbiAgICAgICAgICBleENvbW1hbmREaXNwYXRjaGVyLnByb2Nlc3NDb21tYW5kKGNtLCBjb21tYW5kLCB7XG4gICAgICAgICAgICBjYWxsYmFjazogbmV4dENvbW1hbmRcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIGlmIChjbS5yZWxlYXNlTGluZUhhbmRsZXMpIHtcbiAgICAgICAgICBjbS5yZWxlYXNlTGluZUhhbmRsZXMoKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIG5leHRDb21tYW5kKCk7XG4gICAgfSxcbiAgICAvKiogQGFyZyB7Q29kZU1pcnJvclZ9IGNtIEBhcmcge0V4UGFyYW1zfSBwYXJhbXMqL1xuICAgIHN1YnN0aXR1dGU6IGZ1bmN0aW9uKGNtLCBwYXJhbXMpIHtcbiAgICAgIGlmICghY20uZ2V0U2VhcmNoQ3Vyc29yKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignU2VhcmNoIGZlYXR1cmUgbm90IGF2YWlsYWJsZS4gUmVxdWlyZXMgc2VhcmNoY3Vyc29yLmpzIG9yICcgK1xuICAgICAgICAgICAgJ2FueSBvdGhlciBnZXRTZWFyY2hDdXJzb3IgaW1wbGVtZW50YXRpb24uJyk7XG4gICAgICB9XG4gICAgICB2YXIgYXJnU3RyaW5nID0gcGFyYW1zLmFyZ1N0cmluZztcbiAgICAgIHZhciB0b2tlbnMgPSBhcmdTdHJpbmcgPyBzcGxpdEJ5U2VwYXJhdG9yKGFyZ1N0cmluZywgYXJnU3RyaW5nWzBdKSA6IFtdO1xuICAgICAgdmFyIHJlZ2V4UGFydCA9ICcnLCByZXBsYWNlUGFydCA9ICcnLCB0cmFpbGluZywgZmxhZ3NQYXJ0LCBjb3VudDtcbiAgICAgIHZhciBjb25maXJtID0gZmFsc2U7IC8vIFdoZXRoZXIgdG8gY29uZmlybSBlYWNoIHJlcGxhY2UuXG4gICAgICB2YXIgZ2xvYmFsID0gZmFsc2U7IC8vIFRydWUgdG8gcmVwbGFjZSBhbGwgaW5zdGFuY2VzIG9uIGEgbGluZSwgZmFsc2UgdG8gcmVwbGFjZSBvbmx5IDEuXG4gICAgICBpZiAodG9rZW5zICYmIHRva2Vucy5sZW5ndGgpIHtcbiAgICAgICAgcmVnZXhQYXJ0ID0gdG9rZW5zWzBdO1xuICAgICAgICBpZiAoZ2V0T3B0aW9uKCdwY3JlJykgJiYgcmVnZXhQYXJ0ICE9PSAnJykge1xuICAgICAgICAgICAgcmVnZXhQYXJ0ID0gbmV3IFJlZ0V4cChyZWdleFBhcnQpLnNvdXJjZTsgLy9ub3JtYWxpemUgbm90IGVzY2FwZWQgY2hhcmFjdGVyc1xuICAgICAgICB9XG4gICAgICAgIHJlcGxhY2VQYXJ0ID0gdG9rZW5zWzFdO1xuICAgICAgICBpZiAocmVwbGFjZVBhcnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGlmIChnZXRPcHRpb24oJ3BjcmUnKSkge1xuICAgICAgICAgICAgcmVwbGFjZVBhcnQgPSB1bmVzY2FwZVJlZ2V4UmVwbGFjZShyZXBsYWNlUGFydC5yZXBsYWNlKC8oW15cXFxcXSkmL2csXCIkMSQkJlwiKSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlcGxhY2VQYXJ0ID0gdHJhbnNsYXRlUmVnZXhSZXBsYWNlKHJlcGxhY2VQYXJ0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmltR2xvYmFsU3RhdGUubGFzdFN1YnN0aXR1dGVSZXBsYWNlUGFydCA9IHJlcGxhY2VQYXJ0O1xuICAgICAgICB9XG4gICAgICAgIHRyYWlsaW5nID0gdG9rZW5zWzJdID8gdG9rZW5zWzJdLnNwbGl0KCcgJykgOiBbXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGVpdGhlciB0aGUgYXJnU3RyaW5nIGlzIGVtcHR5IG9yIGl0cyBvZiB0aGUgZm9ybSAnIGhlbGxvL3dvcmxkJ1xuICAgICAgICAvLyBhY3R1YWxseSBzcGxpdEJ5U2xhc2ggcmV0dXJucyBhIGxpc3Qgb2YgdG9rZW5zXG4gICAgICAgIC8vIG9ubHkgaWYgdGhlIHN0cmluZyBzdGFydHMgd2l0aCBhICcvJ1xuICAgICAgICBpZiAoYXJnU3RyaW5nICYmIGFyZ1N0cmluZy5sZW5ndGgpIHtcbiAgICAgICAgICBzaG93Q29uZmlybShjbSwgJ1N1YnN0aXR1dGlvbnMgc2hvdWxkIGJlIG9mIHRoZSBmb3JtICcgK1xuICAgICAgICAgICAgICAnOnMvcGF0dGVybi9yZXBsYWNlLycpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gQWZ0ZXIgdGhlIDNyZCBzbGFzaCwgd2UgY2FuIGhhdmUgZmxhZ3MgZm9sbG93ZWQgYnkgYSBzcGFjZSBmb2xsb3dlZFxuICAgICAgLy8gYnkgY291bnQuXG4gICAgICBpZiAodHJhaWxpbmcpIHtcbiAgICAgICAgZmxhZ3NQYXJ0ID0gdHJhaWxpbmdbMF07XG4gICAgICAgIGNvdW50ID0gcGFyc2VJbnQodHJhaWxpbmdbMV0pO1xuICAgICAgICBpZiAoZmxhZ3NQYXJ0KSB7XG4gICAgICAgICAgaWYgKGZsYWdzUGFydC5pbmRleE9mKCdjJykgIT0gLTEpIHtcbiAgICAgICAgICAgIGNvbmZpcm0gPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZmxhZ3NQYXJ0LmluZGV4T2YoJ2cnKSAhPSAtMSkge1xuICAgICAgICAgICAgZ2xvYmFsID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGdldE9wdGlvbigncGNyZScpKSB7XG4gICAgICAgICAgICByZWdleFBhcnQgPSByZWdleFBhcnQgKyAnLycgKyBmbGFnc1BhcnQ7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlZ2V4UGFydCA9IHJlZ2V4UGFydC5yZXBsYWNlKC9cXC8vZywgXCJcXFxcL1wiKSArICcvJyArIGZsYWdzUGFydDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChyZWdleFBhcnQpIHtcbiAgICAgICAgLy8gSWYgcmVnZXggcGFydCBpcyBlbXB0eSwgdGhlbiB1c2UgdGhlIHByZXZpb3VzIHF1ZXJ5LiBPdGhlcndpc2UgdXNlXG4gICAgICAgIC8vIHRoZSByZWdleCBwYXJ0IGFzIHRoZSBuZXcgcXVlcnkuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdXBkYXRlU2VhcmNoUXVlcnkoY20sIHJlZ2V4UGFydCwgdHJ1ZSAvKiogaWdub3JlQ2FzZSAqLyxcbiAgICAgICAgICAgIHRydWUgLyoqIHNtYXJ0Q2FzZSAqLyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBzaG93Q29uZmlybShjbSwgJ0ludmFsaWQgcmVnZXg6ICcgKyByZWdleFBhcnQpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmVwbGFjZVBhcnQgPSByZXBsYWNlUGFydCB8fCB2aW1HbG9iYWxTdGF0ZS5sYXN0U3Vic3RpdHV0ZVJlcGxhY2VQYXJ0O1xuICAgICAgaWYgKHJlcGxhY2VQYXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgc2hvd0NvbmZpcm0oY20sICdObyBwcmV2aW91cyBzdWJzdGl0dXRlIHJlZ3VsYXIgZXhwcmVzc2lvbicpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgc3RhdGUgPSBnZXRTZWFyY2hTdGF0ZShjbSk7XG4gICAgICB2YXIgcXVlcnkgPSBzdGF0ZS5nZXRRdWVyeSgpO1xuICAgICAgdmFyIGxpbmVTdGFydCA9IChwYXJhbXMubGluZSAhPT0gdW5kZWZpbmVkKSA/IHBhcmFtcy5saW5lIDogY20uZ2V0Q3Vyc29yKCkubGluZTtcbiAgICAgIHZhciBsaW5lRW5kID0gcGFyYW1zLmxpbmVFbmQgfHwgbGluZVN0YXJ0O1xuICAgICAgaWYgKGxpbmVTdGFydCA9PSBjbS5maXJzdExpbmUoKSAmJiBsaW5lRW5kID09IGNtLmxhc3RMaW5lKCkpIHtcbiAgICAgICAgbGluZUVuZCA9IEluZmluaXR5O1xuICAgICAgfVxuICAgICAgaWYgKGNvdW50KSB7XG4gICAgICAgIGxpbmVTdGFydCA9IGxpbmVFbmQ7XG4gICAgICAgIGxpbmVFbmQgPSBsaW5lU3RhcnQgKyBjb3VudCAtIDE7XG4gICAgICB9XG4gICAgICB2YXIgc3RhcnRQb3MgPSBjbGlwQ3Vyc29yVG9Db250ZW50KGNtLCBuZXcgUG9zKGxpbmVTdGFydCwgMCkpO1xuICAgICAgdmFyIGN1cnNvciA9IGNtLmdldFNlYXJjaEN1cnNvcihxdWVyeSwgc3RhcnRQb3MpO1xuICAgICAgZG9SZXBsYWNlKGNtLCBjb25maXJtLCBnbG9iYWwsIGxpbmVTdGFydCwgbGluZUVuZCwgY3Vyc29yLCBxdWVyeSwgcmVwbGFjZVBhcnQsIHBhcmFtcy5jYWxsYmFjayk7XG4gICAgfSxcbiAgICAvKiogQGFyZyB7Q29kZU1pcnJvclZ9IGNtIEBhcmcge0V4UGFyYW1zfSBwYXJhbXMqL1xuICAgIHN0YXJ0aW5zZXJ0OiBmdW5jdGlvbihjbSwgcGFyYW1zKSB7XG4gICAgICBkb0tleVRvS2V5KGNtLCBwYXJhbXMuYXJnU3RyaW5nID09ICchJyA/ICdBJyA6ICdpJywge30pO1xuICAgIH0sXG4gICAgcmVkbzogQ00uY29tbWFuZHMucmVkbyxcbiAgICB1bmRvOiBDTS5jb21tYW5kcy51bmRvLFxuICAgIC8qKiBAYXJnIHtDb2RlTWlycm9yVn0gY20gKi9cbiAgICB3cml0ZTogZnVuY3Rpb24oY20pIHtcbiAgICAgIGlmIChDTS5jb21tYW5kcy5zYXZlKSB7XG4gICAgICAgIENNLmNvbW1hbmRzLnNhdmUoY20pO1xuICAgICAgfSBlbHNlIGlmIChjbS5zYXZlKSB7XG4gICAgICAgIC8vIFNhdmVzIHRvIHRleHQgYXJlYSBpZiBubyBzYXZlIGNvbW1hbmQgaXMgZGVmaW5lZCBhbmQgY20uc2F2ZSgpIGlzIGF2YWlsYWJsZS5cbiAgICAgICAgY20uc2F2ZSgpO1xuICAgICAgfVxuICAgIH0sXG4gICAgLyoqIEBhcmcge0NvZGVNaXJyb3JWfSBjbSAqL1xuICAgIG5vaGxzZWFyY2g6IGZ1bmN0aW9uKGNtKSB7XG4gICAgICBjbGVhclNlYXJjaEhpZ2hsaWdodChjbSk7XG4gICAgfSxcbiAgICAvKiogQGFyZyB7Q29kZU1pcnJvclZ9IGNtICovXG4gICAgeWFuazogZnVuY3Rpb24gKGNtKSB7XG4gICAgICB2YXIgY3VyID0gY29weUN1cnNvcihjbS5nZXRDdXJzb3IoKSk7XG4gICAgICB2YXIgbGluZSA9IGN1ci5saW5lO1xuICAgICAgdmFyIGxpbmVUZXh0ID0gY20uZ2V0TGluZShsaW5lKTtcbiAgICAgIHZpbUdsb2JhbFN0YXRlLnJlZ2lzdGVyQ29udHJvbGxlci5wdXNoVGV4dChcbiAgICAgICAgJzAnLCAneWFuaycsIGxpbmVUZXh0LCB0cnVlLCB0cnVlKTtcbiAgICB9LFxuICAgIC8qKiBAYXJnIHtDb2RlTWlycm9yVn0gY20gQGFyZyB7RXhQYXJhbXN9IHBhcmFtcyovXG4gICAgZGVsZXRlOiBmdW5jdGlvbihjbSwgcGFyYW1zKSB7XG4gICAgICB2YXIgbGluZSA9IHBhcmFtcy5zZWxlY3Rpb25MaW5lO1xuICAgICAgdmFyIGxpbmVFbmQgPSBpc05hTihwYXJhbXMuc2VsZWN0aW9uTGluZUVuZCkgPyBsaW5lIDogcGFyYW1zLnNlbGVjdGlvbkxpbmVFbmQ7XG4gICAgICBvcGVyYXRvcnMuZGVsZXRlKGNtLCB7bGluZXdpc2U6IHRydWV9LCBbXG4gICAgICAgIHsgYW5jaG9yOiBuZXcgUG9zKGxpbmUsIDApLFxuICAgICAgICAgIGhlYWQ6IG5ldyBQb3MobGluZUVuZCArIDEsIDApIH1cbiAgICAgIF0pO1xuICAgIH0sXG4gICAgLyoqIEBhcmcge0NvZGVNaXJyb3JWfSBjbSBAYXJnIHtFeFBhcmFtc30gcGFyYW1zKi9cbiAgICBqb2luOiBmdW5jdGlvbihjbSwgcGFyYW1zKSB7XG4gICAgICB2YXIgbGluZSA9IHBhcmFtcy5zZWxlY3Rpb25MaW5lO1xuICAgICAgdmFyIGxpbmVFbmQgPSBpc05hTihwYXJhbXMuc2VsZWN0aW9uTGluZUVuZCkgPyBsaW5lIDogcGFyYW1zLnNlbGVjdGlvbkxpbmVFbmQ7XG4gICAgICBjbS5zZXRDdXJzb3IobmV3IFBvcyhsaW5lLCAwKSk7XG4gICAgICBhY3Rpb25zLmpvaW5MaW5lcyhjbSwge3JlcGVhdDogbGluZUVuZCAtIGxpbmV9LCBjbS5zdGF0ZS52aW0pO1xuICAgIH0sXG4gICAgLyoqIEBhcmcge0NvZGVNaXJyb3JWfSBjbSBAYXJnIHtFeFBhcmFtc30gcGFyYW1zKi9cbiAgICBkZWxtYXJrczogZnVuY3Rpb24oY20sIHBhcmFtcykge1xuICAgICAgaWYgKCFwYXJhbXMuYXJnU3RyaW5nIHx8ICF0cmltKHBhcmFtcy5hcmdTdHJpbmcpKSB7XG4gICAgICAgIHNob3dDb25maXJtKGNtLCAnQXJndW1lbnQgcmVxdWlyZWQnKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgc3RhdGUgPSBjbS5zdGF0ZS52aW07XG4gICAgICB2YXIgc3RyZWFtID0gbmV3IENNLlN0cmluZ1N0cmVhbSh0cmltKHBhcmFtcy5hcmdTdHJpbmcpKTtcbiAgICAgIHdoaWxlICghc3RyZWFtLmVvbCgpKSB7XG4gICAgICAgIHN0cmVhbS5lYXRTcGFjZSgpO1xuXG4gICAgICAgIC8vIFJlY29yZCB0aGUgc3RyZWFtcyBwb3NpdGlvbiBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBsb29wIGZvciB1c2VcbiAgICAgICAgLy8gaW4gZXJyb3IgbWVzc2FnZXMuXG4gICAgICAgIHZhciBjb3VudCA9IHN0cmVhbS5wb3M7XG5cbiAgICAgICAgaWYgKCFzdHJlYW0ubWF0Y2goL1thLXpBLVpdLywgZmFsc2UpKSB7XG4gICAgICAgICAgc2hvd0NvbmZpcm0oY20sICdJbnZhbGlkIGFyZ3VtZW50OiAnICsgcGFyYW1zLmFyZ1N0cmluZy5zdWJzdHJpbmcoY291bnQpKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc3ltID0gc3RyZWFtLm5leHQoKTtcbiAgICAgICAgLy8gQ2hlY2sgaWYgdGhpcyBzeW1ib2wgaXMgcGFydCBvZiBhIHJhbmdlXG4gICAgICAgIGlmIChzdHJlYW0ubWF0Y2goJy0nLCB0cnVlKSkge1xuICAgICAgICAgIC8vIFRoaXMgc3ltYm9sIGlzIHBhcnQgb2YgYSByYW5nZS5cblxuICAgICAgICAgIC8vIFRoZSByYW5nZSBtdXN0IHRlcm1pbmF0ZSBhdCBhbiBhbHBoYWJldGljIGNoYXJhY3Rlci5cbiAgICAgICAgICBpZiAoIXN0cmVhbS5tYXRjaCgvW2EtekEtWl0vLCBmYWxzZSkpIHtcbiAgICAgICAgICAgIHNob3dDb25maXJtKGNtLCAnSW52YWxpZCBhcmd1bWVudDogJyArIHBhcmFtcy5hcmdTdHJpbmcuc3Vic3RyaW5nKGNvdW50KSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIHN0YXJ0TWFyayA9IHN5bTtcbiAgICAgICAgICB2YXIgZmluaXNoTWFyayA9IHN0cmVhbS5uZXh0KCk7XG4gICAgICAgICAgLy8gVGhlIHJhbmdlIG11c3QgdGVybWluYXRlIGF0IGFuIGFscGhhYmV0aWMgY2hhcmFjdGVyIHdoaWNoXG4gICAgICAgICAgLy8gc2hhcmVzIHRoZSBzYW1lIGNhc2UgYXMgdGhlIHN0YXJ0IG9mIHRoZSByYW5nZS5cbiAgICAgICAgICBpZiAoc3RhcnRNYXJrICYmIGZpbmlzaE1hcmsgJiYgaXNMb3dlckNhc2Uoc3RhcnRNYXJrKSA9PSBpc0xvd2VyQ2FzZShmaW5pc2hNYXJrKSkge1xuICAgICAgICAgICAgdmFyIHN0YXJ0ID0gc3RhcnRNYXJrLmNoYXJDb2RlQXQoMCk7XG4gICAgICAgICAgICB2YXIgZmluaXNoID0gZmluaXNoTWFyay5jaGFyQ29kZUF0KDApO1xuICAgICAgICAgICAgaWYgKHN0YXJ0ID49IGZpbmlzaCkge1xuICAgICAgICAgICAgICBzaG93Q29uZmlybShjbSwgJ0ludmFsaWQgYXJndW1lbnQ6ICcgKyBwYXJhbXMuYXJnU3RyaW5nLnN1YnN0cmluZyhjb3VudCkpO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEJlY2F1c2UgbWFya3MgYXJlIGFsd2F5cyBBU0NJSSB2YWx1ZXMsIGFuZCB3ZSBoYXZlXG4gICAgICAgICAgICAvLyBkZXRlcm1pbmVkIHRoYXQgdGhleSBhcmUgdGhlIHNhbWUgY2FzZSwgd2UgY2FuIHVzZVxuICAgICAgICAgICAgLy8gdGhlaXIgY2hhciBjb2RlcyB0byBpdGVyYXRlIHRocm91Z2ggdGhlIGRlZmluZWQgcmFuZ2UuXG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8PSBmaW5pc2ggLSBzdGFydDsgaisrKSB7XG4gICAgICAgICAgICAgIHZhciBtYXJrID0gU3RyaW5nLmZyb21DaGFyQ29kZShzdGFydCArIGopO1xuICAgICAgICAgICAgICBkZWxldGUgc3RhdGUubWFya3NbbWFya107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNob3dDb25maXJtKGNtLCAnSW52YWxpZCBhcmd1bWVudDogJyArIHN0YXJ0TWFyayArICctJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHN5bSkge1xuICAgICAgICAgIC8vIFRoaXMgc3ltYm9sIGlzIGEgdmFsaWQgbWFyaywgYW5kIGlzIG5vdCBwYXJ0IG9mIGEgcmFuZ2UuXG4gICAgICAgICAgZGVsZXRlIHN0YXRlLm1hcmtzW3N5bV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgdmFyIGV4Q29tbWFuZERpc3BhdGNoZXIgPSBuZXcgRXhDb21tYW5kRGlzcGF0Y2hlcigpO1xuXG4gIHZpbUFwaS5kZWZpbmVFeChcInZlcnNpb25cIiwgXCJ2ZVwiLCAoY20pID0+IHtcbiAgICBzaG93Q29uZmlybShjbSwgXCJDb2RlbWlycm9yLXZpbSB2ZXJzaW9uOiA2LjMuMFwiKTtcbiAgfSk7XG5cbiAgLyoqXG4gICAqIEBhcmcge0NvZGVNaXJyb3JWfSBjbSBDb2RlTWlycm9yIGluc3RhbmNlIHdlIGFyZSBpbi5cbiAgICogQGFyZyB7Ym9vbGVhbn0gY29uZmlybSBXaGV0aGVyIHRvIGNvbmZpcm0gZWFjaCByZXBsYWNlLlxuICAgKiBAYXJnIHtib29sZWFufSBnbG9iYWwgXG4gICAqIEBhcmcge251bWJlcn0gbGluZVN0YXJ0IExpbmUgdG8gc3RhcnQgcmVwbGFjaW5nIGZyb20uXG4gICAqIEBhcmcge251bWJlcn0gbGluZUVuZCBMaW5lIHRvIHN0b3AgcmVwbGFjaW5nIGF0LlxuICAgKiBUT0RPOiBmaW5kIGEgd2F5IGZvciB0eXBlc2NyaXB0IHRvIHVuZGVyc3RhbmQgdGhhdCB3aGVuIG1hdGNoIGlzIGZvdW5kIHNlYXJjaEN1cnNvci5mcm9tKCkgaXMgbm90IG51bGxcbiAgICogQGFyZyB7UmV0dXJuVHlwZTxDb2RlTWlycm9yW1wiZ2V0U2VhcmNoQ3Vyc29yXCJdPnxhbnl9IHNlYXJjaEN1cnNvciBTZWFyY2ggY3Vyc29yIHRvIHVzZSBmb3IgZmluZGluZyBtYXRjaGVzLlxuICAgKiBAYXJnIHtSZWdFeHB9IHF1ZXJ5IFF1ZXJ5IGZvciBwZXJmb3JtaW5nIG1hdGNoZXMgd2l0aC5cbiAgICogQGFyZyB7c3RyaW5nfSByZXBsYWNlV2l0aCBUZXh0IHRvIHJlcGxhY2UgbWF0Y2hlcyB3aXRoLiBNYXkgY29udGFpbiAkMSxcbiAgICogICAgICQyLCBldGMgZm9yIHJlcGxhY2luZyBjYXB0dXJlZCBncm91cHMgdXNpbmcgSmF2YVNjcmlwdCByZXBsYWNlLlxuICAgKiBAYXJnIHtmdW5jdGlvbn0gW2NhbGxiYWNrXSBBIGNhbGxiYWNrIGZvciB3aGVuIHRoZSByZXBsYWNlIGlzIGRvbmUuXG4gICAqL1xuICBmdW5jdGlvbiBkb1JlcGxhY2UoY20sIGNvbmZpcm0sIGdsb2JhbCwgbGluZVN0YXJ0LCBsaW5lRW5kLCBzZWFyY2hDdXJzb3IsIHF1ZXJ5LFxuICAgICAgcmVwbGFjZVdpdGgsIGNhbGxiYWNrKSB7XG4gICAgLy8gU2V0IHVwIGFsbCB0aGUgZnVuY3Rpb25zLlxuICAgIGNtLnN0YXRlLnZpbS5leE1vZGUgPSB0cnVlO1xuICAgIHZhciBkb25lID0gZmFsc2U7XG4gICAgdmFyIG1hdGNoZXMgPSAwO1xuICAgIFxuICAgIC8qKiBAdHlwZSB7UG9zfSovIHZhciBsYXN0UG9zO1xuICAgIC8qKiBAdHlwZSB7bnVtYmVyfSovIHZhciBtb2RpZmllZExpbmVOdW1iZXI7XG4gICAgLyoqIEB0eXBlIHtib29sZWFufSovdmFyIGpvaW5lZDtcbiAgICBmdW5jdGlvbiByZXBsYWNlQWxsKCkge1xuICAgICAgY20ub3BlcmF0aW9uKGZ1bmN0aW9uKCkge1xuICAgICAgICB3aGlsZSAoIWRvbmUpIHtcbiAgICAgICAgICByZXBsYWNlKCk7XG4gICAgICAgICAgbmV4dCgpO1xuICAgICAgICB9XG4gICAgICAgIHN0b3AoKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZXBsYWNlKCkge1xuICAgICAgdmFyIG5ld1RleHQgPSAnJztcbiAgICAgIHZhciBtYXRjaCA9IHNlYXJjaEN1cnNvci5tYXRjaCB8fCBzZWFyY2hDdXJzb3IucG9zICYmIHNlYXJjaEN1cnNvci5wb3MubWF0Y2g7XG4gICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgbmV3VGV4dCA9IHJlcGxhY2VXaXRoLnJlcGxhY2UoL1xcJChcXGR7MSwzfXxbJCZdKS9nLCBmdW5jdGlvbihfLCB4KSB7XG4gICAgICAgICAgaWYgKHggPT0gXCIkXCIpIHJldHVybiBcIiRcIjtcbiAgICAgICAgICBpZiAoeCA9PSAnJicpIHJldHVybiBtYXRjaFswXTtcbiAgICAgICAgICB2YXIgeDEgPSB4O1xuICAgICAgICAgIHdoaWxlIChwYXJzZUludCh4MSkgPj0gbWF0Y2gubGVuZ3RoICYmIHgxLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHgxID0geDEuc2xpY2UoMCwgeDEubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh4MSkgcmV0dXJuIG1hdGNoW3gxXSArIHguc2xpY2UoeDEubGVuZ3RoLCB4Lmxlbmd0aCk7XG4gICAgICAgICAgcmV0dXJuIF87XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHRleHQgPSBjbS5nZXRSYW5nZShzZWFyY2hDdXJzb3IuZnJvbSgpLCBzZWFyY2hDdXJzb3IudG8oKSk7XG4gICAgICAgIG5ld1RleHQgPSB0ZXh0LnJlcGxhY2UocXVlcnksIHJlcGxhY2VXaXRoKTtcbiAgICAgIH1cbiAgICAgIHZhciB1bm1vZGlmaWVkTGluZU51bWJlciA9IHNlYXJjaEN1cnNvci50bygpLmxpbmU7XG4gICAgICBzZWFyY2hDdXJzb3IucmVwbGFjZShuZXdUZXh0KTtcbiAgICAgIG1vZGlmaWVkTGluZU51bWJlciA9IHNlYXJjaEN1cnNvci50bygpLmxpbmU7XG4gICAgICBsaW5lRW5kICs9IG1vZGlmaWVkTGluZU51bWJlciAtIHVubW9kaWZpZWRMaW5lTnVtYmVyO1xuICAgICAgam9pbmVkID0gbW9kaWZpZWRMaW5lTnVtYmVyIDwgdW5tb2RpZmllZExpbmVOdW1iZXI7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZpbmROZXh0VmFsaWRNYXRjaCgpIHtcbiAgICAgIHZhciBsYXN0TWF0Y2hUbyA9IGxhc3RQb3MgJiYgY29weUN1cnNvcihzZWFyY2hDdXJzb3IudG8oKSk7XG4gICAgICB2YXIgbWF0Y2ggPSBzZWFyY2hDdXJzb3IuZmluZE5leHQoKTtcbiAgICAgIGlmIChtYXRjaCAmJiAhbWF0Y2hbMF0gJiYgbGFzdE1hdGNoVG8gJiYgY3Vyc29yRXF1YWwoc2VhcmNoQ3Vyc29yLmZyb20oKSwgbGFzdE1hdGNoVG8pKSB7XG4gICAgICAgIG1hdGNoID0gc2VhcmNoQ3Vyc29yLmZpbmROZXh0KCk7XG4gICAgICB9XG4gICAgICBpZiAobWF0Y2gpIG1hdGNoZXMrKztcbiAgICAgIHJldHVybiBtYXRjaDtcbiAgICB9XG4gICAgZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgIC8vIFRoZSBiZWxvdyBvbmx5IGxvb3BzIHRvIHNraXAgb3ZlciBtdWx0aXBsZSBvY2N1cnJlbmNlcyBvbiB0aGUgc2FtZVxuICAgICAgLy8gbGluZSB3aGVuICdnbG9iYWwnIGlzIG5vdCB0cnVlLlxuICAgICAgd2hpbGUoZmluZE5leHRWYWxpZE1hdGNoKCkgJiZcbiAgICAgICAgICAgIGlzSW5SYW5nZShzZWFyY2hDdXJzb3IuZnJvbSgpLCBsaW5lU3RhcnQsIGxpbmVFbmQpKSB7XG4gICAgICAgIGlmICghZ2xvYmFsICYmIHNlYXJjaEN1cnNvci5mcm9tKCkubGluZSA9PSBtb2RpZmllZExpbmVOdW1iZXIgJiYgIWpvaW5lZCkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNtLnNjcm9sbEludG9WaWV3KHNlYXJjaEN1cnNvci5mcm9tKCksIDMwKTtcbiAgICAgICAgY20uc2V0U2VsZWN0aW9uKHNlYXJjaEN1cnNvci5mcm9tKCksIHNlYXJjaEN1cnNvci50bygpKTtcbiAgICAgICAgbGFzdFBvcyA9IHNlYXJjaEN1cnNvci5mcm9tKCk7XG4gICAgICAgIGRvbmUgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZG9uZSA9IHRydWU7XG4gICAgfVxuICAgIC8qKiBAYXJnIHsoKCkgPT4gdm9pZCkgfCB1bmRlZmluZWR9IFtjbG9zZV0gKi9cbiAgICBmdW5jdGlvbiBzdG9wKGNsb3NlKSB7XG4gICAgICBpZiAoY2xvc2UpIHsgY2xvc2UoKTsgfVxuICAgICAgY20uZm9jdXMoKTtcbiAgICAgIGlmIChsYXN0UG9zKSB7XG4gICAgICAgIGNtLnNldEN1cnNvcihsYXN0UG9zKTtcbiAgICAgICAgdmFyIHZpbSA9IGNtLnN0YXRlLnZpbTtcbiAgICAgICAgdmltLmV4TW9kZSA9IGZhbHNlO1xuICAgICAgICB2aW0ubGFzdEhQb3MgPSB2aW0ubGFzdEhTUG9zID0gbGFzdFBvcy5jaDtcbiAgICAgIH1cbiAgICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjaygpOyB9XG4gICAgICBlbHNlIGlmIChkb25lKSB7XG4gICAgICAgIHNob3dDb25maXJtKGNtLCBcbiAgICAgICAgICAobWF0Y2hlcyA/ICdGb3VuZCAnICsgbWF0Y2hlcyArICcgbWF0Y2hlcycgOiAnTm8gbWF0Y2hlcyBmb3VuZCcpICtcbiAgICAgICAgICAnIGZvciBwYXR0ZXJuOiAnICsgcXVlcnkgK1xuICAgICAgICAgIChnZXRPcHRpb24oJ3BjcmUnKSA/ICcgKHNldCBub3BjcmUgdG8gdXNlIFZpbSByZWdleHBzKScgOiAnJylcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqIEBhcmcge0tleWJvYXJkRXZlbnR9IGUgICBAYXJnIHthbnl9IF92YWx1ZSAgIEBhcmcge2FueX0gY2xvc2UgKi9cbiAgICBmdW5jdGlvbiBvblByb21wdEtleURvd24oZSwgX3ZhbHVlLCBjbG9zZSkge1xuICAgICAgLy8gU3dhbGxvdyBhbGwga2V5cy5cbiAgICAgIENNLmVfc3RvcChlKTtcbiAgICAgIHZhciBrZXlOYW1lID0gdmltS2V5RnJvbUV2ZW50KGUpO1xuICAgICAgc3dpdGNoIChrZXlOYW1lKSB7XG4gICAgICAgIGNhc2UgJ3knOlxuICAgICAgICAgIHJlcGxhY2UoKTsgbmV4dCgpOyBicmVhaztcbiAgICAgICAgY2FzZSAnbic6XG4gICAgICAgICAgbmV4dCgpOyBicmVhaztcbiAgICAgICAgY2FzZSAnYSc6XG4gICAgICAgICAgLy8gcmVwbGFjZUFsbCBjb250YWlucyBhIGNhbGwgdG8gY2xvc2Ugb2YgaXRzIG93bi4gV2UgZG9uJ3Qgd2FudCBpdFxuICAgICAgICAgIC8vIHRvIGZpcmUgdG9vIGVhcmx5IG9yIG11bHRpcGxlIHRpbWVzLlxuICAgICAgICAgIHZhciBzYXZlZENhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgICAgICAgY2FsbGJhY2sgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgY20ub3BlcmF0aW9uKHJlcGxhY2VBbGwpO1xuICAgICAgICAgIGNhbGxiYWNrID0gc2F2ZWRDYWxsYmFjaztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnbCc6XG4gICAgICAgICAgcmVwbGFjZSgpO1xuICAgICAgICAgIC8vIGZhbGwgdGhyb3VnaCBhbmQgZXhpdC5cbiAgICAgICAgY2FzZSAncSc6XG4gICAgICAgIGNhc2UgJzxFc2M+JzpcbiAgICAgICAgY2FzZSAnPEMtYz4nOlxuICAgICAgICBjYXNlICc8Qy1bPic6XG4gICAgICAgICAgc3RvcChjbG9zZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAoZG9uZSkgeyBzdG9wKGNsb3NlKTsgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLy8gQWN0dWFsbHkgZG8gcmVwbGFjZS5cbiAgICBuZXh0KCk7XG4gICAgaWYgKGRvbmUpIHtcbiAgICAgIHNob3dDb25maXJtKGNtLCAnTm8gbWF0Y2hlcyBmb3IgJyArIHF1ZXJ5ICsgIChnZXRPcHRpb24oJ3BjcmUnKSA/ICcgKHNldCBub3BjcmUgdG8gdXNlIHZpbSByZWdleHBzKScgOiAnJykpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIWNvbmZpcm0pIHtcbiAgICAgIHJlcGxhY2VBbGwoKTtcbiAgICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjaygpOyB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHNob3dQcm9tcHQoY20sIHtcbiAgICAgIHByZWZpeDogZG9tKCdzcGFuJywgJ3JlcGxhY2Ugd2l0aCAnLCBkb20oJ3N0cm9uZycsIHJlcGxhY2VXaXRoKSwgJyAoeS9uL2EvcS9sKScpLFxuICAgICAgb25LZXlEb3duOiBvblByb21wdEtleURvd25cbiAgICB9KTtcbiAgfVxuXG4gIC8qKiBAYXJnIHtDb2RlTWlycm9yVn0gY20gIEBhcmcge2Jvb2xlYW59IFtrZWVwQ3Vyc29yXSAqL1xuICBmdW5jdGlvbiBleGl0SW5zZXJ0TW9kZShjbSwga2VlcEN1cnNvcikge1xuICAgIHZhciB2aW0gPSBjbS5zdGF0ZS52aW07XG4gICAgdmFyIG1hY3JvTW9kZVN0YXRlID0gdmltR2xvYmFsU3RhdGUubWFjcm9Nb2RlU3RhdGU7XG4gICAgdmFyIGluc2VydE1vZGVDaGFuZ2VSZWdpc3RlciA9IHZpbUdsb2JhbFN0YXRlLnJlZ2lzdGVyQ29udHJvbGxlci5nZXRSZWdpc3RlcignLicpO1xuICAgIHZhciBpc1BsYXlpbmcgPSBtYWNyb01vZGVTdGF0ZS5pc1BsYXlpbmc7XG4gICAgdmFyIGxhc3RDaGFuZ2UgPSBtYWNyb01vZGVTdGF0ZS5sYXN0SW5zZXJ0TW9kZUNoYW5nZXM7XG4gICAgaWYgKCFpc1BsYXlpbmcpIHtcbiAgICAgIGNtLm9mZignY2hhbmdlJywgb25DaGFuZ2UpO1xuICAgICAgaWYgKHZpbS5pbnNlcnRFbmQpIHZpbS5pbnNlcnRFbmQuY2xlYXIoKTtcbiAgICAgIHZpbS5pbnNlcnRFbmQgPSB1bmRlZmluZWQ7XG4gICAgICBDTS5vZmYoY20uZ2V0SW5wdXRGaWVsZCgpLCAna2V5ZG93bicsIG9uS2V5RXZlbnRUYXJnZXRLZXlEb3duKTtcbiAgICB9XG4gICAgaWYgKCFpc1BsYXlpbmcgJiYgdmltLmluc2VydE1vZGVSZXBlYXQgJiYgdmltLmluc2VydE1vZGVSZXBlYXQgPiAxKSB7XG4gICAgICAvLyBQZXJmb3JtIGluc2VydCBtb2RlIHJlcGVhdCBmb3IgY29tbWFuZHMgbGlrZSAzLGEgYW5kIDMsby5cbiAgICAgIHJlcGVhdExhc3RFZGl0KGNtLCB2aW0sIHZpbS5pbnNlcnRNb2RlUmVwZWF0IC0gMSxcbiAgICAgICAgICB0cnVlIC8qKiByZXBlYXRGb3JJbnNlcnQgKi8pO1xuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgdmltLmxhc3RFZGl0SW5wdXRTdGF0ZS5yZXBlYXRPdmVycmlkZSA9IHZpbS5pbnNlcnRNb2RlUmVwZWF0O1xuICAgIH1cbiAgICBkZWxldGUgdmltLmluc2VydE1vZGVSZXBlYXQ7XG4gICAgdmltLmluc2VydE1vZGUgPSBmYWxzZTtcbiAgICBpZiAoIWtlZXBDdXJzb3IpIHtcbiAgICAgIGNtLnNldEN1cnNvcihjbS5nZXRDdXJzb3IoKS5saW5lLCBjbS5nZXRDdXJzb3IoKS5jaC0xKTtcbiAgICB9XG4gICAgY20uc2V0T3B0aW9uKCdrZXlNYXAnLCAndmltJyk7XG4gICAgY20uc2V0T3B0aW9uKCdkaXNhYmxlSW5wdXQnLCB0cnVlKTtcbiAgICBjbS50b2dnbGVPdmVyd3JpdGUoZmFsc2UpOyAvLyBleGl0IHJlcGxhY2UgbW9kZSBpZiB3ZSB3ZXJlIGluIGl0LlxuICAgIC8vIHVwZGF0ZSB0aGUgXCIuIHJlZ2lzdGVyIGJlZm9yZSBleGl0aW5nIGluc2VydCBtb2RlXG4gICAgaW5zZXJ0TW9kZUNoYW5nZVJlZ2lzdGVyLnNldFRleHQobGFzdENoYW5nZS5jaGFuZ2VzLmpvaW4oJycpKTtcbiAgICBDTS5zaWduYWwoY20sIFwidmltLW1vZGUtY2hhbmdlXCIsIHttb2RlOiBcIm5vcm1hbFwifSk7XG4gICAgaWYgKG1hY3JvTW9kZVN0YXRlLmlzUmVjb3JkaW5nKSB7XG4gICAgICBsb2dJbnNlcnRNb2RlQ2hhbmdlKG1hY3JvTW9kZVN0YXRlKTtcbiAgICB9XG4gIH1cblxuICAvKiogQGFyZyB7dmltS2V5fSBjb21tYW5kKi9cbiAgZnVuY3Rpb24gX21hcENvbW1hbmQoY29tbWFuZCkge1xuICAgIGRlZmF1bHRLZXltYXAudW5zaGlmdChjb21tYW5kKTtcbiAgICBpZiAoY29tbWFuZC5rZXlzKSBhZGRVc2VkS2V5cyhjb21tYW5kLmtleXMpO1xuICB9XG5cbiAgLyoqIEBhcmcge3N0cmluZ30ga2V5cyAqL1xuICBmdW5jdGlvbiBhZGRVc2VkS2V5cyhrZXlzKSB7XG4gICAga2V5cy5zcGxpdCgvKDwoPzpbQ1NNQV0tKSpcXHcrPnwuKS9pKS5mb3JFYWNoKGZ1bmN0aW9uKHBhcnQpIHtcbiAgICAgIGlmIChwYXJ0KSB7XG4gICAgICAgIGlmICghdXNlZEtleXNbcGFydF0pIHVzZWRLZXlzW3BhcnRdID0gMDtcbiAgICAgICAgdXNlZEtleXNbcGFydF0rKztcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8qKiBAYXJnIHtzdHJpbmd9IGtleXMgKi9cbiAgZnVuY3Rpb24gcmVtb3ZlVXNlZEtleXMoa2V5cykge1xuICAgIGtleXMuc3BsaXQoLyg8KD86W0NTTUFdLSkqXFx3Kz58LikvaSkuZm9yRWFjaChmdW5jdGlvbihwYXJ0KSB7XG4gICAgICBpZiAodXNlZEtleXNbcGFydF0pXG4gICAgICAgIHVzZWRLZXlzW3BhcnRdLS07XG4gICAgfSk7XG4gIH1cblxuICAvKiogXG4gICAqIEBhcmcge3N0cmluZ30ga2V5c1xuICAgKiBAYXJnIHtzdHJpbmd9IHR5cGUgICBcbiAgICogQGFyZyB7c3RyaW5nfSBuYW1lXG4gICAqIEBhcmcge2FueX0gYXJnc1xuICAgKiBAYXJnIHt7IFt4OiBzdHJpbmddOiBhbnk7IH19IGV4dHJhIFxuICAgKiovXG4gIGZ1bmN0aW9uIG1hcENvbW1hbmQoa2V5cywgdHlwZSwgbmFtZSwgYXJncywgZXh0cmEpIHtcbiAgICAvKipAdHlwZXthbnl9ICovXG4gICAgdmFyIGNvbW1hbmQgPSB7a2V5czoga2V5cywgdHlwZTogdHlwZX07XG4gICAgY29tbWFuZFt0eXBlXSA9IG5hbWU7XG4gICAgY29tbWFuZFt0eXBlICsgXCJBcmdzXCJdID0gYXJncztcbiAgICBmb3IgKHZhciBrZXkgaW4gZXh0cmEpXG4gICAgICBjb21tYW5kW2tleV0gPSBleHRyYVtrZXldO1xuICAgIF9tYXBDb21tYW5kKGNvbW1hbmQpO1xuICB9XG5cbiAgLy8gVGhlIHRpbWVvdXQgaW4gbWlsbGlzZWNvbmRzIGZvciB0aGUgdHdvLWNoYXJhY3RlciBFU0Mga2V5bWFwIHNob3VsZCBiZVxuICAvLyBhZGp1c3RlZCBhY2NvcmRpbmcgdG8geW91ciB0eXBpbmcgc3BlZWQgdG8gcHJldmVudCBmYWxzZSBwb3NpdGl2ZXMuXG4gIGRlZmluZU9wdGlvbignaW5zZXJ0TW9kZUVzY0tleXNUaW1lb3V0JywgMjAwLCAnbnVtYmVyJyk7XG5cblxuICAvKipcbiAgICogQGFyZyB7Q29kZU1pcnJvclZ9IGNtIFxuICAgKiBAYXJnIHt2aW1TdGF0ZX0gdmltIFxuICAgKiBAYXJnIHtNYWNyb01vZGVTdGF0ZX0gbWFjcm9Nb2RlU3RhdGUgXG4gICAqIEBhcmcge3N0cmluZ30gcmVnaXN0ZXJOYW1lXG4gICAqL1xuICBmdW5jdGlvbiBleGVjdXRlTWFjcm9SZWdpc3RlcihjbSwgdmltLCBtYWNyb01vZGVTdGF0ZSwgcmVnaXN0ZXJOYW1lKSB7XG4gICAgdmFyIHJlZ2lzdGVyID0gdmltR2xvYmFsU3RhdGUucmVnaXN0ZXJDb250cm9sbGVyLmdldFJlZ2lzdGVyKHJlZ2lzdGVyTmFtZSk7XG4gICAgaWYgKHJlZ2lzdGVyTmFtZSA9PSAnOicpIHtcbiAgICAgIC8vIFJlYWQtb25seSByZWdpc3RlciBjb250YWluaW5nIGxhc3QgRXggY29tbWFuZC5cbiAgICAgIGlmIChyZWdpc3Rlci5rZXlCdWZmZXJbMF0pIHtcbiAgICAgICAgZXhDb21tYW5kRGlzcGF0Y2hlci5wcm9jZXNzQ29tbWFuZChjbSwgcmVnaXN0ZXIua2V5QnVmZmVyWzBdKTtcbiAgICAgIH1cbiAgICAgIG1hY3JvTW9kZVN0YXRlLmlzUGxheWluZyA9IGZhbHNlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIga2V5QnVmZmVyID0gcmVnaXN0ZXIua2V5QnVmZmVyO1xuICAgIHZhciBpbWMgPSAwO1xuICAgIG1hY3JvTW9kZVN0YXRlLmlzUGxheWluZyA9IHRydWU7XG4gICAgbWFjcm9Nb2RlU3RhdGUucmVwbGF5U2VhcmNoUXVlcmllcyA9IHJlZ2lzdGVyLnNlYXJjaFF1ZXJpZXMuc2xpY2UoMCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlCdWZmZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciB0ZXh0ID0ga2V5QnVmZmVyW2ldO1xuICAgICAgdmFyIG1hdGNoLCBrZXk7XG4gICAgICB2YXIga2V5UmUgPSAvPCg/OltDU01BXS0pKlxcdys+fC4vZ2k7XG4gICAgICB3aGlsZSAoKG1hdGNoID0ga2V5UmUuZXhlYyh0ZXh0KSkpIHtcbiAgICAgICAgLy8gUHVsbCBvZmYgb25lIGNvbW1hbmQga2V5LCB3aGljaCBpcyBlaXRoZXIgYSBzaW5nbGUgY2hhcmFjdGVyXG4gICAgICAgIC8vIG9yIGEgc3BlY2lhbCBzZXF1ZW5jZSB3cmFwcGVkIGluICc8JyBhbmQgJz4nLCBlLmcuICc8U3BhY2U+Jy5cbiAgICAgICAga2V5ID0gbWF0Y2hbMF07XG4gICAgICAgIHZpbUFwaS5oYW5kbGVLZXkoY20sIGtleSwgJ21hY3JvJyk7XG4gICAgICAgIGlmICh2aW0uaW5zZXJ0TW9kZSkge1xuICAgICAgICAgIHZhciBjaGFuZ2VzID0gcmVnaXN0ZXIuaW5zZXJ0TW9kZUNoYW5nZXNbaW1jKytdLmNoYW5nZXM7XG4gICAgICAgICAgdmltR2xvYmFsU3RhdGUubWFjcm9Nb2RlU3RhdGUubGFzdEluc2VydE1vZGVDaGFuZ2VzLmNoYW5nZXMgPSBjaGFuZ2VzO1xuICAgICAgICAgIHJlcGVhdEluc2VydE1vZGVDaGFuZ2VzKGNtLCBjaGFuZ2VzLCAxKTtcbiAgICAgICAgICBleGl0SW5zZXJ0TW9kZShjbSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgbWFjcm9Nb2RlU3RhdGUuaXNQbGF5aW5nID0gZmFsc2U7XG4gIH1cblxuICAvKiogQGFyZyB7TWFjcm9Nb2RlU3RhdGV9IG1hY3JvTW9kZVN0YXRlIEBhcmcge2FueX0ga2V5ICovXG4gIGZ1bmN0aW9uIGxvZ0tleShtYWNyb01vZGVTdGF0ZSwga2V5KSB7XG4gICAgaWYgKG1hY3JvTW9kZVN0YXRlLmlzUGxheWluZykgeyByZXR1cm47IH1cbiAgICB2YXIgcmVnaXN0ZXJOYW1lID0gbWFjcm9Nb2RlU3RhdGUubGF0ZXN0UmVnaXN0ZXI7XG4gICAgdmFyIHJlZ2lzdGVyID0gdmltR2xvYmFsU3RhdGUucmVnaXN0ZXJDb250cm9sbGVyLmdldFJlZ2lzdGVyKHJlZ2lzdGVyTmFtZSk7XG4gICAgaWYgKHJlZ2lzdGVyKSB7XG4gICAgICByZWdpc3Rlci5wdXNoVGV4dChrZXkpO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBAYXJnIHtNYWNyb01vZGVTdGF0ZX0gbWFjcm9Nb2RlU3RhdGUgKi9cbiAgZnVuY3Rpb24gbG9nSW5zZXJ0TW9kZUNoYW5nZShtYWNyb01vZGVTdGF0ZSkge1xuICAgIGlmIChtYWNyb01vZGVTdGF0ZS5pc1BsYXlpbmcpIHsgcmV0dXJuOyB9XG4gICAgdmFyIHJlZ2lzdGVyTmFtZSA9IG1hY3JvTW9kZVN0YXRlLmxhdGVzdFJlZ2lzdGVyO1xuICAgIHZhciByZWdpc3RlciA9IHZpbUdsb2JhbFN0YXRlLnJlZ2lzdGVyQ29udHJvbGxlci5nZXRSZWdpc3RlcihyZWdpc3Rlck5hbWUpO1xuICAgIGlmIChyZWdpc3RlciAmJiByZWdpc3Rlci5wdXNoSW5zZXJ0TW9kZUNoYW5nZXMpIHtcbiAgICAgIHJlZ2lzdGVyLnB1c2hJbnNlcnRNb2RlQ2hhbmdlcyhtYWNyb01vZGVTdGF0ZS5sYXN0SW5zZXJ0TW9kZUNoYW5nZXMpO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBAYXJnIHtNYWNyb01vZGVTdGF0ZX0gbWFjcm9Nb2RlU3RhdGUgQGFyZyB7c3RyaW5nfSBxdWVyeSAqL1xuICBmdW5jdGlvbiBsb2dTZWFyY2hRdWVyeShtYWNyb01vZGVTdGF0ZSwgcXVlcnkpIHtcbiAgICBpZiAobWFjcm9Nb2RlU3RhdGUuaXNQbGF5aW5nKSB7IHJldHVybjsgfVxuICAgIHZhciByZWdpc3Rlck5hbWUgPSBtYWNyb01vZGVTdGF0ZS5sYXRlc3RSZWdpc3RlcjtcbiAgICB2YXIgcmVnaXN0ZXIgPSB2aW1HbG9iYWxTdGF0ZS5yZWdpc3RlckNvbnRyb2xsZXIuZ2V0UmVnaXN0ZXIocmVnaXN0ZXJOYW1lKTtcbiAgICBpZiAocmVnaXN0ZXIgJiYgcmVnaXN0ZXIucHVzaFNlYXJjaFF1ZXJ5KSB7XG4gICAgICByZWdpc3Rlci5wdXNoU2VhcmNoUXVlcnkocXVlcnkpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBMaXN0ZW5zIGZvciBjaGFuZ2VzIG1hZGUgaW4gaW5zZXJ0IG1vZGUuXG4gICAqIFNob3VsZCBvbmx5IGJlIGFjdGl2ZSBpbiBpbnNlcnQgbW9kZS5cbiAgICogQGFyZyB7Q29kZU1pcnJvcn0gY21cbiAgICogQGFyZyB7eyBvcmlnaW46IHN0cmluZyB8IHVuZGVmaW5lZDsgdGV4dDogYW55W107IG5leHQ6IGFueTsgfX0gY2hhbmdlT2JqXG4gICAqL1xuICBmdW5jdGlvbiBvbkNoYW5nZShjbSwgY2hhbmdlT2JqKSB7XG4gICAgdmFyIG1hY3JvTW9kZVN0YXRlID0gdmltR2xvYmFsU3RhdGUubWFjcm9Nb2RlU3RhdGU7XG4gICAgdmFyIGxhc3RDaGFuZ2UgPSBtYWNyb01vZGVTdGF0ZS5sYXN0SW5zZXJ0TW9kZUNoYW5nZXM7XG4gICAgaWYgKCFtYWNyb01vZGVTdGF0ZS5pc1BsYXlpbmcpIHtcbiAgICAgIHZhciB2aW0gPSBjbS5zdGF0ZS52aW07XG4gICAgICB3aGlsZShjaGFuZ2VPYmopIHtcbiAgICAgICAgbGFzdENoYW5nZS5leHBlY3RDdXJzb3JBY3Rpdml0eUZvckNoYW5nZSA9IHRydWU7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgaWYgKGxhc3RDaGFuZ2UuaWdub3JlQ291bnQgPiAxKSB7XG4gICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgIGxhc3RDaGFuZ2UuaWdub3JlQ291bnQtLTtcbiAgICAgICAgfSBlbHNlIGlmIChjaGFuZ2VPYmoub3JpZ2luID09ICcraW5wdXQnIHx8IGNoYW5nZU9iai5vcmlnaW4gPT0gJ3Bhc3RlJ1xuICAgICAgICAgICAgfHwgY2hhbmdlT2JqLm9yaWdpbiA9PT0gdW5kZWZpbmVkIC8qIG9ubHkgaW4gdGVzdGluZyAqLykge1xuICAgICAgICAgIHZhciBzZWxlY3Rpb25Db3VudCA9IGNtLmxpc3RTZWxlY3Rpb25zKCkubGVuZ3RoO1xuICAgICAgICAgIGlmIChzZWxlY3Rpb25Db3VudCA+IDEpXG4gICAgICAgICAgICBsYXN0Q2hhbmdlLmlnbm9yZUNvdW50ID0gc2VsZWN0aW9uQ291bnQ7XG4gICAgICAgICAgdmFyIHRleHQgPSBjaGFuZ2VPYmoudGV4dC5qb2luKCdcXG4nKTtcbiAgICAgICAgICBpZiAobGFzdENoYW5nZS5tYXliZVJlc2V0KSB7XG4gICAgICAgICAgICBsYXN0Q2hhbmdlLmNoYW5nZXMgPSBbXTtcbiAgICAgICAgICAgIGxhc3RDaGFuZ2UubWF5YmVSZXNldCA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodGV4dCkge1xuICAgICAgICAgICAgaWYgKGNtLnN0YXRlLm92ZXJ3cml0ZSAmJiAhL1xcbi8udGVzdCh0ZXh0KSkge1xuICAgICAgICAgICAgICBsYXN0Q2hhbmdlLmNoYW5nZXMucHVzaChbdGV4dF0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaWYgKHRleHQubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgIHZhciBpbnNlcnRFbmQgPSB2aW0gJiYgdmltLmluc2VydEVuZCAmJiB2aW0uaW5zZXJ0RW5kLmZpbmQoKTtcbiAgICAgICAgICAgICAgICB2YXIgY3Vyc29yID0gY20uZ2V0Q3Vyc29yKCk7XG4gICAgICAgICAgICAgICAgaWYgKGluc2VydEVuZCAmJiBpbnNlcnRFbmQubGluZSA9PSBjdXJzb3IubGluZSkge1xuICAgICAgICAgICAgICAgICAgdmFyIG9mZnNldCA9IGluc2VydEVuZC5jaCAtIGN1cnNvci5jaDtcbiAgICAgICAgICAgICAgICAgIGlmIChvZmZzZXQgPiAwICYmIG9mZnNldCA8IHRleHQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGxhc3RDaGFuZ2UuY2hhbmdlcy5wdXNoKFt0ZXh0LCBvZmZzZXRdKTtcbiAgICAgICAgICAgICAgICAgICAgdGV4dCA9ICcnO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAodGV4dCkgbGFzdENoYW5nZS5jaGFuZ2VzLnB1c2godGV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIENoYW5nZSBvYmplY3RzIG1heSBiZSBjaGFpbmVkIHdpdGggbmV4dC5cbiAgICAgICAgY2hhbmdlT2JqID0gY2hhbmdlT2JqLm5leHQ7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIExpc3RlbnMgZm9yIGFueSBraW5kIG9mIGN1cnNvciBhY3Rpdml0eSBvbiBDb2RlTWlycm9yLlxuICAgKiBAYXJnIHtDb2RlTWlycm9yVn0gY21cbiAgICovXG4gIGZ1bmN0aW9uIG9uQ3Vyc29yQWN0aXZpdHkoY20pIHtcbiAgICB2YXIgdmltID0gY20uc3RhdGUudmltO1xuICAgIGlmICh2aW0uaW5zZXJ0TW9kZSkge1xuICAgICAgLy8gVHJhY2tpbmcgY3Vyc29yIGFjdGl2aXR5IGluIGluc2VydCBtb2RlIChmb3IgbWFjcm8gc3VwcG9ydCkuXG4gICAgICB2YXIgbWFjcm9Nb2RlU3RhdGUgPSB2aW1HbG9iYWxTdGF0ZS5tYWNyb01vZGVTdGF0ZTtcbiAgICAgIGlmIChtYWNyb01vZGVTdGF0ZS5pc1BsYXlpbmcpIHsgcmV0dXJuOyB9XG4gICAgICB2YXIgbGFzdENoYW5nZSA9IG1hY3JvTW9kZVN0YXRlLmxhc3RJbnNlcnRNb2RlQ2hhbmdlcztcbiAgICAgIGlmIChsYXN0Q2hhbmdlLmV4cGVjdEN1cnNvckFjdGl2aXR5Rm9yQ2hhbmdlKSB7XG4gICAgICAgIGxhc3RDaGFuZ2UuZXhwZWN0Q3Vyc29yQWN0aXZpdHlGb3JDaGFuZ2UgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEN1cnNvciBtb3ZlZCBvdXRzaWRlIHRoZSBjb250ZXh0IG9mIGFuIGVkaXQuIFJlc2V0IHRoZSBjaGFuZ2UuXG4gICAgICAgIGxhc3RDaGFuZ2UubWF5YmVSZXNldCA9IHRydWU7XG4gICAgICAgIGlmICh2aW0uaW5zZXJ0RW5kKSB2aW0uaW5zZXJ0RW5kLmNsZWFyKCk7XG4gICAgICAgIHZpbS5pbnNlcnRFbmQgPSBjbS5zZXRCb29rbWFyayhjbS5nZXRDdXJzb3IoKSwge2luc2VydExlZnQ6IHRydWV9KTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCFjbS5jdXJPcD8uaXNWaW1PcCkge1xuICAgICAgaGFuZGxlRXh0ZXJuYWxTZWxlY3Rpb24oY20sIHZpbSk7XG4gICAgfVxuICB9XG4gIC8qKiBAYXJnIHtDb2RlTWlycm9yVn0gY20gIEBhcmcge3ZpbVN0YXRlfSB2aW0gKi9cbiAgZnVuY3Rpb24gaGFuZGxlRXh0ZXJuYWxTZWxlY3Rpb24oY20sIHZpbSkge1xuICAgIHZhciBhbmNob3IgPSBjbS5nZXRDdXJzb3IoJ2FuY2hvcicpO1xuICAgIHZhciBoZWFkID0gY20uZ2V0Q3Vyc29yKCdoZWFkJyk7XG4gICAgLy8gRW50ZXIgb3IgZXhpdCB2aXN1YWwgbW9kZSB0byBtYXRjaCBtb3VzZSBzZWxlY3Rpb24uXG4gICAgaWYgKHZpbS52aXN1YWxNb2RlICYmICFjbS5zb21ldGhpbmdTZWxlY3RlZCgpKSB7XG4gICAgICBleGl0VmlzdWFsTW9kZShjbSwgZmFsc2UpO1xuICAgIH0gZWxzZSBpZiAoIXZpbS52aXN1YWxNb2RlICYmICF2aW0uaW5zZXJ0TW9kZSAmJiBjbS5zb21ldGhpbmdTZWxlY3RlZCgpKSB7XG4gICAgICB2aW0udmlzdWFsTW9kZSA9IHRydWU7XG4gICAgICB2aW0udmlzdWFsTGluZSA9IGZhbHNlO1xuICAgICAgQ00uc2lnbmFsKGNtLCBcInZpbS1tb2RlLWNoYW5nZVwiLCB7bW9kZTogXCJ2aXN1YWxcIn0pO1xuICAgIH1cbiAgICBpZiAodmltLnZpc3VhbE1vZGUpIHtcbiAgICAgIC8vIEJpbmQgQ29kZU1pcnJvciBzZWxlY3Rpb24gbW9kZWwgdG8gdmltIHNlbGVjdGlvbiBtb2RlbC5cbiAgICAgIC8vIE1vdXNlIHNlbGVjdGlvbnMgYXJlIGNvbnNpZGVyZWQgdmlzdWFsIGNoYXJhY3Rlcndpc2UuXG4gICAgICB2YXIgaGVhZE9mZnNldCA9ICFjdXJzb3JJc0JlZm9yZShoZWFkLCBhbmNob3IpID8gLTEgOiAwO1xuICAgICAgdmFyIGFuY2hvck9mZnNldCA9IGN1cnNvcklzQmVmb3JlKGhlYWQsIGFuY2hvcikgPyAtMSA6IDA7XG4gICAgICBoZWFkID0gb2Zmc2V0Q3Vyc29yKGhlYWQsIDAsIGhlYWRPZmZzZXQpO1xuICAgICAgYW5jaG9yID0gb2Zmc2V0Q3Vyc29yKGFuY2hvciwgMCwgYW5jaG9yT2Zmc2V0KTtcbiAgICAgIHZpbS5zZWwgPSB7XG4gICAgICAgIGFuY2hvcjogYW5jaG9yLFxuICAgICAgICBoZWFkOiBoZWFkXG4gICAgICB9O1xuICAgICAgdXBkYXRlTWFyayhjbSwgdmltLCAnPCcsIGN1cnNvck1pbihoZWFkLCBhbmNob3IpKTtcbiAgICAgIHVwZGF0ZU1hcmsoY20sIHZpbSwgJz4nLCBjdXJzb3JNYXgoaGVhZCwgYW5jaG9yKSk7XG4gICAgfSBlbHNlIGlmICghdmltLmluc2VydE1vZGUpIHtcbiAgICAgIC8vIFJlc2V0IGxhc3RIUG9zIGlmIHNlbGVjdGlvbiB3YXMgbW9kaWZpZWQgYnkgc29tZXRoaW5nIG91dHNpZGUgb2YgdmltIG1vZGUgZS5nLiBieSBtb3VzZS5cbiAgICAgIHZpbS5sYXN0SFBvcyA9IGNtLmdldEN1cnNvcigpLmNoO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGVzIHJhdyBrZXkgZG93biBldmVudHMgZnJvbSB0aGUgdGV4dCBhcmVhLlxuICAgKiAtIFNob3VsZCBvbmx5IGJlIGFjdGl2ZSBpbiBpbnNlcnQgbW9kZS5cbiAgICogLSBGb3IgcmVjb3JkaW5nIGRlbGV0ZXMgaW4gaW5zZXJ0IG1vZGUuXG4gICAqIEBhcmcge0tleWJvYXJkRXZlbnR9IGVcbiAgICovXG4gIGZ1bmN0aW9uIG9uS2V5RXZlbnRUYXJnZXRLZXlEb3duKGUpIHtcbiAgICB2YXIgbWFjcm9Nb2RlU3RhdGUgPSB2aW1HbG9iYWxTdGF0ZS5tYWNyb01vZGVTdGF0ZTtcbiAgICB2YXIgbGFzdENoYW5nZSA9IG1hY3JvTW9kZVN0YXRlLmxhc3RJbnNlcnRNb2RlQ2hhbmdlcztcbiAgICB2YXIga2V5TmFtZSA9IENNLmtleU5hbWUgPyBDTS5rZXlOYW1lKGUpIDogZS5rZXk7XG4gICAgaWYgKCFrZXlOYW1lKSB7IHJldHVybjsgfVxuICAgIFxuICAgIGlmIChrZXlOYW1lLmluZGV4T2YoJ0RlbGV0ZScpICE9IC0xIHx8IGtleU5hbWUuaW5kZXhPZignQmFja3NwYWNlJykgIT0gLTEpIHtcbiAgICAgIGlmIChsYXN0Q2hhbmdlLm1heWJlUmVzZXQpIHtcbiAgICAgICAgbGFzdENoYW5nZS5jaGFuZ2VzID0gW107XG4gICAgICAgIGxhc3RDaGFuZ2UubWF5YmVSZXNldCA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgbGFzdENoYW5nZS5jaGFuZ2VzLnB1c2gobmV3IEluc2VydE1vZGVLZXkoa2V5TmFtZSwgZSkpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXBlYXRzIHRoZSBsYXN0IGVkaXQsIHdoaWNoIGluY2x1ZGVzIGV4YWN0bHkgMSBjb21tYW5kIGFuZCBhdCBtb3N0IDFcbiAgICogaW5zZXJ0LiBPcGVyYXRvciBhbmQgbW90aW9uIGNvbW1hbmRzIGFyZSByZWFkIGZyb20gbGFzdEVkaXRJbnB1dFN0YXRlLFxuICAgKiB3aGlsZSBhY3Rpb24gY29tbWFuZHMgYXJlIHJlYWQgZnJvbSBsYXN0RWRpdEFjdGlvbkNvbW1hbmQuXG4gICAqXG4gICAqIElmIHJlcGVhdEZvckluc2VydCBpcyB0cnVlLCB0aGVuIHRoZSBmdW5jdGlvbiB3YXMgY2FsbGVkIGJ5XG4gICAqIGV4aXRJbnNlcnRNb2RlIHRvIHJlcGVhdCB0aGUgaW5zZXJ0IG1vZGUgY2hhbmdlcyB0aGUgdXNlciBqdXN0IG1hZGUuIFRoZVxuICAgKiBjb3JyZXNwb25kaW5nIGVudGVySW5zZXJ0TW9kZSBjYWxsIHdhcyBtYWRlIHdpdGggYSBjb3VudC5cbiAgICogQGFyZyB7Q29kZU1pcnJvclZ9IGNtIFxuICAgKiBAYXJnIHt2aW1TdGF0ZX0gdmltIFxuICAgKiBAYXJnIHtudW1iZXJ9IHJlcGVhdCAgXG4gICAqIEBhcmcge2Jvb2xlYW59IHJlcGVhdEZvckluc2VydFxuICAgKi9cbiAgZnVuY3Rpb24gcmVwZWF0TGFzdEVkaXQoY20sIHZpbSwgcmVwZWF0LCByZXBlYXRGb3JJbnNlcnQpIHtcbiAgICB2YXIgbWFjcm9Nb2RlU3RhdGUgPSB2aW1HbG9iYWxTdGF0ZS5tYWNyb01vZGVTdGF0ZTtcbiAgICBtYWNyb01vZGVTdGF0ZS5pc1BsYXlpbmcgPSB0cnVlO1xuICAgIHZhciBsYXN0QWN0aW9uID0gdmltLmxhc3RFZGl0QWN0aW9uQ29tbWFuZDtcbiAgICB2YXIgY2FjaGVkSW5wdXRTdGF0ZSA9IHZpbS5pbnB1dFN0YXRlO1xuICAgIGZ1bmN0aW9uIHJlcGVhdENvbW1hbmQoKSB7XG4gICAgICBpZiAobGFzdEFjdGlvbikge1xuICAgICAgICBjb21tYW5kRGlzcGF0Y2hlci5wcm9jZXNzQWN0aW9uKGNtLCB2aW0sIGxhc3RBY3Rpb24pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29tbWFuZERpc3BhdGNoZXIuZXZhbElucHV0KGNtLCB2aW0pO1xuICAgICAgfVxuICAgIH1cbiAgICAvKiogQGFyZyB7bnVtYmVyfSByZXBlYXQgKi9cbiAgICBmdW5jdGlvbiByZXBlYXRJbnNlcnQocmVwZWF0KSB7XG4gICAgICBpZiAobWFjcm9Nb2RlU3RhdGUubGFzdEluc2VydE1vZGVDaGFuZ2VzLmNoYW5nZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAvLyBGb3Igc29tZSByZWFzb24sIHJlcGVhdCBjdyBpbiBkZXNrdG9wIFZJTSBkb2VzIG5vdCByZXBlYXRcbiAgICAgICAgLy8gaW5zZXJ0IG1vZGUgY2hhbmdlcy4gV2lsbCBjb25mb3JtIHRvIHRoYXQgYmVoYXZpb3IuXG4gICAgICAgIHJlcGVhdCA9ICF2aW0ubGFzdEVkaXRBY3Rpb25Db21tYW5kID8gMSA6IHJlcGVhdDtcbiAgICAgICAgdmFyIGNoYW5nZU9iamVjdCA9IG1hY3JvTW9kZVN0YXRlLmxhc3RJbnNlcnRNb2RlQ2hhbmdlcztcbiAgICAgICAgcmVwZWF0SW5zZXJ0TW9kZUNoYW5nZXMoY20sIGNoYW5nZU9iamVjdC5jaGFuZ2VzLCByZXBlYXQpO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBAdHMtaWdub3JlXG4gICAgdmltLmlucHV0U3RhdGUgPSB2aW0ubGFzdEVkaXRJbnB1dFN0YXRlO1xuICAgIGlmIChsYXN0QWN0aW9uICYmIGxhc3RBY3Rpb24uaW50ZXJsYWNlSW5zZXJ0UmVwZWF0KSB7XG4gICAgICAvLyBvIGFuZCBPIHJlcGVhdCBoYXZlIHRvIGJlIGludGVybGFjZWQgd2l0aCBpbnNlcnQgcmVwZWF0cyBzbyB0aGF0IHRoZVxuICAgICAgLy8gaW5zZXJ0aW9ucyBhcHBlYXIgb24gc2VwYXJhdGUgbGluZXMgaW5zdGVhZCBvZiB0aGUgbGFzdCBsaW5lLlxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXBlYXQ7IGkrKykge1xuICAgICAgICByZXBlYXRDb21tYW5kKCk7XG4gICAgICAgIHJlcGVhdEluc2VydCgxKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCFyZXBlYXRGb3JJbnNlcnQpIHtcbiAgICAgICAgLy8gSGFjayB0byBnZXQgdGhlIGN1cnNvciB0byBlbmQgdXAgYXQgdGhlIHJpZ2h0IHBsYWNlLiBJZiBJIGlzXG4gICAgICAgIC8vIHJlcGVhdGVkIGluIGluc2VydCBtb2RlIHJlcGVhdCwgY3Vyc29yIHdpbGwgYmUgMSBpbnNlcnRcbiAgICAgICAgLy8gY2hhbmdlIHNldCBsZWZ0IG9mIHdoZXJlIGl0IHNob3VsZCBiZS5cbiAgICAgICAgcmVwZWF0Q29tbWFuZCgpO1xuICAgICAgfVxuICAgICAgcmVwZWF0SW5zZXJ0KHJlcGVhdCk7XG4gICAgfVxuICAgIHZpbS5pbnB1dFN0YXRlID0gY2FjaGVkSW5wdXRTdGF0ZTtcbiAgICBpZiAodmltLmluc2VydE1vZGUgJiYgIXJlcGVhdEZvckluc2VydCkge1xuICAgICAgLy8gRG9uJ3QgZXhpdCBpbnNlcnQgbW9kZSB0d2ljZS4gSWYgcmVwZWF0Rm9ySW5zZXJ0IGlzIHNldCwgdGhlbiB3ZVxuICAgICAgLy8gd2VyZSBjYWxsZWQgYnkgYW4gZXhpdEluc2VydE1vZGUgY2FsbCBsb3dlciBvbiB0aGUgc3RhY2suXG4gICAgICBleGl0SW5zZXJ0TW9kZShjbSk7XG4gICAgfVxuICAgIG1hY3JvTW9kZVN0YXRlLmlzUGxheWluZyA9IGZhbHNlO1xuICB9XG4gIC8qKkBhcmcge0NvZGVNaXJyb3JWfSBjbSwgQGFyZyB7c3RyaW5nfSBrZXkgKi9cbiAgZnVuY3Rpb24gc2VuZENtS2V5KGNtLCBrZXkpIHtcbiAgICBDTS5sb29rdXBLZXkoa2V5LCAndmltLWluc2VydCcsIGZ1bmN0aW9uIGtleUhhbmRsZXIoYmluZGluZykge1xuICAgICAgaWYgKHR5cGVvZiBiaW5kaW5nID09ICdzdHJpbmcnKSB7XG4gICAgICAgIENNLmNvbW1hbmRzW2JpbmRpbmddKGNtKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJpbmRpbmcoY20pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIEBwYXJhbSB7Q29kZU1pcnJvclZ9IGNtXG4gICAqIEBwYXJhbSB7SW5zZXJ0TW9kZUNoYW5nZXNbXCJjaGFuZ2VzXCJdfSBjaGFuZ2VzXG4gICAqIEBwYXJhbSB7bnVtYmVyfSByZXBlYXRcbiAgICovXG4gIGZ1bmN0aW9uIHJlcGVhdEluc2VydE1vZGVDaGFuZ2VzKGNtLCBjaGFuZ2VzLCByZXBlYXQpIHtcbiAgICB2YXIgaGVhZCA9IGNtLmdldEN1cnNvcignaGVhZCcpO1xuICAgIHZhciB2aXN1YWxCbG9jayA9IHZpbUdsb2JhbFN0YXRlLm1hY3JvTW9kZVN0YXRlLmxhc3RJbnNlcnRNb2RlQ2hhbmdlcy52aXN1YWxCbG9jaztcbiAgICBpZiAodmlzdWFsQmxvY2spIHtcbiAgICAgIC8vIFNldCB1cCBibG9jayBzZWxlY3Rpb24gYWdhaW4gZm9yIHJlcGVhdGluZyB0aGUgY2hhbmdlcy5cbiAgICAgIHNlbGVjdEZvckluc2VydChjbSwgaGVhZCwgdmlzdWFsQmxvY2sgKyAxKTtcbiAgICAgIHJlcGVhdCA9IGNtLmxpc3RTZWxlY3Rpb25zKCkubGVuZ3RoO1xuICAgICAgY20uc2V0Q3Vyc29yKGhlYWQpO1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlcGVhdDsgaSsrKSB7XG4gICAgICBpZiAodmlzdWFsQmxvY2spIHtcbiAgICAgICAgY20uc2V0Q3Vyc29yKG9mZnNldEN1cnNvcihoZWFkLCBpLCAwKSk7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGNoYW5nZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgdmFyIGNoYW5nZSA9IGNoYW5nZXNbal07XG4gICAgICAgIGlmIChjaGFuZ2UgaW5zdGFuY2VvZiBJbnNlcnRNb2RlS2V5KSB7XG4gICAgICAgICAgc2VuZENtS2V5KGNtLCBjaGFuZ2Uua2V5TmFtZSk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGNoYW5nZSA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgY20ucmVwbGFjZVNlbGVjdGlvbihjaGFuZ2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBzdGFydCA9IGNtLmdldEN1cnNvcigpO1xuICAgICAgICAgIHZhciBlbmQgPSBvZmZzZXRDdXJzb3Ioc3RhcnQsIDAsIGNoYW5nZVswXS5sZW5ndGggLSAoY2hhbmdlWzFdIHx8IDApKTtcbiAgICAgICAgICBjbS5yZXBsYWNlUmFuZ2UoY2hhbmdlWzBdLCBzdGFydCwgY2hhbmdlWzFdID8gc3RhcnQ6IGVuZCk7XG4gICAgICAgICAgY20uc2V0Q3Vyc29yKGVuZCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHZpc3VhbEJsb2NrKSB7XG4gICAgICBjbS5zZXRDdXJzb3Iob2Zmc2V0Q3Vyc29yKGhlYWQsIDAsIDEpKTtcbiAgICB9XG4gIH1cblxuICAvLyBtdWx0aXNlbGVjdCBzdXBwb3J0XG4gIC8qKiBAYXJnIHt2aW1TdGF0ZX0gc3RhdGUgKi9cbiAgZnVuY3Rpb24gY2xvbmVWaW1TdGF0ZShzdGF0ZSkge1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICB2YXIgbiA9IG5ldyBzdGF0ZS5jb25zdHJ1Y3RvcigpO1xuICAgIE9iamVjdC5rZXlzKHN0YXRlKS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgaWYgKGtleSA9PSBcImluc2VydEVuZFwiKSByZXR1cm47XG4gICAgICB2YXIgbyA9IHN0YXRlW2tleV07XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShvKSlcbiAgICAgICAgbyA9IG8uc2xpY2UoKTtcbiAgICAgIGVsc2UgaWYgKG8gJiYgdHlwZW9mIG8gPT0gXCJvYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yICE9IE9iamVjdClcbiAgICAgICAgbyA9IGNsb25lVmltU3RhdGUobyk7XG4gICAgICBuW2tleV0gPSBvO1xuICAgIH0pO1xuICAgIGlmIChzdGF0ZS5zZWwpIHtcbiAgICAgIG4uc2VsID0ge1xuICAgICAgICBoZWFkOiBzdGF0ZS5zZWwuaGVhZCAmJiBjb3B5Q3Vyc29yKHN0YXRlLnNlbC5oZWFkKSxcbiAgICAgICAgYW5jaG9yOiBzdGF0ZS5zZWwuYW5jaG9yICYmIGNvcHlDdXJzb3Ioc3RhdGUuc2VsLmFuY2hvcilcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBuO1xuICB9XG4gIC8qKiBAYXJnIHtDb2RlTWlycm9yfSBjbV8gIEBhcmcge3N0cmluZ30ga2V5IEBhcmcge3N0cmluZ30gb3JpZ2luICovXG4gIGZ1bmN0aW9uIG11bHRpU2VsZWN0SGFuZGxlS2V5KGNtXywga2V5LCBvcmlnaW4pIHtcbiAgICB2YXIgdmltID0gbWF5YmVJbml0VmltU3RhdGUoY21fKTtcbiAgICB2YXIgY20gPSAvKipAdHlwZSB7Q29kZU1pcnJvclZ9Ki8oY21fKTtcbiAgICAvKiogQHR5cGUge2Jvb2xlYW4gfCB1bmRlZmluZWR9ICovXG4gICAgdmFyIGlzSGFuZGxlZCA9IGZhbHNlO1xuICAgIHZhciB2aW0gPSB2aW1BcGkubWF5YmVJbml0VmltU3RhdGVfKGNtKTtcbiAgICB2YXIgdmlzdWFsQmxvY2sgPSB2aW0udmlzdWFsQmxvY2sgfHwgdmltLndhc0luVmlzdWFsQmxvY2s7XG5cbiAgICBpZiAoY20uc3RhdGUuY2xvc2VWaW1Ob3RpZmljYXRpb24pIHtcbiAgICAgIHZhciBjbG9zZSA9IGNtLnN0YXRlLmNsb3NlVmltTm90aWZpY2F0aW9uO1xuICAgICAgY20uc3RhdGUuY2xvc2VWaW1Ob3RpZmljYXRpb24gPSBudWxsO1xuICAgICAgY2xvc2UoKTtcbiAgICAgIGlmIChrZXkgPT0gJzxDUj4nKSB7XG4gICAgICAgIGNsZWFySW5wdXRTdGF0ZShjbSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciB3YXNNdWx0aXNlbGVjdCA9IGNtLmlzSW5NdWx0aVNlbGVjdE1vZGUoKTtcbiAgICBpZiAodmltLndhc0luVmlzdWFsQmxvY2sgJiYgIXdhc011bHRpc2VsZWN0KSB7XG4gICAgICB2aW0ud2FzSW5WaXN1YWxCbG9jayA9IGZhbHNlO1xuICAgIH0gZWxzZSBpZiAod2FzTXVsdGlzZWxlY3QgJiYgdmltLnZpc3VhbEJsb2NrKSB7XG4gICAgICAgIHZpbS53YXNJblZpc3VhbEJsb2NrID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoa2V5ID09ICc8RXNjPicgJiYgIXZpbS5pbnNlcnRNb2RlICYmICF2aW0udmlzdWFsTW9kZSAmJiB3YXNNdWx0aXNlbGVjdCAmJiB2aW0uc3RhdHVzID09IFwiPEVzYz5cIikge1xuICAgICAgLy8gYWxsb3cgZWRpdG9yIHRvIGV4aXQgbXVsdGlzZWxlY3RcbiAgICAgIGNsZWFySW5wdXRTdGF0ZShjbSk7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIH0gZWxzZSBpZiAodmlzdWFsQmxvY2sgfHwgIXdhc011bHRpc2VsZWN0IHx8IGNtLmluVmlydHVhbFNlbGVjdGlvbk1vZGUpIHtcbiAgICAgIGlzSGFuZGxlZCA9IHZpbUFwaS5oYW5kbGVLZXkoY20sIGtleSwgb3JpZ2luKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIG9sZCA9IGNsb25lVmltU3RhdGUodmltKTtcbiAgICAgIHZhciBjaGFuZ2VRdWV1ZUxpc3QgPSB2aW0uaW5wdXRTdGF0ZS5jaGFuZ2VRdWV1ZUxpc3QgfHwgW107XG5cbiAgICAgIGNtLm9wZXJhdGlvbihmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKGNtLmN1ck9wKVxuICAgICAgICAgIGNtLmN1ck9wLmlzVmltT3AgPSB0cnVlO1xuICAgICAgICB2YXIgaW5kZXggPSAwO1xuICAgICAgICBjbS5mb3JFYWNoU2VsZWN0aW9uKGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGNtLnN0YXRlLnZpbS5pbnB1dFN0YXRlLmNoYW5nZVF1ZXVlID0gY2hhbmdlUXVldWVMaXN0W2luZGV4XTtcbiAgICAgICAgICB2YXIgaGVhZCA9IGNtLmdldEN1cnNvcihcImhlYWRcIik7XG4gICAgICAgICAgdmFyIGFuY2hvciA9IGNtLmdldEN1cnNvcihcImFuY2hvclwiKTtcbiAgICAgICAgICB2YXIgaGVhZE9mZnNldCA9ICFjdXJzb3JJc0JlZm9yZShoZWFkLCBhbmNob3IpID8gLTEgOiAwO1xuICAgICAgICAgIHZhciBhbmNob3JPZmZzZXQgPSBjdXJzb3JJc0JlZm9yZShoZWFkLCBhbmNob3IpID8gLTEgOiAwO1xuICAgICAgICAgIGhlYWQgPSBvZmZzZXRDdXJzb3IoaGVhZCwgMCwgaGVhZE9mZnNldCk7XG4gICAgICAgICAgYW5jaG9yID0gb2Zmc2V0Q3Vyc29yKGFuY2hvciwgMCwgYW5jaG9yT2Zmc2V0KTtcbiAgICAgICAgICBjbS5zdGF0ZS52aW0uc2VsLmhlYWQgPSBoZWFkO1xuICAgICAgICAgIGNtLnN0YXRlLnZpbS5zZWwuYW5jaG9yID0gYW5jaG9yO1xuXG4gICAgICAgICAgaXNIYW5kbGVkID0gdmltQXBpLmhhbmRsZUtleShjbSwga2V5LCBvcmlnaW4pO1xuICAgICAgICAgIGlmIChjbS52aXJ0dWFsU2VsZWN0aW9uKSB7XG4gICAgICAgICAgICBjaGFuZ2VRdWV1ZUxpc3RbaW5kZXhdID0gY20uc3RhdGUudmltLmlucHV0U3RhdGUuY2hhbmdlUXVldWU7XG4gICAgICAgICAgICBjbS5zdGF0ZS52aW0gPSBjbG9uZVZpbVN0YXRlKG9sZCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGluZGV4Kys7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoY20uY3VyT3A/LmN1cnNvckFjdGl2aXR5ICYmICFpc0hhbmRsZWQpXG4gICAgICAgICAgY20uY3VyT3AuY3Vyc29yQWN0aXZpdHkgPSBmYWxzZTtcbiAgICAgICAgY20uc3RhdGUudmltID0gdmltO1xuICAgICAgICB2aW0uaW5wdXRTdGF0ZS5jaGFuZ2VRdWV1ZUxpc3QgPSBjaGFuZ2VRdWV1ZUxpc3Q7XG4gICAgICAgIHZpbS5pbnB1dFN0YXRlLmNoYW5nZVF1ZXVlID0gbnVsbDtcbiAgICAgIH0sIHRydWUpO1xuICAgIH1cbiAgICAvLyBzb21lIGNvbW1hbmRzIG1heSBicmluZyB2aXN1YWxNb2RlIGFuZCBzZWxlY3Rpb24gb3V0IG9mIHN5bmNcbiAgICBpZiAoaXNIYW5kbGVkICYmICF2aW0udmlzdWFsTW9kZSAmJiAhdmltLmluc2VydE1vZGUgJiYgdmltLnZpc3VhbE1vZGUgIT0gY20uc29tZXRoaW5nU2VsZWN0ZWQoKSkge1xuICAgICAgaGFuZGxlRXh0ZXJuYWxTZWxlY3Rpb24oY20sIHZpbSk7XG4gICAgfVxuICAgIHJldHVybiBpc0hhbmRsZWQ7XG4gIH1cbiAgcmVzZXRWaW1HbG9iYWxTdGF0ZSgpO1xuXG4gIHJldHVybiB2aW1BcGk7XG59XG5cbmZ1bmN0aW9uIGluZGV4RnJvbVBvcyhkb2MsIHBvcykge1xuICAgIHZhciBjaCA9IHBvcy5jaDtcbiAgICB2YXIgbGluZU51bWJlciA9IHBvcy5saW5lICsgMTtcbiAgICBpZiAobGluZU51bWJlciA8IDEpIHtcbiAgICAgICAgbGluZU51bWJlciA9IDE7XG4gICAgICAgIGNoID0gMDtcbiAgICB9XG4gICAgaWYgKGxpbmVOdW1iZXIgPiBkb2MubGluZXMpIHtcbiAgICAgICAgbGluZU51bWJlciA9IGRvYy5saW5lcztcbiAgICAgICAgY2ggPSBOdW1iZXIuTUFYX1ZBTFVFO1xuICAgIH1cbiAgICB2YXIgbGluZSA9IGRvYy5saW5lKGxpbmVOdW1iZXIpO1xuICAgIHJldHVybiBNYXRoLm1pbihsaW5lLmZyb20gKyBNYXRoLm1heCgwLCBjaCksIGxpbmUudG8pO1xufVxuZnVuY3Rpb24gcG9zRnJvbUluZGV4KGRvYywgb2Zmc2V0KSB7XG4gICAgbGV0IGxpbmUgPSBkb2MubGluZUF0KG9mZnNldCk7XG4gICAgcmV0dXJuIHsgbGluZTogbGluZS5udW1iZXIgLSAxLCBjaDogb2Zmc2V0IC0gbGluZS5mcm9tIH07XG59XG5jbGFzcyBQb3Mge1xuICAgIGNvbnN0cnVjdG9yKGxpbmUsIGNoKSB7XG4gICAgICAgIHRoaXMubGluZSA9IGxpbmU7XG4gICAgICAgIHRoaXMuY2ggPSBjaDtcbiAgICB9XG59XG5mdW5jdGlvbiBvbihlbWl0dGVyLCB0eXBlLCBmKSB7XG4gICAgaWYgKGVtaXR0ZXIuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgICAgICBlbWl0dGVyLmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgZiwgZmFsc2UpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdmFyIG1hcCA9IGVtaXR0ZXIuX2hhbmRsZXJzIHx8IChlbWl0dGVyLl9oYW5kbGVycyA9IHt9KTtcbiAgICAgICAgbWFwW3R5cGVdID0gKG1hcFt0eXBlXSB8fCBbXSkuY29uY2F0KGYpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIG9mZihlbWl0dGVyLCB0eXBlLCBmKSB7XG4gICAgaWYgKGVtaXR0ZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcikge1xuICAgICAgICBlbWl0dGVyLnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgZiwgZmFsc2UpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdmFyIG1hcCA9IGVtaXR0ZXIuX2hhbmRsZXJzLCBhcnIgPSBtYXAgJiYgbWFwW3R5cGVdO1xuICAgICAgICBpZiAoYXJyKSB7XG4gICAgICAgICAgICB2YXIgaW5kZXggPSBhcnIuaW5kZXhPZihmKTtcbiAgICAgICAgICAgIGlmIChpbmRleCA+IC0xKSB7XG4gICAgICAgICAgICAgICAgbWFwW3R5cGVdID0gYXJyLnNsaWNlKDAsIGluZGV4KS5jb25jYXQoYXJyLnNsaWNlKGluZGV4ICsgMSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gc2lnbmFsKGVtaXR0ZXIsIHR5cGUsIC4uLmFyZ3MpIHtcbiAgICB2YXIgX2E7XG4gICAgdmFyIGhhbmRsZXJzID0gKF9hID0gZW1pdHRlci5faGFuZGxlcnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYVt0eXBlXTtcbiAgICBpZiAoIWhhbmRsZXJzKVxuICAgICAgICByZXR1cm47XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBoYW5kbGVycy5sZW5ndGg7ICsraSkge1xuICAgICAgICBoYW5kbGVyc1tpXSguLi5hcmdzKTtcbiAgICB9XG59XG5mdW5jdGlvbiBzaWduYWxUbyhoYW5kbGVycywgLi4uYXJncykge1xuICAgIGlmICghaGFuZGxlcnMpXG4gICAgICAgIHJldHVybjtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhhbmRsZXJzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGhhbmRsZXJzW2ldKC4uLmFyZ3MpO1xuICAgIH1cbn1cbmxldCB3b3JkQ2hhcjtcbnRyeSB7XG4gICAgd29yZENoYXIgPSAvKkBfX1BVUkVfXyovbmV3IFJlZ0V4cChcIltcXFxcd1xcXFxwe0FscGhhYmV0aWN9XFxcXHB7TnVtYmVyfV9dXCIsIFwidVwiKTtcbn1cbmNhdGNoIChfKSB7XG4gICAgd29yZENoYXIgPSAvW1xcd10vO1xufVxuLy8gd29ya2Fyb3VuZCBmb3IgbWlzc2luZyBhcGkgZm9yIG1lcmdpbmcgdHJhbnNhY3Rpb25zXG5mdW5jdGlvbiBkaXNwYXRjaENoYW5nZShjbSwgdHJhbnNhY3Rpb24pIHtcbiAgICB2YXIgdmlldyA9IGNtLmNtNjtcbiAgICBpZiAodmlldy5zdGF0ZS5yZWFkT25seSlcbiAgICAgICAgcmV0dXJuO1xuICAgIHZhciB0eXBlID0gXCJpbnB1dC50eXBlLmNvbXBvc2VcIjtcbiAgICBpZiAoY20uY3VyT3ApIHtcbiAgICAgICAgaWYgKCFjbS5jdXJPcC5sYXN0Q2hhbmdlKVxuICAgICAgICAgICAgdHlwZSA9IFwiaW5wdXQudHlwZS5jb21wb3NlLnN0YXJ0XCI7XG4gICAgfVxuICAgIGlmICh0cmFuc2FjdGlvbi5hbm5vdGF0aW9ucykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdHJhbnNhY3Rpb24uYW5ub3RhdGlvbnMuc29tZShmdW5jdGlvbiAobm90ZSkge1xuICAgICAgICAgICAgICAgIGlmIChub3RlLnZhbHVlID09IFwiaW5wdXRcIilcbiAgICAgICAgICAgICAgICAgICAgbm90ZS52YWx1ZSA9IHR5cGU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdHJhbnNhY3Rpb24udXNlckV2ZW50ID0gdHlwZTtcbiAgICB9XG4gICAgcmV0dXJuIHZpZXcuZGlzcGF0Y2godHJhbnNhY3Rpb24pO1xufVxuZnVuY3Rpb24gcnVuSGlzdG9yeUNvbW1hbmQoY20sIHJldmVydCkge1xuICAgIHZhciBfYTtcbiAgICBpZiAoY20uY3VyT3ApIHtcbiAgICAgICAgY20uY3VyT3AuJGNoYW5nZVN0YXJ0ID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICAocmV2ZXJ0ID8gdW5kbyA6IHJlZG8pKGNtLmNtNik7XG4gICAgbGV0IGNoYW5nZVN0YXJ0SW5kZXggPSAoX2EgPSBjbS5jdXJPcCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLiRjaGFuZ2VTdGFydDtcbiAgICAvLyB2aW0gbW9kZSBleHBlY3RzIHRoZSBjaGFuZ2VkIHRleHQgdG8gYmUgZWl0aGVyIHNlbGVjdGVkIG9yIGN1cnNvciBwbGFjZWQgYXQgdGhlIHN0YXJ0XG4gICAgaWYgKGNoYW5nZVN0YXJ0SW5kZXggIT0gbnVsbCkge1xuICAgICAgICBjbS5jbTYuZGlzcGF0Y2goeyBzZWxlY3Rpb246IHsgYW5jaG9yOiBjaGFuZ2VTdGFydEluZGV4IH0gfSk7XG4gICAgfVxufVxudmFyIGtleXMgPSB7XG4gICAgTGVmdDogKGNtKSA9PiBydW5TY29wZUhhbmRsZXJzKGNtLmNtNiwgeyBrZXk6IFwiTGVmdFwiIH0sIFwiZWRpdG9yXCIpLFxuICAgIFJpZ2h0OiAoY20pID0+IHJ1blNjb3BlSGFuZGxlcnMoY20uY202LCB7IGtleTogXCJSaWdodFwiIH0sIFwiZWRpdG9yXCIpLFxuICAgIFVwOiAoY20pID0+IHJ1blNjb3BlSGFuZGxlcnMoY20uY202LCB7IGtleTogXCJVcFwiIH0sIFwiZWRpdG9yXCIpLFxuICAgIERvd246IChjbSkgPT4gcnVuU2NvcGVIYW5kbGVycyhjbS5jbTYsIHsga2V5OiBcIkRvd25cIiB9LCBcImVkaXRvclwiKSxcbiAgICBCYWNrc3BhY2U6IChjbSkgPT4gcnVuU2NvcGVIYW5kbGVycyhjbS5jbTYsIHsga2V5OiBcIkJhY2tzcGFjZVwiIH0sIFwiZWRpdG9yXCIpLFxuICAgIERlbGV0ZTogKGNtKSA9PiBydW5TY29wZUhhbmRsZXJzKGNtLmNtNiwgeyBrZXk6IFwiRGVsZXRlXCIgfSwgXCJlZGl0b3JcIiksXG59O1xuY2xhc3MgQ29kZU1pcnJvciB7XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBvcGVuRGlhbG9nKHRlbXBsYXRlLCBjYWxsYmFjaywgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gb3BlbkRpYWxvZyh0aGlzLCB0ZW1wbGF0ZSwgY2FsbGJhY2ssIG9wdGlvbnMpO1xuICAgIH1cbiAgICA7XG4gICAgb3Blbk5vdGlmaWNhdGlvbih0ZW1wbGF0ZSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gb3Blbk5vdGlmaWNhdGlvbih0aGlzLCB0ZW1wbGF0ZSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIDtcbiAgICBjb25zdHJ1Y3RvcihjbTYpIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHt9O1xuICAgICAgICB0aGlzLm1hcmtzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgdGhpcy4kbWlkID0gMDsgLy8gbWFya2VyIGlkIGNvdW50ZXJcbiAgICAgICAgdGhpcy5vcHRpb25zID0ge307XG4gICAgICAgIHRoaXMuX2hhbmRsZXJzID0ge307XG4gICAgICAgIHRoaXMuJGxhc3RDaGFuZ2VFbmRPZmZzZXQgPSAwO1xuICAgICAgICB0aGlzLnZpcnR1YWxTZWxlY3Rpb24gPSBudWxsO1xuICAgICAgICB0aGlzLmNtNiA9IGNtNjtcbiAgICAgICAgdGhpcy5vbkNoYW5nZSA9IHRoaXMub25DaGFuZ2UuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vblNlbGVjdGlvbkNoYW5nZSA9IHRoaXMub25TZWxlY3Rpb25DaGFuZ2UuYmluZCh0aGlzKTtcbiAgICB9XG4gICAgO1xuICAgIG9uKHR5cGUsIGYpIHsgb24odGhpcywgdHlwZSwgZik7IH1cbiAgICBvZmYodHlwZSwgZikgeyBvZmYodGhpcywgdHlwZSwgZik7IH1cbiAgICBzaWduYWwodHlwZSwgZSwgaGFuZGxlcnMpIHsgc2lnbmFsKHRoaXMsIHR5cGUsIGUsIGhhbmRsZXJzKTsgfVxuICAgIGluZGV4RnJvbVBvcyhwb3MpIHtcbiAgICAgICAgcmV0dXJuIGluZGV4RnJvbVBvcyh0aGlzLmNtNi5zdGF0ZS5kb2MsIHBvcyk7XG4gICAgfVxuICAgIDtcbiAgICBwb3NGcm9tSW5kZXgob2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiBwb3NGcm9tSW5kZXgodGhpcy5jbTYuc3RhdGUuZG9jLCBvZmZzZXQpO1xuICAgIH1cbiAgICA7XG4gICAgZm9sZENvZGUocG9zKSB7XG4gICAgICAgIGxldCB2aWV3ID0gdGhpcy5jbTY7XG4gICAgICAgIGxldCByYW5nZXMgPSB2aWV3LnN0YXRlLnNlbGVjdGlvbi5yYW5nZXM7XG4gICAgICAgIGxldCBkb2MgPSB0aGlzLmNtNi5zdGF0ZS5kb2M7XG4gICAgICAgIGxldCBpbmRleCA9IGluZGV4RnJvbVBvcyhkb2MsIHBvcyk7XG4gICAgICAgIGxldCB0bXBSYW5nZXMgPSBFZGl0b3JTZWxlY3Rpb24uY3JlYXRlKFtFZGl0b3JTZWxlY3Rpb24ucmFuZ2UoaW5kZXgsIGluZGV4KV0sIDApLnJhbmdlcztcbiAgICAgICAgdmlldy5zdGF0ZS5zZWxlY3Rpb24ucmFuZ2VzID0gdG1wUmFuZ2VzO1xuICAgICAgICBmb2xkQ29kZSh2aWV3KTtcbiAgICAgICAgdmlldy5zdGF0ZS5zZWxlY3Rpb24ucmFuZ2VzID0gcmFuZ2VzO1xuICAgIH1cbiAgICBmaXJzdExpbmUoKSB7IHJldHVybiAwOyB9XG4gICAgO1xuICAgIGxhc3RMaW5lKCkgeyByZXR1cm4gdGhpcy5jbTYuc3RhdGUuZG9jLmxpbmVzIC0gMTsgfVxuICAgIDtcbiAgICBsaW5lQ291bnQoKSB7IHJldHVybiB0aGlzLmNtNi5zdGF0ZS5kb2MubGluZXM7IH1cbiAgICA7XG4gICAgc2V0Q3Vyc29yKGxpbmUsIGNoKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbGluZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGNoID0gbGluZS5jaDtcbiAgICAgICAgICAgIGxpbmUgPSBsaW5lLmxpbmU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG9mZnNldCA9IGluZGV4RnJvbVBvcyh0aGlzLmNtNi5zdGF0ZS5kb2MsIHsgbGluZSwgY2g6IGNoIHx8IDAgfSk7XG4gICAgICAgIHRoaXMuY202LmRpc3BhdGNoKHsgc2VsZWN0aW9uOiB7IGFuY2hvcjogb2Zmc2V0IH0gfSwgeyBzY3JvbGxJbnRvVmlldzogIXRoaXMuY3VyT3AgfSk7XG4gICAgICAgIGlmICh0aGlzLmN1ck9wICYmICF0aGlzLmN1ck9wLmlzVmltT3ApXG4gICAgICAgICAgICB0aGlzLm9uQmVmb3JlRW5kT3BlcmF0aW9uKCk7XG4gICAgfVxuICAgIDtcbiAgICBnZXRDdXJzb3IocCkge1xuICAgICAgICB2YXIgc2VsID0gdGhpcy5jbTYuc3RhdGUuc2VsZWN0aW9uLm1haW47XG4gICAgICAgIHZhciBvZmZzZXQgPSBwID09IFwiaGVhZFwiIHx8ICFwXG4gICAgICAgICAgICA/IHNlbC5oZWFkXG4gICAgICAgICAgICA6IHAgPT0gXCJhbmNob3JcIlxuICAgICAgICAgICAgICAgID8gc2VsLmFuY2hvclxuICAgICAgICAgICAgICAgIDogcCA9PSBcInN0YXJ0XCJcbiAgICAgICAgICAgICAgICAgICAgPyBzZWwuZnJvbVxuICAgICAgICAgICAgICAgICAgICA6IHAgPT0gXCJlbmRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgPyBzZWwudG9cbiAgICAgICAgICAgICAgICAgICAgICAgIDogbnVsbDtcbiAgICAgICAgaWYgKG9mZnNldCA9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBjdXJzb3IgdHlwZVwiKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucG9zRnJvbUluZGV4KG9mZnNldCk7XG4gICAgfVxuICAgIDtcbiAgICBsaXN0U2VsZWN0aW9ucygpIHtcbiAgICAgICAgdmFyIGRvYyA9IHRoaXMuY202LnN0YXRlLmRvYztcbiAgICAgICAgcmV0dXJuIHRoaXMuY202LnN0YXRlLnNlbGVjdGlvbi5yYW5nZXMubWFwKHIgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBhbmNob3I6IHBvc0Zyb21JbmRleChkb2MsIHIuYW5jaG9yKSxcbiAgICAgICAgICAgICAgICBoZWFkOiBwb3NGcm9tSW5kZXgoZG9jLCByLmhlYWQpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIDtcbiAgICBzZXRTZWxlY3Rpb25zKHAsIHByaW1JbmRleCkge1xuICAgICAgICB2YXIgZG9jID0gdGhpcy5jbTYuc3RhdGUuZG9jO1xuICAgICAgICB2YXIgcmFuZ2VzID0gcC5tYXAoeCA9PiB7XG4gICAgICAgICAgICB2YXIgaGVhZCA9IGluZGV4RnJvbVBvcyhkb2MsIHguaGVhZCk7XG4gICAgICAgICAgICB2YXIgYW5jaG9yID0gaW5kZXhGcm9tUG9zKGRvYywgeC5hbmNob3IpO1xuICAgICAgICAgICAgLy8gd29ya2Fyb3VuZCBmb3IgY29kZW1pcnJvciBidWcsIHNlZSBodHRwczovL2dpdGh1Yi5jb20vcmVwbGl0L2NvZGVtaXJyb3ItdmltL2lzc3Vlcy8xNjlcbiAgICAgICAgICAgIGlmIChoZWFkID09IGFuY2hvcilcbiAgICAgICAgICAgICAgICByZXR1cm4gRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihoZWFkLCAxKTtcbiAgICAgICAgICAgIHJldHVybiBFZGl0b3JTZWxlY3Rpb24ucmFuZ2UoYW5jaG9yLCBoZWFkKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY202LmRpc3BhdGNoKHtcbiAgICAgICAgICAgIHNlbGVjdGlvbjogRWRpdG9yU2VsZWN0aW9uLmNyZWF0ZShyYW5nZXMsIHByaW1JbmRleClcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIDtcbiAgICBzZXRTZWxlY3Rpb24oYW5jaG9yLCBoZWFkLCBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuc2V0U2VsZWN0aW9ucyhbeyBhbmNob3IsIGhlYWQgfV0sIDApO1xuICAgICAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLm9yaWdpbiA9PSAnKm1vdXNlJykge1xuICAgICAgICAgICAgdGhpcy5vbkJlZm9yZUVuZE9wZXJhdGlvbigpO1xuICAgICAgICB9XG4gICAgfVxuICAgIDtcbiAgICBnZXRMaW5lKHJvdykge1xuICAgICAgICB2YXIgZG9jID0gdGhpcy5jbTYuc3RhdGUuZG9jO1xuICAgICAgICBpZiAocm93IDwgMCB8fCByb3cgPj0gZG9jLmxpbmVzKVxuICAgICAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICAgIHJldHVybiB0aGlzLmNtNi5zdGF0ZS5kb2MubGluZShyb3cgKyAxKS50ZXh0O1xuICAgIH1cbiAgICA7XG4gICAgZ2V0TGluZUhhbmRsZShyb3cpIHtcbiAgICAgICAgaWYgKCF0aGlzLiRsaW5lSGFuZGxlQ2hhbmdlcylcbiAgICAgICAgICAgIHRoaXMuJGxpbmVIYW5kbGVDaGFuZ2VzID0gW107XG4gICAgICAgIHJldHVybiB7IHJvdzogcm93LCBpbmRleDogdGhpcy5pbmRleEZyb21Qb3MobmV3IFBvcyhyb3csIDApKSB9O1xuICAgIH1cbiAgICBnZXRMaW5lTnVtYmVyKGhhbmRsZSkge1xuICAgICAgICB2YXIgdXBkYXRlcyA9IHRoaXMuJGxpbmVIYW5kbGVDaGFuZ2VzO1xuICAgICAgICBpZiAoIXVwZGF0ZXMpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgdmFyIG9mZnNldCA9IGhhbmRsZS5pbmRleDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB1cGRhdGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBvZmZzZXQgPSB1cGRhdGVzW2ldLmNoYW5nZXMubWFwUG9zKG9mZnNldCwgMSwgTWFwTW9kZS5UcmFja0FmdGVyKTtcbiAgICAgICAgICAgIGlmIChvZmZzZXQgPT0gbnVsbClcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcG9zID0gdGhpcy5wb3NGcm9tSW5kZXgob2Zmc2V0KTtcbiAgICAgICAgcmV0dXJuIHBvcy5jaCA9PSAwID8gcG9zLmxpbmUgOiBudWxsO1xuICAgIH1cbiAgICByZWxlYXNlTGluZUhhbmRsZXMoKSB7XG4gICAgICAgIHRoaXMuJGxpbmVIYW5kbGVDaGFuZ2VzID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBnZXRSYW5nZShzLCBlKSB7XG4gICAgICAgIHZhciBkb2MgPSB0aGlzLmNtNi5zdGF0ZS5kb2M7XG4gICAgICAgIHJldHVybiB0aGlzLmNtNi5zdGF0ZS5zbGljZURvYyhpbmRleEZyb21Qb3MoZG9jLCBzKSwgaW5kZXhGcm9tUG9zKGRvYywgZSkpO1xuICAgIH1cbiAgICA7XG4gICAgcmVwbGFjZVJhbmdlKHRleHQsIHMsIGUsIHNvdXJjZSkge1xuICAgICAgICBpZiAoIWUpXG4gICAgICAgICAgICBlID0gcztcbiAgICAgICAgdmFyIGRvYyA9IHRoaXMuY202LnN0YXRlLmRvYztcbiAgICAgICAgdmFyIGZyb20gPSBpbmRleEZyb21Qb3MoZG9jLCBzKTtcbiAgICAgICAgdmFyIHRvID0gaW5kZXhGcm9tUG9zKGRvYywgZSk7XG4gICAgICAgIGRpc3BhdGNoQ2hhbmdlKHRoaXMsIHsgY2hhbmdlczogeyBmcm9tLCB0bywgaW5zZXJ0OiB0ZXh0IH0gfSk7XG4gICAgfVxuICAgIDtcbiAgICByZXBsYWNlU2VsZWN0aW9uKHRleHQpIHtcbiAgICAgICAgZGlzcGF0Y2hDaGFuZ2UodGhpcywgdGhpcy5jbTYuc3RhdGUucmVwbGFjZVNlbGVjdGlvbih0ZXh0KSk7XG4gICAgfVxuICAgIDtcbiAgICByZXBsYWNlU2VsZWN0aW9ucyhyZXBsYWNlbWVudHMpIHtcbiAgICAgICAgdmFyIHJhbmdlcyA9IHRoaXMuY202LnN0YXRlLnNlbGVjdGlvbi5yYW5nZXM7XG4gICAgICAgIHZhciBjaGFuZ2VzID0gcmFuZ2VzLm1hcCgociwgaSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHsgZnJvbTogci5mcm9tLCB0bzogci50bywgaW5zZXJ0OiByZXBsYWNlbWVudHNbaV0gfHwgXCJcIiB9O1xuICAgICAgICB9KTtcbiAgICAgICAgZGlzcGF0Y2hDaGFuZ2UodGhpcywgeyBjaGFuZ2VzIH0pO1xuICAgIH1cbiAgICA7XG4gICAgZ2V0U2VsZWN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRTZWxlY3Rpb25zKCkuam9pbihcIlxcblwiKTtcbiAgICB9XG4gICAgO1xuICAgIGdldFNlbGVjdGlvbnMoKSB7XG4gICAgICAgIHZhciBjbSA9IHRoaXMuY202O1xuICAgICAgICByZXR1cm4gY20uc3RhdGUuc2VsZWN0aW9uLnJhbmdlcy5tYXAociA9PiBjbS5zdGF0ZS5zbGljZURvYyhyLmZyb20sIHIudG8pKTtcbiAgICB9XG4gICAgO1xuICAgIHNvbWV0aGluZ1NlbGVjdGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jbTYuc3RhdGUuc2VsZWN0aW9uLnJhbmdlcy5zb21lKHIgPT4gIXIuZW1wdHkpO1xuICAgIH1cbiAgICA7XG4gICAgZ2V0SW5wdXRGaWVsZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY202LmNvbnRlbnRET007XG4gICAgfVxuICAgIDtcbiAgICBjbGlwUG9zKHApIHtcbiAgICAgICAgdmFyIGRvYyA9IHRoaXMuY202LnN0YXRlLmRvYztcbiAgICAgICAgdmFyIGNoID0gcC5jaDtcbiAgICAgICAgdmFyIGxpbmVOdW1iZXIgPSBwLmxpbmUgKyAxO1xuICAgICAgICBpZiAobGluZU51bWJlciA8IDEpIHtcbiAgICAgICAgICAgIGxpbmVOdW1iZXIgPSAxO1xuICAgICAgICAgICAgY2ggPSAwO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsaW5lTnVtYmVyID4gZG9jLmxpbmVzKSB7XG4gICAgICAgICAgICBsaW5lTnVtYmVyID0gZG9jLmxpbmVzO1xuICAgICAgICAgICAgY2ggPSBOdW1iZXIuTUFYX1ZBTFVFO1xuICAgICAgICB9XG4gICAgICAgIHZhciBsaW5lID0gZG9jLmxpbmUobGluZU51bWJlcik7XG4gICAgICAgIGNoID0gTWF0aC5taW4oTWF0aC5tYXgoMCwgY2gpLCBsaW5lLnRvIC0gbGluZS5mcm9tKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQb3MobGluZU51bWJlciAtIDEsIGNoKTtcbiAgICB9XG4gICAgO1xuICAgIGdldFZhbHVlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jbTYuc3RhdGUuZG9jLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIDtcbiAgICBzZXRWYWx1ZSh0ZXh0KSB7XG4gICAgICAgIHZhciBjbSA9IHRoaXMuY202O1xuICAgICAgICByZXR1cm4gY20uZGlzcGF0Y2goe1xuICAgICAgICAgICAgY2hhbmdlczogeyBmcm9tOiAwLCB0bzogY20uc3RhdGUuZG9jLmxlbmd0aCwgaW5zZXJ0OiB0ZXh0IH0sXG4gICAgICAgICAgICBzZWxlY3Rpb246IEVkaXRvclNlbGVjdGlvbi5yYW5nZSgwLCAwKVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgO1xuICAgIGZvY3VzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jbTYuZm9jdXMoKTtcbiAgICB9XG4gICAgO1xuICAgIGJsdXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNtNi5jb250ZW50RE9NLmJsdXIoKTtcbiAgICB9XG4gICAgO1xuICAgIGRlZmF1bHRUZXh0SGVpZ2h0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jbTYuZGVmYXVsdExpbmVIZWlnaHQ7XG4gICAgfVxuICAgIDtcbiAgICBmaW5kTWF0Y2hpbmdCcmFja2V0KHBvcywgX29wdGlvbnMpIHtcbiAgICAgICAgdmFyIHN0YXRlID0gdGhpcy5jbTYuc3RhdGU7XG4gICAgICAgIHZhciBvZmZzZXQgPSBpbmRleEZyb21Qb3Moc3RhdGUuZG9jLCBwb3MpO1xuICAgICAgICB2YXIgbSA9IG1hdGNoQnJhY2tldHMoc3RhdGUsIG9mZnNldCArIDEsIC0xKTtcbiAgICAgICAgaWYgKG0gJiYgbS5lbmQpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHRvOiBwb3NGcm9tSW5kZXgoc3RhdGUuZG9jLCBtLmVuZC5mcm9tKSB9O1xuICAgICAgICB9XG4gICAgICAgIG0gPSBtYXRjaEJyYWNrZXRzKHN0YXRlLCBvZmZzZXQsIDEpO1xuICAgICAgICBpZiAobSAmJiBtLmVuZCkge1xuICAgICAgICAgICAgcmV0dXJuIHsgdG86IHBvc0Zyb21JbmRleChzdGF0ZS5kb2MsIG0uZW5kLmZyb20pIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgdG86IHVuZGVmaW5lZCB9O1xuICAgIH1cbiAgICA7XG4gICAgc2NhbkZvckJyYWNrZXQocG9zLCBkaXIsIHN0eWxlLCBjb25maWcpIHtcbiAgICAgICAgcmV0dXJuIHNjYW5Gb3JCcmFja2V0KHRoaXMsIHBvcywgZGlyLCBzdHlsZSwgY29uZmlnKTtcbiAgICB9XG4gICAgO1xuICAgIGluZGVudExpbmUobGluZSwgbW9yZSkge1xuICAgICAgICAvLyB0b2RvIGhvdyB0byBpbmRlbnQgb25seSBvbmUgbGluZSBpbnN0ZWFkIG9mIHNlbGVjdGlvblxuICAgICAgICBpZiAobW9yZSlcbiAgICAgICAgICAgIHRoaXMuaW5kZW50TW9yZSgpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aGlzLmluZGVudExlc3MoKTtcbiAgICB9XG4gICAgO1xuICAgIGluZGVudE1vcmUoKSB7XG4gICAgICAgIGluZGVudE1vcmUodGhpcy5jbTYpO1xuICAgIH1cbiAgICA7XG4gICAgaW5kZW50TGVzcygpIHtcbiAgICAgICAgaW5kZW50TGVzcyh0aGlzLmNtNik7XG4gICAgfVxuICAgIDtcbiAgICBleGVjQ29tbWFuZChuYW1lKSB7XG4gICAgICAgIGlmIChuYW1lID09IFwiaW5kZW50QXV0b1wiKVxuICAgICAgICAgICAgQ29kZU1pcnJvci5jb21tYW5kcy5pbmRlbnRBdXRvKHRoaXMpO1xuICAgICAgICBlbHNlIGlmIChuYW1lID09IFwiZ29MaW5lTGVmdFwiKVxuICAgICAgICAgICAgY3Vyc29yTGluZUJvdW5kYXJ5QmFja3dhcmQodGhpcy5jbTYpO1xuICAgICAgICBlbHNlIGlmIChuYW1lID09IFwiZ29MaW5lUmlnaHRcIikge1xuICAgICAgICAgICAgY3Vyc29yTGluZUJvdW5kYXJ5Rm9yd2FyZCh0aGlzLmNtNik7XG4gICAgICAgICAgICBsZXQgc3RhdGUgPSB0aGlzLmNtNi5zdGF0ZTtcbiAgICAgICAgICAgIGxldCBjdXIgPSBzdGF0ZS5zZWxlY3Rpb24ubWFpbi5oZWFkO1xuICAgICAgICAgICAgaWYgKGN1ciA8IHN0YXRlLmRvYy5sZW5ndGggJiYgc3RhdGUuc2xpY2VEb2MoY3VyLCBjdXIgKyAxKSAhPT0gXCJcXG5cIikge1xuICAgICAgICAgICAgICAgIGN1cnNvckNoYXJCYWNrd2FyZCh0aGlzLmNtNik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgY29uc29sZS5sb2cobmFtZSArIFwiIGlzIG5vdCBpbXBsZW1lbnRlZFwiKTtcbiAgICB9XG4gICAgO1xuICAgIHNldEJvb2ttYXJrKGN1cnNvciwgb3B0aW9ucykge1xuICAgICAgICB2YXIgYXNzb2MgPSAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmluc2VydExlZnQpID8gMSA6IC0xO1xuICAgICAgICB2YXIgb2Zmc2V0ID0gdGhpcy5pbmRleEZyb21Qb3MoY3Vyc29yKTtcbiAgICAgICAgdmFyIGJtID0gbmV3IE1hcmtlcih0aGlzLCBvZmZzZXQsIGFzc29jKTtcbiAgICAgICAgcmV0dXJuIGJtO1xuICAgIH1cbiAgICA7XG4gICAgYWRkT3ZlcmxheSh7IHF1ZXJ5IH0pIHtcbiAgICAgICAgbGV0IGNtNlF1ZXJ5ID0gbmV3IFNlYXJjaFF1ZXJ5KHtcbiAgICAgICAgICAgIHJlZ2V4cDogdHJ1ZSxcbiAgICAgICAgICAgIHNlYXJjaDogcXVlcnkuc291cmNlLFxuICAgICAgICAgICAgY2FzZVNlbnNpdGl2ZTogIS9pLy50ZXN0KHF1ZXJ5LmZsYWdzKSxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChjbTZRdWVyeS52YWxpZCkge1xuICAgICAgICAgICAgY202UXVlcnkuZm9yVmltID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuY202UXVlcnkgPSBjbTZRdWVyeTtcbiAgICAgICAgICAgIGxldCBlZmZlY3QgPSBzZXRTZWFyY2hRdWVyeS5vZihjbTZRdWVyeSk7XG4gICAgICAgICAgICB0aGlzLmNtNi5kaXNwYXRjaCh7IGVmZmVjdHM6IGVmZmVjdCB9KTtcbiAgICAgICAgICAgIHJldHVybiBjbTZRdWVyeTtcbiAgICAgICAgfVxuICAgIH1cbiAgICA7XG4gICAgcmVtb3ZlT3ZlcmxheShvdmVybGF5KSB7XG4gICAgICAgIGlmICghdGhpcy5jbTZRdWVyeSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5jbTZRdWVyeS5mb3JWaW0gPSBmYWxzZTtcbiAgICAgICAgbGV0IGVmZmVjdCA9IHNldFNlYXJjaFF1ZXJ5Lm9mKHRoaXMuY202UXVlcnkpO1xuICAgICAgICB0aGlzLmNtNi5kaXNwYXRjaCh7IGVmZmVjdHM6IGVmZmVjdCB9KTtcbiAgICB9XG4gICAgO1xuICAgIGdldFNlYXJjaEN1cnNvcihxdWVyeSwgcG9zKSB7XG4gICAgICAgIHZhciBjbSA9IHRoaXM7XG4gICAgICAgIHZhciBsYXN0ID0gbnVsbDtcbiAgICAgICAgdmFyIGxhc3RDTTVSZXN1bHQgPSBudWxsO1xuICAgICAgICB2YXIgYWZ0ZXJFbXB0eU1hdGNoID0gZmFsc2U7XG4gICAgICAgIGlmIChwb3MuY2ggPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcG9zLmNoID0gTnVtYmVyLk1BWF9WQUxVRTtcbiAgICAgICAgdmFyIGZpcnN0T2Zmc2V0ID0gaW5kZXhGcm9tUG9zKGNtLmNtNi5zdGF0ZS5kb2MsIHBvcyk7XG4gICAgICAgIHZhciBzb3VyY2UgPSBxdWVyeS5zb3VyY2UucmVwbGFjZSgvKFxcXFwufHsoPzpcXGQrKD86LFxcZCopP3wsXFxkKyl9KXxbe31dL2csIGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICBpZiAoIWIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiXFxcXFwiICsgYTtcbiAgICAgICAgICAgIHJldHVybiBiO1xuICAgICAgICB9KTtcbiAgICAgICAgZnVuY3Rpb24gckN1cnNvcihkb2MsIGZyb20gPSAwLCB0byA9IGRvYy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUmVnRXhwQ3Vyc29yKGRvYywgc291cmNlLCB7IGlnbm9yZUNhc2U6IHF1ZXJ5Lmlnbm9yZUNhc2UgfSwgZnJvbSwgdG8pO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIG5leHRNYXRjaChmcm9tKSB7XG4gICAgICAgICAgICB2YXIgZG9jID0gY20uY202LnN0YXRlLmRvYztcbiAgICAgICAgICAgIGlmIChmcm9tID4gZG9jLmxlbmd0aClcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIGxldCByZXMgPSByQ3Vyc29yKGRvYywgZnJvbSkubmV4dCgpO1xuICAgICAgICAgICAgcmV0dXJuIHJlcy5kb25lID8gbnVsbCA6IHJlcy52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgQ2h1bmtTaXplID0gMTAwMDA7XG4gICAgICAgIGZ1bmN0aW9uIHByZXZNYXRjaEluUmFuZ2UoZnJvbSwgdG8pIHtcbiAgICAgICAgICAgIHZhciBkb2MgPSBjbS5jbTYuc3RhdGUuZG9jO1xuICAgICAgICAgICAgZm9yIChsZXQgc2l6ZSA9IDE7OyBzaXplKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgc3RhcnQgPSBNYXRoLm1heChmcm9tLCB0byAtIHNpemUgKiBDaHVua1NpemUpO1xuICAgICAgICAgICAgICAgIGxldCBjdXJzb3IgPSByQ3Vyc29yKGRvYywgc3RhcnQsIHRvKSwgcmFuZ2UgPSBudWxsO1xuICAgICAgICAgICAgICAgIHdoaWxlICghY3Vyc29yLm5leHQoKS5kb25lKVxuICAgICAgICAgICAgICAgICAgICByYW5nZSA9IGN1cnNvci52YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAocmFuZ2UgJiYgKHN0YXJ0ID09IGZyb20gfHwgcmFuZ2UuZnJvbSA+IHN0YXJ0ICsgMTApKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmFuZ2U7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXJ0ID09IGZyb20pXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBmaW5kTmV4dDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5maW5kKGZhbHNlKTsgfSxcbiAgICAgICAgICAgIGZpbmRQcmV2aW91czogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5maW5kKHRydWUpOyB9LFxuICAgICAgICAgICAgZmluZDogZnVuY3Rpb24gKGJhY2spIHtcbiAgICAgICAgICAgICAgICB2YXIgZG9jID0gY20uY202LnN0YXRlLmRvYztcbiAgICAgICAgICAgICAgICBpZiAoYmFjaykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgZW5kQXQgPSBsYXN0ID8gKGFmdGVyRW1wdHlNYXRjaCA/IGxhc3QudG8gLSAxIDogbGFzdC5mcm9tKSA6IGZpcnN0T2Zmc2V0O1xuICAgICAgICAgICAgICAgICAgICBsYXN0ID0gcHJldk1hdGNoSW5SYW5nZSgwLCBlbmRBdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsZXQgc3RhcnRGcm9tID0gbGFzdCA/IChhZnRlckVtcHR5TWF0Y2ggPyBsYXN0LnRvICsgMSA6IGxhc3QudG8pIDogZmlyc3RPZmZzZXQ7XG4gICAgICAgICAgICAgICAgICAgIGxhc3QgPSBuZXh0TWF0Y2goc3RhcnRGcm9tKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGFzdENNNVJlc3VsdCA9IGxhc3QgJiYge1xuICAgICAgICAgICAgICAgICAgICBmcm9tOiBwb3NGcm9tSW5kZXgoZG9jLCBsYXN0LmZyb20pLFxuICAgICAgICAgICAgICAgICAgICB0bzogcG9zRnJvbUluZGV4KGRvYywgbGFzdC50byksXG4gICAgICAgICAgICAgICAgICAgIG1hdGNoOiBsYXN0Lm1hdGNoLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgYWZ0ZXJFbXB0eU1hdGNoID0gbGFzdCA/IGxhc3QuZnJvbSA9PSBsYXN0LnRvIDogZmFsc2U7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxhc3QgJiYgbGFzdC5tYXRjaDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmcm9tOiBmdW5jdGlvbiAoKSB7IHJldHVybiBsYXN0Q001UmVzdWx0ID09PSBudWxsIHx8IGxhc3RDTTVSZXN1bHQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGxhc3RDTTVSZXN1bHQuZnJvbTsgfSxcbiAgICAgICAgICAgIHRvOiBmdW5jdGlvbiAoKSB7IHJldHVybiBsYXN0Q001UmVzdWx0ID09PSBudWxsIHx8IGxhc3RDTTVSZXN1bHQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGxhc3RDTTVSZXN1bHQudG87IH0sXG4gICAgICAgICAgICByZXBsYWNlOiBmdW5jdGlvbiAodGV4dCkge1xuICAgICAgICAgICAgICAgIGlmIChsYXN0KSB7XG4gICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoQ2hhbmdlKGNtLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFuZ2VzOiB7IGZyb206IGxhc3QuZnJvbSwgdG86IGxhc3QudG8sIGluc2VydDogdGV4dCB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBsYXN0LnRvID0gbGFzdC5mcm9tICsgdGV4dC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsYXN0Q001UmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsYXN0Q001UmVzdWx0LnRvID0gcG9zRnJvbUluZGV4KGNtLmNtNi5zdGF0ZS5kb2MsIGxhc3QudG8pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldCBtYXRjaCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbGFzdENNNVJlc3VsdCAmJiBsYXN0Q001UmVzdWx0Lm1hdGNoO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICA7XG4gICAgZmluZFBvc1Yoc3RhcnQsIGFtb3VudCwgdW5pdCwgZ29hbENvbHVtbikge1xuICAgICAgICBsZXQgeyBjbTYgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IGRvYyA9IGNtNi5zdGF0ZS5kb2M7XG4gICAgICAgIGxldCBwaXhlbHMgPSB1bml0ID09ICdwYWdlJyA/IGNtNi5kb20uY2xpZW50SGVpZ2h0IDogMDtcbiAgICAgICAgY29uc3Qgc3RhcnRPZmZzZXQgPSBpbmRleEZyb21Qb3MoZG9jLCBzdGFydCk7XG4gICAgICAgIGxldCByYW5nZSA9IEVkaXRvclNlbGVjdGlvbi5jdXJzb3Ioc3RhcnRPZmZzZXQsIDEsIHVuZGVmaW5lZCwgZ29hbENvbHVtbik7XG4gICAgICAgIGxldCBjb3VudCA9IE1hdGgucm91bmQoTWF0aC5hYnMoYW1vdW50KSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICAgICAgaWYgKHVuaXQgPT0gJ3BhZ2UnKSB7XG4gICAgICAgICAgICAgICAgcmFuZ2UgPSBjbTYubW92ZVZlcnRpY2FsbHkocmFuZ2UsIGFtb3VudCA+IDAsIHBpeGVscyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh1bml0ID09ICdsaW5lJykge1xuICAgICAgICAgICAgICAgIHJhbmdlID0gY202Lm1vdmVWZXJ0aWNhbGx5KHJhbmdlLCBhbW91bnQgPiAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgcG9zID0gcG9zRnJvbUluZGV4KGRvYywgcmFuZ2UuaGVhZCk7XG4gICAgICAgIC8vIHNldCBoaXRzaWRlIHRvIHRydWUgaWYgdGhlcmUgd2FzIG5vIHBsYWNlIHRvIG1vdmUgYW5kIGN1cnNvciB3YXMgY2xpcHBlZCB0byB0aGUgZWRnZVxuICAgICAgICAvLyBvZiBkb2N1bWVudC4gTmVlZGVkIGZvciBnai9na1xuICAgICAgICBpZiAoKGFtb3VudCA8IDAgJiZcbiAgICAgICAgICAgIHJhbmdlLmhlYWQgPT0gMCAmJiBnb2FsQ29sdW1uICE9IDAgJiZcbiAgICAgICAgICAgIHN0YXJ0LmxpbmUgPT0gMCAmJiBzdGFydC5jaCAhPSAwKSB8fCAoYW1vdW50ID4gMCAmJlxuICAgICAgICAgICAgcmFuZ2UuaGVhZCA9PSBkb2MubGVuZ3RoICYmIHBvcy5jaCAhPSBnb2FsQ29sdW1uXG4gICAgICAgICAgICAmJiBzdGFydC5saW5lID09IHBvcy5saW5lKSkge1xuICAgICAgICAgICAgcG9zLmhpdFNpZGUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwb3M7XG4gICAgfVxuICAgIDtcbiAgICBjaGFyQ29vcmRzKHBvcywgbW9kZSkge1xuICAgICAgICB2YXIgcmVjdCA9IHRoaXMuY202LmNvbnRlbnRET00uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIHZhciBvZmZzZXQgPSBpbmRleEZyb21Qb3ModGhpcy5jbTYuc3RhdGUuZG9jLCBwb3MpO1xuICAgICAgICB2YXIgY29vcmRzID0gdGhpcy5jbTYuY29vcmRzQXRQb3Mob2Zmc2V0KTtcbiAgICAgICAgdmFyIGQgPSAtcmVjdC50b3A7XG4gICAgICAgIHJldHVybiB7IGxlZnQ6ICgoY29vcmRzID09PSBudWxsIHx8IGNvb3JkcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29vcmRzLmxlZnQpIHx8IDApIC0gcmVjdC5sZWZ0LCB0b3A6ICgoY29vcmRzID09PSBudWxsIHx8IGNvb3JkcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29vcmRzLnRvcCkgfHwgMCkgKyBkLCBib3R0b206ICgoY29vcmRzID09PSBudWxsIHx8IGNvb3JkcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29vcmRzLmJvdHRvbSkgfHwgMCkgKyBkIH07XG4gICAgfVxuICAgIDtcbiAgICBjb29yZHNDaGFyKGNvb3JkcywgbW9kZSkge1xuICAgICAgICB2YXIgcmVjdCA9IHRoaXMuY202LmNvbnRlbnRET00uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIHZhciBvZmZzZXQgPSB0aGlzLmNtNi5wb3NBdENvb3Jkcyh7IHg6IGNvb3Jkcy5sZWZ0ICsgcmVjdC5sZWZ0LCB5OiBjb29yZHMudG9wICsgcmVjdC50b3AgfSkgfHwgMDtcbiAgICAgICAgcmV0dXJuIHBvc0Zyb21JbmRleCh0aGlzLmNtNi5zdGF0ZS5kb2MsIG9mZnNldCk7XG4gICAgfVxuICAgIDtcbiAgICBnZXRTY3JvbGxJbmZvKCkge1xuICAgICAgICB2YXIgc2Nyb2xsZXIgPSB0aGlzLmNtNi5zY3JvbGxET007XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsZWZ0OiBzY3JvbGxlci5zY3JvbGxMZWZ0LCB0b3A6IHNjcm9sbGVyLnNjcm9sbFRvcCxcbiAgICAgICAgICAgIGhlaWdodDogc2Nyb2xsZXIuc2Nyb2xsSGVpZ2h0LFxuICAgICAgICAgICAgd2lkdGg6IHNjcm9sbGVyLnNjcm9sbFdpZHRoLFxuICAgICAgICAgICAgY2xpZW50SGVpZ2h0OiBzY3JvbGxlci5jbGllbnRIZWlnaHQsIGNsaWVudFdpZHRoOiBzY3JvbGxlci5jbGllbnRXaWR0aFxuICAgICAgICB9O1xuICAgIH1cbiAgICA7XG4gICAgc2Nyb2xsVG8oeCwgeSkge1xuICAgICAgICBpZiAoeCAhPSBudWxsKVxuICAgICAgICAgICAgdGhpcy5jbTYuc2Nyb2xsRE9NLnNjcm9sbExlZnQgPSB4O1xuICAgICAgICBpZiAoeSAhPSBudWxsKVxuICAgICAgICAgICAgdGhpcy5jbTYuc2Nyb2xsRE9NLnNjcm9sbFRvcCA9IHk7XG4gICAgfVxuICAgIDtcbiAgICBzY3JvbGxJbnRvVmlldyhwb3MsIG1hcmdpbikge1xuICAgICAgICBpZiAocG9zKSB7XG4gICAgICAgICAgICB2YXIgb2Zmc2V0ID0gdGhpcy5pbmRleEZyb21Qb3MocG9zKTtcbiAgICAgICAgICAgIHRoaXMuY202LmRpc3BhdGNoKHtcbiAgICAgICAgICAgICAgICBlZmZlY3RzOiBFZGl0b3JWaWV3LnNjcm9sbEludG9WaWV3KG9mZnNldClcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jbTYuZGlzcGF0Y2goeyBzY3JvbGxJbnRvVmlldzogdHJ1ZSwgdXNlckV2ZW50OiBcInNjcm9sbFwiIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIDtcbiAgICBnZXRXcmFwcGVyRWxlbWVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY202LmRvbTtcbiAgICB9XG4gICAgO1xuICAgIC8vIGZvciB0ZXN0c1xuICAgIGdldE1vZGUoKSB7XG4gICAgICAgIHJldHVybiB7IG5hbWU6IHRoaXMuZ2V0T3B0aW9uKFwibW9kZVwiKSB9O1xuICAgIH1cbiAgICA7XG4gICAgc2V0U2l6ZSh3LCBoKSB7XG4gICAgICAgIHRoaXMuY202LmRvbS5zdHlsZS53aWR0aCA9IHcgKyA0ICsgXCJweFwiO1xuICAgICAgICB0aGlzLmNtNi5kb20uc3R5bGUuaGVpZ2h0ID0gaCArIFwicHhcIjtcbiAgICAgICAgdGhpcy5yZWZyZXNoKCk7XG4gICAgfVxuICAgIHJlZnJlc2goKSB7XG4gICAgICAgIHRoaXMuY202Lm1lYXN1cmUoKTtcbiAgICB9XG4gICAgLy8gZXZlbnQgbGlzdGVuZXJzXG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVPdmVybGF5KCk7XG4gICAgfVxuICAgIDtcbiAgICBnZXRMYXN0RWRpdEVuZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucG9zRnJvbUluZGV4KHRoaXMuJGxhc3RDaGFuZ2VFbmRPZmZzZXQpO1xuICAgIH1cbiAgICA7XG4gICAgb25DaGFuZ2UodXBkYXRlKSB7XG4gICAgICAgIGlmICh0aGlzLiRsaW5lSGFuZGxlQ2hhbmdlcykge1xuICAgICAgICAgICAgdGhpcy4kbGluZUhhbmRsZUNoYW5nZXMucHVzaCh1cGRhdGUpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgaW4gdGhpcy5tYXJrcykge1xuICAgICAgICAgICAgbGV0IG0gPSB0aGlzLm1hcmtzW2ldO1xuICAgICAgICAgICAgbS51cGRhdGUodXBkYXRlLmNoYW5nZXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnZpcnR1YWxTZWxlY3Rpb24pIHtcbiAgICAgICAgICAgIHRoaXMudmlydHVhbFNlbGVjdGlvbi5yYW5nZXMgPSB0aGlzLnZpcnR1YWxTZWxlY3Rpb24ucmFuZ2VzLm1hcChyYW5nZSA9PiByYW5nZS5tYXAodXBkYXRlLmNoYW5nZXMpKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY3VyT3AgPSB0aGlzLmN1ck9wID0gdGhpcy5jdXJPcCB8fCB7fTtcbiAgICAgICAgdXBkYXRlLmNoYW5nZXMuaXRlckNoYW5nZXMoKGZyb21BLCB0b0EsIGZyb21CLCB0b0IsIHRleHQpID0+IHtcbiAgICAgICAgICAgIGlmIChjdXJPcC4kY2hhbmdlU3RhcnQgPT0gbnVsbCB8fCBjdXJPcC4kY2hhbmdlU3RhcnQgPiBmcm9tQilcbiAgICAgICAgICAgICAgICBjdXJPcC4kY2hhbmdlU3RhcnQgPSBmcm9tQjtcbiAgICAgICAgICAgIHRoaXMuJGxhc3RDaGFuZ2VFbmRPZmZzZXQgPSB0b0I7XG4gICAgICAgICAgICB2YXIgY2hhbmdlID0geyB0ZXh0OiB0ZXh0LnRvSlNPTigpIH07XG4gICAgICAgICAgICBpZiAoIWN1ck9wLmxhc3RDaGFuZ2UpIHtcbiAgICAgICAgICAgICAgICBjdXJPcC5sYXN0Q2hhbmdlID0gY3VyT3AuY2hhbmdlID0gY2hhbmdlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY3VyT3AubGFzdENoYW5nZS5uZXh0ID0gY3VyT3AubGFzdENoYW5nZSA9IGNoYW5nZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgdHJ1ZSk7XG4gICAgICAgIGlmICghY3VyT3AuY2hhbmdlSGFuZGxlcnMpXG4gICAgICAgICAgICBjdXJPcC5jaGFuZ2VIYW5kbGVycyA9IHRoaXMuX2hhbmRsZXJzW1wiY2hhbmdlXCJdICYmIHRoaXMuX2hhbmRsZXJzW1wiY2hhbmdlXCJdLnNsaWNlKCk7XG4gICAgfVxuICAgIDtcbiAgICBvblNlbGVjdGlvbkNoYW5nZSgpIHtcbiAgICAgICAgdmFyIGN1ck9wID0gdGhpcy5jdXJPcCA9IHRoaXMuY3VyT3AgfHwge307XG4gICAgICAgIGlmICghY3VyT3AuY3Vyc29yQWN0aXZpdHlIYW5kbGVycylcbiAgICAgICAgICAgIGN1ck9wLmN1cnNvckFjdGl2aXR5SGFuZGxlcnMgPSB0aGlzLl9oYW5kbGVyc1tcImN1cnNvckFjdGl2aXR5XCJdICYmIHRoaXMuX2hhbmRsZXJzW1wiY3Vyc29yQWN0aXZpdHlcIl0uc2xpY2UoKTtcbiAgICAgICAgdGhpcy5jdXJPcC5jdXJzb3JBY3Rpdml0eSA9IHRydWU7XG4gICAgfVxuICAgIDtcbiAgICBvcGVyYXRpb24oZm4sIGZvcmNlKSB7XG4gICAgICAgIGlmICghdGhpcy5jdXJPcClcbiAgICAgICAgICAgIHRoaXMuY3VyT3AgPSB7ICRkOiAwIH07XG4gICAgICAgIHRoaXMuY3VyT3AuJGQrKztcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBmbigpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgaWYgKHRoaXMuY3VyT3ApIHtcbiAgICAgICAgICAgICAgICB0aGlzLmN1ck9wLiRkLS07XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmN1ck9wLiRkKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLm9uQmVmb3JlRW5kT3BlcmF0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgO1xuICAgIG9uQmVmb3JlRW5kT3BlcmF0aW9uKCkge1xuICAgICAgICB2YXIgb3AgPSB0aGlzLmN1ck9wO1xuICAgICAgICB2YXIgc2Nyb2xsSW50b1ZpZXcgPSBmYWxzZTtcbiAgICAgICAgaWYgKG9wKSB7XG4gICAgICAgICAgICBpZiAob3AuY2hhbmdlKSB7XG4gICAgICAgICAgICAgICAgc2lnbmFsVG8ob3AuY2hhbmdlSGFuZGxlcnMsIHRoaXMsIG9wLmNoYW5nZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3AgJiYgb3AuY3Vyc29yQWN0aXZpdHkpIHtcbiAgICAgICAgICAgICAgICBzaWduYWxUbyhvcC5jdXJzb3JBY3Rpdml0eUhhbmRsZXJzLCB0aGlzLCBudWxsKTtcbiAgICAgICAgICAgICAgICBpZiAob3AuaXNWaW1PcClcbiAgICAgICAgICAgICAgICAgICAgc2Nyb2xsSW50b1ZpZXcgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jdXJPcCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNjcm9sbEludG9WaWV3KVxuICAgICAgICAgICAgdGhpcy5zY3JvbGxJbnRvVmlldygpO1xuICAgIH1cbiAgICA7XG4gICAgbW92ZUgoaW5jcmVtZW50LCB1bml0KSB7XG4gICAgICAgIGlmICh1bml0ID09ICdjaGFyJykge1xuICAgICAgICAgICAgLy8gdG9kb1xuICAgICAgICAgICAgdmFyIGN1ciA9IHRoaXMuZ2V0Q3Vyc29yKCk7XG4gICAgICAgICAgICB0aGlzLnNldEN1cnNvcihjdXIubGluZSwgY3VyLmNoICsgaW5jcmVtZW50KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICA7XG4gICAgc2V0T3B0aW9uKG5hbWUsIHZhbCkge1xuICAgICAgICBzd2l0Y2ggKG5hbWUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJrZXlNYXBcIjpcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLmtleU1hcCA9IHZhbDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJ0ZXh0d2lkdGhcIjpcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLnRleHR3aWR0aCA9IHZhbDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICA7XG4gICAgZ2V0T3B0aW9uKG5hbWUpIHtcbiAgICAgICAgc3dpdGNoIChuYW1lKSB7XG4gICAgICAgICAgICBjYXNlIFwiZmlyc3RMaW5lTnVtYmVyXCI6IHJldHVybiAxO1xuICAgICAgICAgICAgY2FzZSBcInRhYlNpemVcIjogcmV0dXJuIHRoaXMuY202LnN0YXRlLnRhYlNpemUgfHwgNDtcbiAgICAgICAgICAgIGNhc2UgXCJyZWFkT25seVwiOiByZXR1cm4gdGhpcy5jbTYuc3RhdGUucmVhZE9ubHk7XG4gICAgICAgICAgICBjYXNlIFwiaW5kZW50V2l0aFRhYnNcIjogcmV0dXJuIHRoaXMuY202LnN0YXRlLmZhY2V0KGluZGVudFVuaXQpID09IFwiXFx0XCI7IC8vIFRPRE9cbiAgICAgICAgICAgIGNhc2UgXCJpbmRlbnRVbml0XCI6IHJldHVybiB0aGlzLmNtNi5zdGF0ZS5mYWNldChpbmRlbnRVbml0KS5sZW5ndGggfHwgMjtcbiAgICAgICAgICAgIGNhc2UgXCJ0ZXh0d2lkdGhcIjogcmV0dXJuIHRoaXMuc3RhdGUudGV4dHdpZHRoO1xuICAgICAgICAgICAgLy8gZm9yIHRlc3RzXG4gICAgICAgICAgICBjYXNlIFwia2V5TWFwXCI6IHJldHVybiB0aGlzLnN0YXRlLmtleU1hcCB8fCBcInZpbVwiO1xuICAgICAgICB9XG4gICAgfVxuICAgIDtcbiAgICB0b2dnbGVPdmVyd3JpdGUob24pIHtcbiAgICAgICAgdGhpcy5zdGF0ZS5vdmVyd3JpdGUgPSBvbjtcbiAgICB9XG4gICAgO1xuICAgIGdldFRva2VuVHlwZUF0KHBvcykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIC8vIG9ubHkgY29tbWVudHxzdHJpbmcgYXJlIG5lZWRlZFxuICAgICAgICB2YXIgb2Zmc2V0ID0gdGhpcy5pbmRleEZyb21Qb3MocG9zKTtcbiAgICAgICAgdmFyIHRyZWUgPSBlbnN1cmVTeW50YXhUcmVlKHRoaXMuY202LnN0YXRlLCBvZmZzZXQpO1xuICAgICAgICB2YXIgbm9kZSA9IHRyZWUgPT09IG51bGwgfHwgdHJlZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogdHJlZS5yZXNvbHZlKG9mZnNldCk7XG4gICAgICAgIHZhciB0eXBlID0gKChfYSA9IG5vZGUgPT09IG51bGwgfHwgbm9kZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogbm9kZS50eXBlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubmFtZSkgfHwgXCJcIjtcbiAgICAgICAgaWYgKC9jb21tZW50L2kudGVzdCh0eXBlKSlcbiAgICAgICAgICAgIHJldHVybiBcImNvbW1lbnRcIjtcbiAgICAgICAgaWYgKC9zdHJpbmcvaS50ZXN0KHR5cGUpKVxuICAgICAgICAgICAgcmV0dXJuIFwic3RyaW5nXCI7XG4gICAgICAgIHJldHVybiBcIlwiO1xuICAgIH1cbiAgICA7XG4gICAgb3ZlcldyaXRlU2VsZWN0aW9uKHRleHQpIHtcbiAgICAgICAgdmFyIGRvYyA9IHRoaXMuY202LnN0YXRlLmRvYztcbiAgICAgICAgdmFyIHNlbCA9IHRoaXMuY202LnN0YXRlLnNlbGVjdGlvbjtcbiAgICAgICAgdmFyIHJhbmdlcyA9IHNlbC5yYW5nZXMubWFwKHggPT4ge1xuICAgICAgICAgICAgaWYgKHguZW1wdHkpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2ggPSB4LnRvIDwgZG9jLmxlbmd0aCA/IGRvYy5zbGljZVN0cmluZyh4LmZyb20sIHgudG8gKyAxKSA6IFwiXCI7XG4gICAgICAgICAgICAgICAgaWYgKGNoICYmICEvXFxuLy50ZXN0KGNoKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEVkaXRvclNlbGVjdGlvbi5yYW5nZSh4LmZyb20sIHgudG8gKyAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB4O1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jbTYuZGlzcGF0Y2goe1xuICAgICAgICAgICAgc2VsZWN0aW9uOiBFZGl0b3JTZWxlY3Rpb24uY3JlYXRlKHJhbmdlcywgc2VsLm1haW5JbmRleClcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucmVwbGFjZVNlbGVjdGlvbih0ZXh0KTtcbiAgICB9XG4gICAgLyoqKiBtdWx0aXNlbGVjdCAqKioqL1xuICAgIGlzSW5NdWx0aVNlbGVjdE1vZGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNtNi5zdGF0ZS5zZWxlY3Rpb24ucmFuZ2VzLmxlbmd0aCA+IDE7XG4gICAgfVxuICAgIHZpcnR1YWxTZWxlY3Rpb25Nb2RlKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLnZpcnR1YWxTZWxlY3Rpb247XG4gICAgfVxuICAgIGZvckVhY2hTZWxlY3Rpb24oY29tbWFuZCkge1xuICAgICAgICB2YXIgc2VsZWN0aW9uID0gdGhpcy5jbTYuc3RhdGUuc2VsZWN0aW9uO1xuICAgICAgICB0aGlzLnZpcnR1YWxTZWxlY3Rpb24gPSBFZGl0b3JTZWxlY3Rpb24uY3JlYXRlKHNlbGVjdGlvbi5yYW5nZXMsIHNlbGVjdGlvbi5tYWluSW5kZXgpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMudmlydHVhbFNlbGVjdGlvbi5yYW5nZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciByYW5nZSA9IHRoaXMudmlydHVhbFNlbGVjdGlvbi5yYW5nZXNbaV07XG4gICAgICAgICAgICBpZiAoIXJhbmdlKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgdGhpcy5jbTYuZGlzcGF0Y2goeyBzZWxlY3Rpb246IEVkaXRvclNlbGVjdGlvbi5jcmVhdGUoW3JhbmdlXSkgfSk7XG4gICAgICAgICAgICBjb21tYW5kKCk7XG4gICAgICAgICAgICB0aGlzLnZpcnR1YWxTZWxlY3Rpb24ucmFuZ2VzW2ldID0gdGhpcy5jbTYuc3RhdGUuc2VsZWN0aW9uLnJhbmdlc1swXTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNtNi5kaXNwYXRjaCh7IHNlbGVjdGlvbjogdGhpcy52aXJ0dWFsU2VsZWN0aW9uIH0pO1xuICAgICAgICB0aGlzLnZpcnR1YWxTZWxlY3Rpb24gPSBudWxsO1xuICAgIH1cbiAgICBoYXJkV3JhcChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBoYXJkV3JhcCh0aGlzLCBvcHRpb25zKTtcbiAgICB9XG59XG5Db2RlTWlycm9yLmlzTWFjID0gdHlwZW9mIG5hdmlnYXRvciAhPSBcInVuZGVmaW5lZFwiICYmIC8qQF9fUFVSRV9fKi8vTWFjLy50ZXN0KG5hdmlnYXRvci5wbGF0Zm9ybSk7XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuQ29kZU1pcnJvci5Qb3MgPSBQb3M7XG5Db2RlTWlycm9yLlN0cmluZ1N0cmVhbSA9IFN0cmluZ1N0cmVhbTtcbkNvZGVNaXJyb3IuY29tbWFuZHMgPSB7XG4gICAgY3Vyc29yQ2hhckxlZnQ6IGZ1bmN0aW9uIChjbSkgeyBjdXJzb3JDaGFyTGVmdChjbS5jbTYpOyB9LFxuICAgIHJlZG86IGZ1bmN0aW9uIChjbSkgeyBydW5IaXN0b3J5Q29tbWFuZChjbSwgZmFsc2UpOyB9LFxuICAgIHVuZG86IGZ1bmN0aW9uIChjbSkgeyBydW5IaXN0b3J5Q29tbWFuZChjbSwgdHJ1ZSk7IH0sXG4gICAgbmV3bGluZUFuZEluZGVudDogZnVuY3Rpb24gKGNtKSB7XG4gICAgICAgIGluc2VydE5ld2xpbmVBbmRJbmRlbnQoe1xuICAgICAgICAgICAgc3RhdGU6IGNtLmNtNi5zdGF0ZSxcbiAgICAgICAgICAgIGRpc3BhdGNoOiAodHIpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGlzcGF0Y2hDaGFuZ2UoY20sIHRyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSxcbiAgICBpbmRlbnRBdXRvOiBmdW5jdGlvbiAoY20pIHtcbiAgICAgICAgaW5kZW50U2VsZWN0aW9uKGNtLmNtNik7XG4gICAgfSxcbiAgICBuZXdsaW5lQW5kSW5kZW50Q29udGludWVDb21tZW50OiB1bmRlZmluZWQsXG4gICAgc2F2ZTogdW5kZWZpbmVkLFxufTtcbkNvZGVNaXJyb3IuaXNXb3JkQ2hhciA9IGZ1bmN0aW9uIChjaCkge1xuICAgIHJldHVybiB3b3JkQ2hhci50ZXN0KGNoKTtcbn07XG5Db2RlTWlycm9yLmtleXMgPSBrZXlzO1xuQ29kZU1pcnJvci5hZGRDbGFzcyA9IGZ1bmN0aW9uIChlbCwgc3RyKSB7IH07XG5Db2RlTWlycm9yLnJtQ2xhc3MgPSBmdW5jdGlvbiAoZWwsIHN0cikgeyB9O1xuQ29kZU1pcnJvci5lX3ByZXZlbnREZWZhdWx0ID0gZnVuY3Rpb24gKGUpIHtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG59O1xuQ29kZU1pcnJvci5lX3N0b3AgPSBmdW5jdGlvbiAoZSkge1xuICAgIHZhciBfYSwgX2I7XG4gICAgKF9hID0gZSA9PT0gbnVsbCB8fCBlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlLnN0b3BQcm9wYWdhdGlvbikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwoZSk7XG4gICAgKF9iID0gZSA9PT0gbnVsbCB8fCBlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlLnByZXZlbnREZWZhdWx0KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChlKTtcbn07XG5Db2RlTWlycm9yLmxvb2t1cEtleSA9IGZ1bmN0aW9uIGxvb2t1cEtleShrZXksIG1hcCwgaGFuZGxlKSB7XG4gICAgdmFyIHJlc3VsdCA9IENvZGVNaXJyb3Iua2V5c1trZXldO1xuICAgIGlmICghcmVzdWx0ICYmIC9eQXJyb3cvLnRlc3Qoa2V5KSlcbiAgICAgICAgcmVzdWx0ID0gQ29kZU1pcnJvci5rZXlzW2tleS5zbGljZSg1KV07XG4gICAgaWYgKHJlc3VsdClcbiAgICAgICAgaGFuZGxlKHJlc3VsdCk7XG59O1xuQ29kZU1pcnJvci5vbiA9IG9uO1xuQ29kZU1pcnJvci5vZmYgPSBvZmY7XG5Db2RlTWlycm9yLnNpZ25hbCA9IHNpZ25hbDtcbkNvZGVNaXJyb3IuZmluZE1hdGNoaW5nVGFnID0gZmluZE1hdGNoaW5nVGFnO1xuQ29kZU1pcnJvci5maW5kRW5jbG9zaW5nVGFnID0gZmluZEVuY2xvc2luZ1RhZztcbkNvZGVNaXJyb3Iua2V5TmFtZSA9IHVuZGVmaW5lZDtcbi8qKioqKioqKioqKioqIGRpYWxvZyAqKioqKioqKioqKioqL1xuZnVuY3Rpb24gZGlhbG9nRGl2KGNtLCB0ZW1wbGF0ZSwgYm90dG9tKSB7XG4gICAgdmFyIGRpYWxvZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgZGlhbG9nLmFwcGVuZENoaWxkKHRlbXBsYXRlKTtcbiAgICByZXR1cm4gZGlhbG9nO1xufVxuZnVuY3Rpb24gY2xvc2VOb3RpZmljYXRpb24oY20sIG5ld1ZhbCkge1xuICAgIGlmIChjbS5zdGF0ZS5jdXJyZW50Tm90aWZpY2F0aW9uQ2xvc2UpXG4gICAgICAgIGNtLnN0YXRlLmN1cnJlbnROb3RpZmljYXRpb25DbG9zZSgpO1xuICAgIGNtLnN0YXRlLmN1cnJlbnROb3RpZmljYXRpb25DbG9zZSA9IG5ld1ZhbDtcbn1cbmZ1bmN0aW9uIG9wZW5Ob3RpZmljYXRpb24oY20sIHRlbXBsYXRlLCBvcHRpb25zKSB7XG4gICAgY2xvc2VOb3RpZmljYXRpb24oY20sIGNsb3NlKTtcbiAgICB2YXIgZGlhbG9nID0gZGlhbG9nRGl2KGNtLCB0ZW1wbGF0ZSwgb3B0aW9ucyAmJiBvcHRpb25zLmJvdHRvbSk7XG4gICAgdmFyIGNsb3NlZCA9IGZhbHNlO1xuICAgIHZhciBkb25lVGltZXI7XG4gICAgdmFyIGR1cmF0aW9uID0gb3B0aW9ucyAmJiB0eXBlb2Ygb3B0aW9ucy5kdXJhdGlvbiAhPT0gXCJ1bmRlZmluZWRcIiA/IG9wdGlvbnMuZHVyYXRpb24gOiA1MDAwO1xuICAgIGZ1bmN0aW9uIGNsb3NlKCkge1xuICAgICAgICBpZiAoY2xvc2VkKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjbG9zZWQgPSB0cnVlO1xuICAgICAgICBjbGVhclRpbWVvdXQoZG9uZVRpbWVyKTtcbiAgICAgICAgZGlhbG9nLnJlbW92ZSgpO1xuICAgICAgICBoaWRlRGlhbG9nKGNtLCBkaWFsb2cpO1xuICAgIH1cbiAgICBkaWFsb2cub25jbGljayA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgY2xvc2UoKTtcbiAgICB9O1xuICAgIHNob3dEaWFsb2coY20sIGRpYWxvZyk7XG4gICAgaWYgKGR1cmF0aW9uKVxuICAgICAgICBkb25lVGltZXIgPSBzZXRUaW1lb3V0KGNsb3NlLCBkdXJhdGlvbik7XG4gICAgcmV0dXJuIGNsb3NlO1xufVxuZnVuY3Rpb24gc2hvd0RpYWxvZyhjbSwgZGlhbG9nKSB7XG4gICAgdmFyIG9sZERpYWxvZyA9IGNtLnN0YXRlLmRpYWxvZztcbiAgICBjbS5zdGF0ZS5kaWFsb2cgPSBkaWFsb2c7XG4gICAgZGlhbG9nLnN0eWxlLmZsZXggPSBcIjFcIjtcbiAgICBpZiAoZGlhbG9nICYmIG9sZERpYWxvZyAhPT0gZGlhbG9nKSB7XG4gICAgICAgIGlmIChvbGREaWFsb2cgJiYgb2xkRGlhbG9nLmNvbnRhaW5zKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpKVxuICAgICAgICAgICAgY20uZm9jdXMoKTtcbiAgICAgICAgaWYgKG9sZERpYWxvZyAmJiBvbGREaWFsb2cucGFyZW50RWxlbWVudCkge1xuICAgICAgICAgICAgb2xkRGlhbG9nLnBhcmVudEVsZW1lbnQucmVwbGFjZUNoaWxkKGRpYWxvZywgb2xkRGlhbG9nKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvbGREaWFsb2cpIHtcbiAgICAgICAgICAgIG9sZERpYWxvZy5yZW1vdmUoKTtcbiAgICAgICAgfVxuICAgICAgICBDb2RlTWlycm9yLnNpZ25hbChjbSwgXCJkaWFsb2dcIik7XG4gICAgfVxufVxuZnVuY3Rpb24gaGlkZURpYWxvZyhjbSwgZGlhbG9nKSB7XG4gICAgaWYgKGNtLnN0YXRlLmRpYWxvZyA9PSBkaWFsb2cpIHtcbiAgICAgICAgY20uc3RhdGUuZGlhbG9nID0gbnVsbDtcbiAgICAgICAgQ29kZU1pcnJvci5zaWduYWwoY20sIFwiZGlhbG9nXCIpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIG9wZW5EaWFsb2cobWUsIHRlbXBsYXRlLCBjYWxsYmFjaywgb3B0aW9ucykge1xuICAgIGlmICghb3B0aW9ucylcbiAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgIGNsb3NlTm90aWZpY2F0aW9uKG1lLCB1bmRlZmluZWQpO1xuICAgIHZhciBkaWFsb2cgPSBkaWFsb2dEaXYobWUsIHRlbXBsYXRlLCBvcHRpb25zLmJvdHRvbSk7XG4gICAgdmFyIGNsb3NlZCA9IGZhbHNlO1xuICAgIHNob3dEaWFsb2cobWUsIGRpYWxvZyk7XG4gICAgZnVuY3Rpb24gY2xvc2UobmV3VmFsKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbmV3VmFsID09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBpbnAudmFsdWUgPSBuZXdWYWw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoY2xvc2VkKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGNsb3NlZCA9IHRydWU7XG4gICAgICAgICAgICBoaWRlRGlhbG9nKG1lLCBkaWFsb2cpO1xuICAgICAgICAgICAgaWYgKCFtZS5zdGF0ZS5kaWFsb2cpXG4gICAgICAgICAgICAgICAgbWUuZm9jdXMoKTtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLm9uQ2xvc2UpXG4gICAgICAgICAgICAgICAgb3B0aW9ucy5vbkNsb3NlKGRpYWxvZyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFyIGlucCA9IGRpYWxvZy5nZXRFbGVtZW50c0J5VGFnTmFtZShcImlucHV0XCIpWzBdO1xuICAgIGlmIChpbnApIHtcbiAgICAgICAgaWYgKG9wdGlvbnMudmFsdWUpIHtcbiAgICAgICAgICAgIGlucC52YWx1ZSA9IG9wdGlvbnMudmFsdWU7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5zZWxlY3RWYWx1ZU9uT3BlbiAhPT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgaW5wLnNlbGVjdCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLm9uSW5wdXQpXG4gICAgICAgICAgICBDb2RlTWlycm9yLm9uKGlucCwgXCJpbnB1dFwiLCBmdW5jdGlvbiAoZSkgeyBvcHRpb25zLm9uSW5wdXQoZSwgaW5wLnZhbHVlLCBjbG9zZSk7IH0pO1xuICAgICAgICBpZiAob3B0aW9ucy5vbktleVVwKVxuICAgICAgICAgICAgQ29kZU1pcnJvci5vbihpbnAsIFwia2V5dXBcIiwgZnVuY3Rpb24gKGUpIHsgb3B0aW9ucy5vbktleVVwKGUsIGlucC52YWx1ZSwgY2xvc2UpOyB9KTtcbiAgICAgICAgQ29kZU1pcnJvci5vbihpbnAsIFwia2V5ZG93blwiLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5vbktleURvd24gJiYgb3B0aW9ucy5vbktleURvd24oZSwgaW5wLnZhbHVlLCBjbG9zZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZS5rZXlDb2RlID09IDEzKVxuICAgICAgICAgICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKGlucC52YWx1ZSk7XG4gICAgICAgICAgICBpZiAoZS5rZXlDb2RlID09IDI3IHx8IChvcHRpb25zLmNsb3NlT25FbnRlciAhPT0gZmFsc2UgJiYgZS5rZXlDb2RlID09IDEzKSkge1xuICAgICAgICAgICAgICAgIGlucC5ibHVyKCk7XG4gICAgICAgICAgICAgICAgQ29kZU1pcnJvci5lX3N0b3AoZSk7XG4gICAgICAgICAgICAgICAgY2xvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChvcHRpb25zLmNsb3NlT25CbHVyICE9PSBmYWxzZSlcbiAgICAgICAgICAgIENvZGVNaXJyb3Iub24oaW5wLCBcImJsdXJcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCA9PT0gaW5wKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICBjbG9zZSgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIGlucC5mb2N1cygpO1xuICAgIH1cbiAgICByZXR1cm4gY2xvc2U7XG59XG52YXIgbWF0Y2hpbmcgPSB7IFwiKFwiOiBcIik+XCIsIFwiKVwiOiBcIig8XCIsIFwiW1wiOiBcIl0+XCIsIFwiXVwiOiBcIls8XCIsIFwie1wiOiBcIn0+XCIsIFwifVwiOiBcIns8XCIsIFwiPFwiOiBcIj4+XCIsIFwiPlwiOiBcIjw8XCIgfTtcbmZ1bmN0aW9uIGJyYWNrZXRSZWdleChjb25maWcpIHtcbiAgICByZXR1cm4gY29uZmlnICYmIGNvbmZpZy5icmFja2V0UmVnZXggfHwgL1soKXt9W1xcXV0vO1xufVxuZnVuY3Rpb24gc2NhbkZvckJyYWNrZXQoY20sIHdoZXJlLCBkaXIsIHN0eWxlLCBjb25maWcpIHtcbiAgICB2YXIgbWF4U2NhbkxlbiA9IChjb25maWcgJiYgY29uZmlnLm1heFNjYW5MaW5lTGVuZ3RoKSB8fCAxMDAwMDtcbiAgICB2YXIgbWF4U2NhbkxpbmVzID0gKGNvbmZpZyAmJiBjb25maWcubWF4U2NhbkxpbmVzKSB8fCAxMDAwO1xuICAgIHZhciBzdGFjayA9IFtdO1xuICAgIHZhciByZSA9IGJyYWNrZXRSZWdleChjb25maWcpO1xuICAgIHZhciBsaW5lRW5kID0gZGlyID4gMCA/IE1hdGgubWluKHdoZXJlLmxpbmUgKyBtYXhTY2FuTGluZXMsIGNtLmxhc3RMaW5lKCkgKyAxKVxuICAgICAgICA6IE1hdGgubWF4KGNtLmZpcnN0TGluZSgpIC0gMSwgd2hlcmUubGluZSAtIG1heFNjYW5MaW5lcyk7XG4gICAgZm9yICh2YXIgbGluZU5vID0gd2hlcmUubGluZTsgbGluZU5vICE9IGxpbmVFbmQ7IGxpbmVObyArPSBkaXIpIHtcbiAgICAgICAgdmFyIGxpbmUgPSBjbS5nZXRMaW5lKGxpbmVObyk7XG4gICAgICAgIGlmICghbGluZSlcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB2YXIgcG9zID0gZGlyID4gMCA/IDAgOiBsaW5lLmxlbmd0aCAtIDEsIGVuZCA9IGRpciA+IDAgPyBsaW5lLmxlbmd0aCA6IC0xO1xuICAgICAgICBpZiAobGluZS5sZW5ndGggPiBtYXhTY2FuTGVuKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIGlmIChsaW5lTm8gPT0gd2hlcmUubGluZSlcbiAgICAgICAgICAgIHBvcyA9IHdoZXJlLmNoIC0gKGRpciA8IDAgPyAxIDogMCk7XG4gICAgICAgIGZvciAoOyBwb3MgIT0gZW5kOyBwb3MgKz0gZGlyKSB7XG4gICAgICAgICAgICB2YXIgY2ggPSBsaW5lLmNoYXJBdChwb3MpO1xuICAgICAgICAgICAgaWYgKHJlLnRlc3QoY2gpIC8qJiYgKHN0eWxlID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGNtLmdldFRva2VuVHlwZUF0KG5ldyBQb3MobGluZU5vLCBwb3MgKyAxKSkgfHwgXCJcIikgPT0gKHN0eWxlIHx8IFwiXCIpKSovKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1hdGNoID0gbWF0Y2hpbmdbY2hdO1xuICAgICAgICAgICAgICAgIGlmIChtYXRjaCAmJiAobWF0Y2guY2hhckF0KDEpID09IFwiPlwiKSA9PSAoZGlyID4gMCkpXG4gICAgICAgICAgICAgICAgICAgIHN0YWNrLnB1c2goY2gpO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFzdGFjay5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHBvczogbmV3IFBvcyhsaW5lTm8sIHBvcyksIGNoOiBjaCB9O1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGxpbmVObyAtIGRpciA9PSAoZGlyID4gMCA/IGNtLmxhc3RMaW5lKCkgOiBjbS5maXJzdExpbmUoKSkgPyBmYWxzZSA6IG51bGw7XG59XG5mdW5jdGlvbiBmaW5kTWF0Y2hpbmdUYWcoY20sIHBvcykge1xuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gZmluZEVuY2xvc2luZ1RhZyhjbSwgcG9zKSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICB2YXIgc3RhdGUgPSBjbS5jbTYuc3RhdGU7XG4gICAgdmFyIG9mZnNldCA9IGNtLmluZGV4RnJvbVBvcyhwb3MpO1xuICAgIGlmIChvZmZzZXQgPCBzdGF0ZS5kb2MubGVuZ3RoKSB7XG4gICAgICAgIHZhciB0ZXh0ID0gc3RhdGUuc2xpY2VEb2Mob2Zmc2V0LCBvZmZzZXQgKyAxKTtcbiAgICAgICAgaWYgKHRleHQgPT0gXCI8XCIpXG4gICAgICAgICAgICBvZmZzZXQrKztcbiAgICB9XG4gICAgdmFyIHRyZWUgPSBlbnN1cmVTeW50YXhUcmVlKHN0YXRlLCBvZmZzZXQpO1xuICAgIHZhciBub2RlID0gKHRyZWUgPT09IG51bGwgfHwgdHJlZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogdHJlZS5yZXNvbHZlKG9mZnNldCkpIHx8IG51bGw7XG4gICAgd2hpbGUgKG5vZGUpIHtcbiAgICAgICAgaWYgKCgoX2EgPSBub2RlLmZpcnN0Q2hpbGQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS50eXBlLm5hbWUpID09ICdPcGVuVGFnJ1xuICAgICAgICAgICAgJiYgKChfYiA9IG5vZGUubGFzdENoaWxkKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IudHlwZS5uYW1lKSA9PSAnQ2xvc2VUYWcnKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIG9wZW46IGNvbnZlcnRSYW5nZShzdGF0ZS5kb2MsIG5vZGUuZmlyc3RDaGlsZCksXG4gICAgICAgICAgICAgICAgY2xvc2U6IGNvbnZlcnRSYW5nZShzdGF0ZS5kb2MsIG5vZGUubGFzdENoaWxkKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgbm9kZSA9IG5vZGUucGFyZW50O1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNvbnZlcnRSYW5nZShkb2MsIGNtNlJhbmdlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZnJvbTogcG9zRnJvbUluZGV4KGRvYywgY202UmFuZ2UuZnJvbSksXG4gICAgICAgIHRvOiBwb3NGcm9tSW5kZXgoZG9jLCBjbTZSYW5nZS50bylcbiAgICB9O1xufVxuY2xhc3MgTWFya2VyIHtcbiAgICBjb25zdHJ1Y3RvcihjbSwgb2Zmc2V0LCBhc3NvYykge1xuICAgICAgICB0aGlzLmNtID0gY207XG4gICAgICAgIHRoaXMuaWQgPSBjbS4kbWlkKys7XG4gICAgICAgIHRoaXMub2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgICB0aGlzLmFzc29jID0gYXNzb2M7XG4gICAgICAgIGNtLm1hcmtzW3RoaXMuaWRdID0gdGhpcztcbiAgICB9XG4gICAgO1xuICAgIGNsZWFyKCkgeyBkZWxldGUgdGhpcy5jbS5tYXJrc1t0aGlzLmlkXTsgfVxuICAgIDtcbiAgICBmaW5kKCkge1xuICAgICAgICBpZiAodGhpcy5vZmZzZXQgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICByZXR1cm4gdGhpcy5jbS5wb3NGcm9tSW5kZXgodGhpcy5vZmZzZXQpO1xuICAgIH1cbiAgICA7XG4gICAgdXBkYXRlKGNoYW5nZSkge1xuICAgICAgICBpZiAodGhpcy5vZmZzZXQgIT0gbnVsbClcbiAgICAgICAgICAgIHRoaXMub2Zmc2V0ID0gY2hhbmdlLm1hcFBvcyh0aGlzLm9mZnNldCwgdGhpcy5hc3NvYywgTWFwTW9kZS5UcmFja0RlbCk7XG4gICAgfVxufVxuZnVuY3Rpb24gaGFyZFdyYXAoY20sIG9wdGlvbnMpIHtcbiAgICB2YXIgX2E7XG4gICAgdmFyIG1heCA9IG9wdGlvbnMuY29sdW1uIHx8IGNtLmdldE9wdGlvbigndGV4dHdpZHRoJykgfHwgODA7XG4gICAgdmFyIGFsbG93TWVyZ2UgPSBvcHRpb25zLmFsbG93TWVyZ2UgIT0gZmFsc2U7XG4gICAgdmFyIHJvdyA9IE1hdGgubWluKG9wdGlvbnMuZnJvbSwgb3B0aW9ucy50byk7XG4gICAgdmFyIGVuZFJvdyA9IE1hdGgubWF4KG9wdGlvbnMuZnJvbSwgb3B0aW9ucy50byk7XG4gICAgd2hpbGUgKHJvdyA8PSBlbmRSb3cpIHtcbiAgICAgICAgdmFyIGxpbmUgPSBjbS5nZXRMaW5lKHJvdyk7XG4gICAgICAgIGlmIChsaW5lLmxlbmd0aCA+IG1heCkge1xuICAgICAgICAgICAgdmFyIHNwYWNlID0gZmluZFNwYWNlKGxpbmUsIG1heCwgNSk7XG4gICAgICAgICAgICBpZiAoc3BhY2UpIHtcbiAgICAgICAgICAgICAgICB2YXIgaW5kZW50YXRpb24gPSAoX2EgPSAvXlxccyovLmV4ZWMobGluZSkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYVswXTtcbiAgICAgICAgICAgICAgICBjbS5yZXBsYWNlUmFuZ2UoXCJcXG5cIiArIGluZGVudGF0aW9uLCBuZXcgUG9zKHJvdywgc3BhY2Uuc3RhcnQpLCBuZXcgUG9zKHJvdywgc3BhY2UuZW5kKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbmRSb3crKztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChhbGxvd01lcmdlICYmIC9cXFMvLnRlc3QobGluZSkgJiYgcm93ICE9IGVuZFJvdykge1xuICAgICAgICAgICAgdmFyIG5leHRMaW5lID0gY20uZ2V0TGluZShyb3cgKyAxKTtcbiAgICAgICAgICAgIGlmIChuZXh0TGluZSAmJiAvXFxTLy50ZXN0KG5leHRMaW5lKSkge1xuICAgICAgICAgICAgICAgIHZhciB0cmltbWVkTGluZSA9IGxpbmUucmVwbGFjZSgvXFxzKyQvLCBcIlwiKTtcbiAgICAgICAgICAgICAgICB2YXIgdHJpbW1lZE5leHRMaW5lID0gbmV4dExpbmUucmVwbGFjZSgvXlxccysvLCBcIlwiKTtcbiAgICAgICAgICAgICAgICB2YXIgbWVyZ2VkTGluZSA9IHRyaW1tZWRMaW5lICsgXCIgXCIgKyB0cmltbWVkTmV4dExpbmU7XG4gICAgICAgICAgICAgICAgdmFyIHNwYWNlID0gZmluZFNwYWNlKG1lcmdlZExpbmUsIG1heCwgNSk7XG4gICAgICAgICAgICAgICAgaWYgKHNwYWNlICYmIHNwYWNlLnN0YXJ0ID4gdHJpbW1lZExpbmUubGVuZ3RoIHx8IG1lcmdlZExpbmUubGVuZ3RoIDwgbWF4KSB7XG4gICAgICAgICAgICAgICAgICAgIGNtLnJlcGxhY2VSYW5nZShcIiBcIiwgbmV3IFBvcyhyb3csIHRyaW1tZWRMaW5lLmxlbmd0aCksIG5ldyBQb3Mocm93ICsgMSwgbmV4dExpbmUubGVuZ3RoIC0gdHJpbW1lZE5leHRMaW5lLmxlbmd0aCkpO1xuICAgICAgICAgICAgICAgICAgICByb3ctLTtcbiAgICAgICAgICAgICAgICAgICAgZW5kUm93LS07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRyaW1tZWRMaW5lLmxlbmd0aCA8IGxpbmUubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGNtLnJlcGxhY2VSYW5nZShcIlwiLCBuZXcgUG9zKHJvdywgdHJpbW1lZExpbmUubGVuZ3RoKSwgbmV3IFBvcyhyb3csIGxpbmUubGVuZ3RoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJvdysrO1xuICAgIH1cbiAgICByZXR1cm4gcm93O1xuICAgIGZ1bmN0aW9uIGZpbmRTcGFjZShsaW5lLCBtYXgsIG1pbikge1xuICAgICAgICBpZiAobGluZS5sZW5ndGggPCBtYXgpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHZhciBiZWZvcmUgPSBsaW5lLnNsaWNlKDAsIG1heCk7XG4gICAgICAgIHZhciBhZnRlciA9IGxpbmUuc2xpY2UobWF4KTtcbiAgICAgICAgdmFyIHNwYWNlQWZ0ZXIgPSAvXig/OihcXHMrKXwoXFxTKykoXFxzKykpLy5leGVjKGFmdGVyKTtcbiAgICAgICAgdmFyIHNwYWNlQmVmb3JlID0gLyg/OihcXHMrKXwoXFxzKykoXFxTKykpJC8uZXhlYyhiZWZvcmUpO1xuICAgICAgICB2YXIgc3RhcnQgPSAwO1xuICAgICAgICB2YXIgZW5kID0gMDtcbiAgICAgICAgaWYgKHNwYWNlQmVmb3JlICYmICFzcGFjZUJlZm9yZVsyXSkge1xuICAgICAgICAgICAgc3RhcnQgPSBtYXggLSBzcGFjZUJlZm9yZVsxXS5sZW5ndGg7XG4gICAgICAgICAgICBlbmQgPSBtYXg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNwYWNlQWZ0ZXIgJiYgIXNwYWNlQWZ0ZXJbMl0pIHtcbiAgICAgICAgICAgIGlmICghc3RhcnQpXG4gICAgICAgICAgICAgICAgc3RhcnQgPSBtYXg7XG4gICAgICAgICAgICBlbmQgPSBtYXggKyBzcGFjZUFmdGVyWzFdLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhcnQpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgICAgICAgICAgIGVuZDogZW5kXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChzcGFjZUJlZm9yZSAmJiBzcGFjZUJlZm9yZVsyXSAmJiBzcGFjZUJlZm9yZS5pbmRleCA+IG1pbikge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzdGFydDogc3BhY2VCZWZvcmUuaW5kZXgsXG4gICAgICAgICAgICAgICAgZW5kOiBzcGFjZUJlZm9yZS5pbmRleCArIHNwYWNlQmVmb3JlWzJdLmxlbmd0aFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3BhY2VBZnRlciAmJiBzcGFjZUFmdGVyWzJdKSB7XG4gICAgICAgICAgICBzdGFydCA9IG1heCArIHNwYWNlQWZ0ZXJbMl0ubGVuZ3RoO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzdGFydDogc3RhcnQsXG4gICAgICAgICAgICAgICAgZW5kOiBzdGFydCArIHNwYWNlQWZ0ZXJbM10ubGVuZ3RoXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vLyBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSBmb3Igb2xkIHZlcnNpb25zIG5vdCBzdXBwb3J0aW5nIGdldERyYXdTZWxlY3Rpb25Db25maWdcbmxldCBnZXREcmF3U2VsZWN0aW9uQ29uZmlnID0gVmlldy5nZXREcmF3U2VsZWN0aW9uQ29uZmlnIHx8IC8qQF9fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgbGV0IGRlZmF1bHRDb25maWcgPSB7IGN1cnNvckJsaW5rUmF0ZTogMTIwMCB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBkZWZhdWx0Q29uZmlnO1xuICAgIH07XG59KCk7XG5jbGFzcyBQaWVjZSB7XG4gICAgY29uc3RydWN0b3IobGVmdCwgdG9wLCBoZWlnaHQsIGZvbnRGYW1pbHksIGZvbnRTaXplLCBmb250V2VpZ2h0LCBjb2xvciwgY2xhc3NOYW1lLCBsZXR0ZXIsIHBhcnRpYWwpIHtcbiAgICAgICAgdGhpcy5sZWZ0ID0gbGVmdDtcbiAgICAgICAgdGhpcy50b3AgPSB0b3A7XG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICB0aGlzLmZvbnRGYW1pbHkgPSBmb250RmFtaWx5O1xuICAgICAgICB0aGlzLmZvbnRTaXplID0gZm9udFNpemU7XG4gICAgICAgIHRoaXMuZm9udFdlaWdodCA9IGZvbnRXZWlnaHQ7XG4gICAgICAgIHRoaXMuY29sb3IgPSBjb2xvcjtcbiAgICAgICAgdGhpcy5jbGFzc05hbWUgPSBjbGFzc05hbWU7XG4gICAgICAgIHRoaXMubGV0dGVyID0gbGV0dGVyO1xuICAgICAgICB0aGlzLnBhcnRpYWwgPSBwYXJ0aWFsO1xuICAgIH1cbiAgICBkcmF3KCkge1xuICAgICAgICBsZXQgZWx0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgZWx0LmNsYXNzTmFtZSA9IHRoaXMuY2xhc3NOYW1lO1xuICAgICAgICB0aGlzLmFkanVzdChlbHQpO1xuICAgICAgICByZXR1cm4gZWx0O1xuICAgIH1cbiAgICBhZGp1c3QoZWx0KSB7XG4gICAgICAgIGVsdC5zdHlsZS5sZWZ0ID0gdGhpcy5sZWZ0ICsgXCJweFwiO1xuICAgICAgICBlbHQuc3R5bGUudG9wID0gdGhpcy50b3AgKyBcInB4XCI7XG4gICAgICAgIGVsdC5zdHlsZS5oZWlnaHQgPSB0aGlzLmhlaWdodCArIFwicHhcIjtcbiAgICAgICAgZWx0LnN0eWxlLmxpbmVIZWlnaHQgPSB0aGlzLmhlaWdodCArIFwicHhcIjtcbiAgICAgICAgZWx0LnN0eWxlLmZvbnRGYW1pbHkgPSB0aGlzLmZvbnRGYW1pbHk7XG4gICAgICAgIGVsdC5zdHlsZS5mb250U2l6ZSA9IHRoaXMuZm9udFNpemU7XG4gICAgICAgIGVsdC5zdHlsZS5mb250V2VpZ2h0ID0gdGhpcy5mb250V2VpZ2h0O1xuICAgICAgICBlbHQuc3R5bGUuY29sb3IgPSB0aGlzLnBhcnRpYWwgPyBcInRyYW5zcGFyZW50XCIgOiB0aGlzLmNvbG9yO1xuICAgICAgICBlbHQuY2xhc3NOYW1lID0gdGhpcy5jbGFzc05hbWU7XG4gICAgICAgIGVsdC50ZXh0Q29udGVudCA9IHRoaXMubGV0dGVyO1xuICAgIH1cbiAgICBlcShwKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxlZnQgPT0gcC5sZWZ0ICYmIHRoaXMudG9wID09IHAudG9wICYmIHRoaXMuaGVpZ2h0ID09IHAuaGVpZ2h0ICYmXG4gICAgICAgICAgICB0aGlzLmZvbnRGYW1pbHkgPT0gcC5mb250RmFtaWx5ICYmIHRoaXMuZm9udFNpemUgPT0gcC5mb250U2l6ZSAmJlxuICAgICAgICAgICAgdGhpcy5mb250V2VpZ2h0ID09IHAuZm9udFdlaWdodCAmJiB0aGlzLmNvbG9yID09IHAuY29sb3IgJiZcbiAgICAgICAgICAgIHRoaXMuY2xhc3NOYW1lID09IHAuY2xhc3NOYW1lICYmXG4gICAgICAgICAgICB0aGlzLmxldHRlciA9PSBwLmxldHRlcjtcbiAgICB9XG59XG5jbGFzcyBCbG9ja0N1cnNvclBsdWdpbiB7XG4gICAgY29uc3RydWN0b3IodmlldywgY20pIHtcbiAgICAgICAgdGhpcy52aWV3ID0gdmlldztcbiAgICAgICAgdGhpcy5yYW5nZVBpZWNlcyA9IFtdO1xuICAgICAgICB0aGlzLmN1cnNvcnMgPSBbXTtcbiAgICAgICAgdGhpcy5jbSA9IGNtO1xuICAgICAgICB0aGlzLm1lYXN1cmVSZXEgPSB7IHJlYWQ6IHRoaXMucmVhZFBvcy5iaW5kKHRoaXMpLCB3cml0ZTogdGhpcy5kcmF3U2VsLmJpbmQodGhpcykgfTtcbiAgICAgICAgdGhpcy5jdXJzb3JMYXllciA9IHZpZXcuc2Nyb2xsRE9NLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIikpO1xuICAgICAgICB0aGlzLmN1cnNvckxheWVyLmNsYXNzTmFtZSA9IFwiY20tY3Vyc29yTGF5ZXIgY20tdmltQ3Vyc29yTGF5ZXJcIjtcbiAgICAgICAgdGhpcy5jdXJzb3JMYXllci5zZXRBdHRyaWJ1dGUoXCJhcmlhLWhpZGRlblwiLCBcInRydWVcIik7XG4gICAgICAgIHZpZXcucmVxdWVzdE1lYXN1cmUodGhpcy5tZWFzdXJlUmVxKTtcbiAgICAgICAgdGhpcy5zZXRCbGlua1JhdGUoKTtcbiAgICB9XG4gICAgc2V0QmxpbmtSYXRlKCkge1xuICAgICAgICBsZXQgY29uZmlnID0gZ2V0RHJhd1NlbGVjdGlvbkNvbmZpZyh0aGlzLmNtLmNtNi5zdGF0ZSk7XG4gICAgICAgIGxldCBibGlua1JhdGUgPSBjb25maWcuY3Vyc29yQmxpbmtSYXRlO1xuICAgICAgICB0aGlzLmN1cnNvckxheWVyLnN0eWxlLmFuaW1hdGlvbkR1cmF0aW9uID0gYmxpbmtSYXRlICsgXCJtc1wiO1xuICAgIH1cbiAgICB1cGRhdGUodXBkYXRlKSB7XG4gICAgICAgIGlmICh1cGRhdGUuc2VsZWN0aW9uU2V0IHx8IHVwZGF0ZS5nZW9tZXRyeUNoYW5nZWQgfHwgdXBkYXRlLnZpZXdwb3J0Q2hhbmdlZCkge1xuICAgICAgICAgICAgdGhpcy52aWV3LnJlcXVlc3RNZWFzdXJlKHRoaXMubWVhc3VyZVJlcSk7XG4gICAgICAgICAgICB0aGlzLmN1cnNvckxheWVyLnN0eWxlLmFuaW1hdGlvbk5hbWUgPSB0aGlzLmN1cnNvckxheWVyLnN0eWxlLmFuaW1hdGlvbk5hbWUgPT0gXCJjbS1ibGlua1wiID8gXCJjbS1ibGluazJcIiA6IFwiY20tYmxpbmtcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29uZmlnQ2hhbmdlZCh1cGRhdGUpKVxuICAgICAgICAgICAgdGhpcy5zZXRCbGlua1JhdGUoKTtcbiAgICB9XG4gICAgc2NoZWR1bGVSZWRyYXcoKSB7XG4gICAgICAgIHRoaXMudmlldy5yZXF1ZXN0TWVhc3VyZSh0aGlzLm1lYXN1cmVSZXEpO1xuICAgIH1cbiAgICByZWFkUG9zKCkge1xuICAgICAgICBsZXQgeyBzdGF0ZSB9ID0gdGhpcy52aWV3O1xuICAgICAgICBsZXQgY3Vyc29ycyA9IFtdO1xuICAgICAgICBmb3IgKGxldCByIG9mIHN0YXRlLnNlbGVjdGlvbi5yYW5nZXMpIHtcbiAgICAgICAgICAgIGxldCBwcmltID0gciA9PSBzdGF0ZS5zZWxlY3Rpb24ubWFpbjtcbiAgICAgICAgICAgIGxldCBwaWVjZSA9IG1lYXN1cmVDdXJzb3IodGhpcy5jbSwgdGhpcy52aWV3LCByLCBwcmltKTtcbiAgICAgICAgICAgIGlmIChwaWVjZSlcbiAgICAgICAgICAgICAgICBjdXJzb3JzLnB1c2gocGllY2UpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGN1cnNvcnMgfTtcbiAgICB9XG4gICAgZHJhd1NlbCh7IGN1cnNvcnMgfSkge1xuICAgICAgICBpZiAoY3Vyc29ycy5sZW5ndGggIT0gdGhpcy5jdXJzb3JzLmxlbmd0aCB8fCBjdXJzb3JzLnNvbWUoKGMsIGkpID0+ICFjLmVxKHRoaXMuY3Vyc29yc1tpXSkpKSB7XG4gICAgICAgICAgICBsZXQgb2xkQ3Vyc29ycyA9IHRoaXMuY3Vyc29yTGF5ZXIuY2hpbGRyZW47XG4gICAgICAgICAgICBpZiAob2xkQ3Vyc29ycy5sZW5ndGggIT09IGN1cnNvcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJzb3JMYXllci50ZXh0Q29udGVudCA9IFwiXCI7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBjIG9mIGN1cnNvcnMpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY3Vyc29yTGF5ZXIuYXBwZW5kQ2hpbGQoYy5kcmF3KCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY3Vyc29ycy5mb3JFYWNoKChjLCBpZHgpID0+IGMuYWRqdXN0KG9sZEN1cnNvcnNbaWR4XSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jdXJzb3JzID0gY3Vyc29ycztcbiAgICAgICAgfVxuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLmN1cnNvckxheWVyLnJlbW92ZSgpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNvbmZpZ0NoYW5nZWQodXBkYXRlKSB7XG4gICAgcmV0dXJuIGdldERyYXdTZWxlY3Rpb25Db25maWcodXBkYXRlLnN0YXJ0U3RhdGUpICE9IGdldERyYXdTZWxlY3Rpb25Db25maWcodXBkYXRlLnN0YXRlKTtcbn1cbmNvbnN0IHRoZW1lU3BlYyA9IHtcbiAgICBcIi5jbS12aW1Nb2RlIC5jbS1saW5lXCI6IHtcbiAgICAgICAgXCImIDo6c2VsZWN0aW9uXCI6IHsgYmFja2dyb3VuZENvbG9yOiBcInRyYW5zcGFyZW50ICFpbXBvcnRhbnRcIiB9LFxuICAgICAgICBcIiY6OnNlbGVjdGlvblwiOiB7IGJhY2tncm91bmRDb2xvcjogXCJ0cmFuc3BhcmVudCAhaW1wb3J0YW50XCIgfSxcbiAgICAgICAgY2FyZXRDb2xvcjogXCJ0cmFuc3BhcmVudCAhaW1wb3J0YW50XCIsXG4gICAgfSxcbiAgICBcIi5jbS1mYXQtY3Vyc29yXCI6IHtcbiAgICAgICAgcG9zaXRpb246IFwiYWJzb2x1dGVcIixcbiAgICAgICAgYmFja2dyb3VuZDogXCIjZmY5Njk2XCIsXG4gICAgICAgIGJvcmRlcjogXCJub25lXCIsXG4gICAgICAgIHdoaXRlU3BhY2U6IFwicHJlXCIsXG4gICAgfSxcbiAgICBcIiY6bm90KC5jbS1mb2N1c2VkKSAuY20tZmF0LWN1cnNvclwiOiB7XG4gICAgICAgIGJhY2tncm91bmQ6IFwibm9uZVwiLFxuICAgICAgICBvdXRsaW5lOiBcInNvbGlkIDFweCAjZmY5Njk2XCIsXG4gICAgICAgIGNvbG9yOiBcInRyYW5zcGFyZW50ICFpbXBvcnRhbnRcIixcbiAgICB9LFxufTtcbmNvbnN0IGhpZGVOYXRpdmVTZWxlY3Rpb24gPSAvKkBfX1BVUkVfXyovUHJlYy5oaWdoZXN0KC8qQF9fUFVSRV9fKi9FZGl0b3JWaWV3LnRoZW1lKHRoZW1lU3BlYykpO1xuZnVuY3Rpb24gZ2V0QmFzZSh2aWV3KSB7XG4gICAgbGV0IHJlY3QgPSB2aWV3LnNjcm9sbERPTS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBsZXQgbGVmdCA9IHZpZXcudGV4dERpcmVjdGlvbiA9PSBEaXJlY3Rpb24uTFRSID8gcmVjdC5sZWZ0IDogcmVjdC5yaWdodCAtIHZpZXcuc2Nyb2xsRE9NLmNsaWVudFdpZHRoO1xuICAgIHJldHVybiB7IGxlZnQ6IGxlZnQgLSB2aWV3LnNjcm9sbERPTS5zY3JvbGxMZWZ0ICogdmlldy5zY2FsZVgsIHRvcDogcmVjdC50b3AgLSB2aWV3LnNjcm9sbERPTS5zY3JvbGxUb3AgKiB2aWV3LnNjYWxlWSB9O1xufVxuZnVuY3Rpb24gbWVhc3VyZUN1cnNvcihjbSwgdmlldywgY3Vyc29yLCBwcmltYXJ5KSB7XG4gICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgIGxldCBoZWFkID0gY3Vyc29yLmhlYWQ7XG4gICAgbGV0IGZhdEN1cnNvciA9IGZhbHNlO1xuICAgIGxldCBoQ29lZmYgPSAxO1xuICAgIGxldCB2aW0gPSBjbS5zdGF0ZS52aW07XG4gICAgaWYgKHZpbSAmJiAoIXZpbS5pbnNlcnRNb2RlIHx8IGNtLnN0YXRlLm92ZXJ3cml0ZSkpIHtcbiAgICAgICAgZmF0Q3Vyc29yID0gdHJ1ZTtcbiAgICAgICAgaWYgKHZpbS52aXN1YWxCbG9jayAmJiAhcHJpbWFyeSlcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBpZiAoY3Vyc29yLmFuY2hvciA8IGN1cnNvci5oZWFkKSB7XG4gICAgICAgICAgICBsZXQgbGV0dGVyID0gaGVhZCA8IHZpZXcuc3RhdGUuZG9jLmxlbmd0aCAmJiB2aWV3LnN0YXRlLnNsaWNlRG9jKGhlYWQsIGhlYWQgKyAxKTtcbiAgICAgICAgICAgIGlmIChsZXR0ZXIgIT0gXCJcXG5cIilcbiAgICAgICAgICAgICAgICBoZWFkLS07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNtLnN0YXRlLm92ZXJ3cml0ZSlcbiAgICAgICAgICAgIGhDb2VmZiA9IDAuMjtcbiAgICAgICAgZWxzZSBpZiAodmltLnN0YXR1cylcbiAgICAgICAgICAgIGhDb2VmZiA9IDAuNTtcbiAgICB9XG4gICAgaWYgKGZhdEN1cnNvcikge1xuICAgICAgICBsZXQgbGV0dGVyID0gaGVhZCA8IHZpZXcuc3RhdGUuZG9jLmxlbmd0aCAmJiB2aWV3LnN0YXRlLnNsaWNlRG9jKGhlYWQsIGhlYWQgKyAxKTtcbiAgICAgICAgaWYgKGxldHRlciAmJiAoL1tcXHVEQzAwLVxcdURGRkZdLy50ZXN0KGxldHRlcikgJiYgaGVhZCA+IDEpKSB7XG4gICAgICAgICAgICAvLyBzdGVwIGJhY2sgaWYgY3Vyc29yIGlzIG9uIHRoZSBzZWNvbmQgaGFsZiBvZiBhIHN1cnJvZ2F0ZSBwYWlyXG4gICAgICAgICAgICBoZWFkLS07XG4gICAgICAgICAgICBsZXR0ZXIgPSB2aWV3LnN0YXRlLnNsaWNlRG9jKGhlYWQsIGhlYWQgKyAxKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcG9zID0gdmlldy5jb29yZHNBdFBvcyhoZWFkLCAxKTtcbiAgICAgICAgaWYgKCFwb3MpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgbGV0IGJhc2UgPSBnZXRCYXNlKHZpZXcpO1xuICAgICAgICBsZXQgZG9tQXRQb3MgPSB2aWV3LmRvbUF0UG9zKGhlYWQpO1xuICAgICAgICBsZXQgbm9kZSA9IGRvbUF0UG9zID8gZG9tQXRQb3Mubm9kZSA6IHZpZXcuY29udGVudERPTTtcbiAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBUZXh0ICYmIGRvbUF0UG9zLm9mZnNldCA+PSBub2RlLmRhdGEubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoKF9hID0gbm9kZS5wYXJlbnRFbGVtZW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubmV4dFNpYmxpbmcpIHtcbiAgICAgICAgICAgICAgICBub2RlID0gKF9iID0gbm9kZS5wYXJlbnRFbGVtZW50KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICAgICAgZG9tQXRQb3MgPSB7IG5vZGU6IG5vZGUsIG9mZnNldDogMCB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChkb21BdFBvcyAmJiBkb21BdFBvcy5ub2RlIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpIHtcbiAgICAgICAgICAgIG5vZGUgPSBkb21BdFBvcy5ub2RlO1xuICAgICAgICAgICAgZG9tQXRQb3MgPSB7IG5vZGU6IGRvbUF0UG9zLm5vZGUuY2hpbGROb2Rlc1tkb21BdFBvcy5vZmZzZXRdLCBvZmZzZXQ6IDAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIShub2RlIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpKSB7XG4gICAgICAgICAgICBpZiAoIW5vZGUucGFyZW50Tm9kZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShub2RlKTtcbiAgICAgICAgbGV0IGxlZnQgPSBwb3MubGVmdDtcbiAgICAgICAgLy8gVE9ETyByZW1vdmUgY29vcmRzQXRQb3Mgd2hlbiBhbGwgc3VwcG9ydGVkIHZlcnNpb25zIG9mIGNvZGVtaXJyb3IgaGF2ZSBjb29yZHNGb3JDaGFyIGFwaVxuICAgICAgICBsZXQgY2hhckNvb3JkcyA9IChfZCA9IChfYyA9IHZpZXcpLmNvb3Jkc0ZvckNoYXIpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5jYWxsKF9jLCBoZWFkKTtcbiAgICAgICAgaWYgKGNoYXJDb29yZHMpIHtcbiAgICAgICAgICAgIGxlZnQgPSBjaGFyQ29vcmRzLmxlZnQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFsZXR0ZXIgfHwgbGV0dGVyID09IFwiXFxuXCIgfHwgbGV0dGVyID09IFwiXFxyXCIpIHtcbiAgICAgICAgICAgIGxldHRlciA9IFwiXFx4YTBcIjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChsZXR0ZXIgPT0gXCJcXHRcIikge1xuICAgICAgICAgICAgbGV0dGVyID0gXCJcXHhhMFwiO1xuICAgICAgICAgICAgdmFyIG5leHRQb3MgPSB2aWV3LmNvb3Jkc0F0UG9zKGhlYWQgKyAxLCAtMSk7XG4gICAgICAgICAgICBpZiAobmV4dFBvcykge1xuICAgICAgICAgICAgICAgIGxlZnQgPSBuZXh0UG9zLmxlZnQgLSAobmV4dFBvcy5sZWZ0IC0gcG9zLmxlZnQpIC8gcGFyc2VJbnQoc3R5bGUudGFiU2l6ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKC9bXFx1RDgwMC1cXHVEQkZGXS8udGVzdChsZXR0ZXIpICYmIGhlYWQgPCB2aWV3LnN0YXRlLmRvYy5sZW5ndGggLSAxKSkge1xuICAgICAgICAgICAgLy8gaW5jbHVkZSB0aGUgc2Vjb25kIGhhbGYgb2YgYSBzdXJyb2dhdGUgcGFpciBpbiBjdXJzb3JcbiAgICAgICAgICAgIGxldHRlciArPSB2aWV3LnN0YXRlLnNsaWNlRG9jKGhlYWQgKyAxLCBoZWFkICsgMik7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGggPSAocG9zLmJvdHRvbSAtIHBvcy50b3ApO1xuICAgICAgICByZXR1cm4gbmV3IFBpZWNlKChsZWZ0IC0gYmFzZS5sZWZ0KSAvIHZpZXcuc2NhbGVYLCAocG9zLnRvcCAtIGJhc2UudG9wICsgaCAqICgxIC0gaENvZWZmKSkgLyB2aWV3LnNjYWxlWSwgaCAqIGhDb2VmZiAvIHZpZXcuc2NhbGVZLCBzdHlsZS5mb250RmFtaWx5LCBzdHlsZS5mb250U2l6ZSwgc3R5bGUuZm9udFdlaWdodCwgc3R5bGUuY29sb3IsIHByaW1hcnkgPyBcImNtLWZhdC1jdXJzb3IgY20tY3Vyc29yLXByaW1hcnlcIiA6IFwiY20tZmF0LWN1cnNvciBjbS1jdXJzb3Itc2Vjb25kYXJ5XCIsIGxldHRlciwgaENvZWZmICE9IDEpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufVxuXG52YXIgRklSRUZPWF9MSU5VWCA9IHR5cGVvZiBuYXZpZ2F0b3IgIT0gXCJ1bmRlZmluZWRcIlxuICAgICYmIC8qQF9fUFVSRV9fKi8vbGludXgvaS50ZXN0KG5hdmlnYXRvci5wbGF0Zm9ybSlcbiAgICAmJiAvKkBfX1BVUkVfXyovLyBHZWNrb1xcL1xcZCsvLmV4ZWMobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG5jb25zdCBWaW0gPSAvKkBfX1BVUkVfXyovaW5pdFZpbShDb2RlTWlycm9yKTtcbmNvbnN0IEhpZ2hsaWdodE1hcmdpbiA9IDI1MDtcbmNvbnN0IHZpbVN0eWxlID0gLypAX19QVVJFX18qL0VkaXRvclZpZXcuYmFzZVRoZW1lKHtcbiAgICBcIi5jbS12aW1Nb2RlIC5jbS1jdXJzb3JMYXllcjpub3QoLmNtLXZpbUN1cnNvckxheWVyKVwiOiB7XG4gICAgICAgIGRpc3BsYXk6IFwibm9uZVwiLFxuICAgIH0sXG4gICAgXCIuY20tdmltLXBhbmVsXCI6IHtcbiAgICAgICAgcGFkZGluZzogXCIwcHggMTBweFwiLFxuICAgICAgICBmb250RmFtaWx5OiBcIm1vbm9zcGFjZVwiLFxuICAgICAgICBtaW5IZWlnaHQ6IFwiMS4zZW1cIixcbiAgICAgICAgZGlzcGxheTogJ2ZsZXgnLFxuICAgIH0sXG4gICAgXCIuY20tdmltLXBhbmVsIGlucHV0XCI6IHtcbiAgICAgICAgYm9yZGVyOiBcIm5vbmVcIixcbiAgICAgICAgb3V0bGluZTogXCJub25lXCIsXG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogXCJpbmhlcml0XCIsXG4gICAgfSxcbiAgICBcIiZsaWdodCAuY20tc2VhcmNoTWF0Y2hcIjogeyBiYWNrZ3JvdW5kQ29sb3I6IFwiI2ZmZmYwMDU0XCIgfSxcbiAgICBcIiZkYXJrIC5jbS1zZWFyY2hNYXRjaFwiOiB7IGJhY2tncm91bmRDb2xvcjogXCIjMDBmZmZmOGFcIiB9LFxufSk7XG5jb25zdCB2aW1QbHVnaW4gPSAvKkBfX1BVUkVfXyovVmlld1BsdWdpbi5mcm9tQ2xhc3MoY2xhc3Mge1xuICAgIGNvbnN0cnVjdG9yKHZpZXcpIHtcbiAgICAgICAgdGhpcy5zdGF0dXMgPSBcIlwiO1xuICAgICAgICB0aGlzLnF1ZXJ5ID0gbnVsbDtcbiAgICAgICAgdGhpcy5kZWNvcmF0aW9ucyA9IERlY29yYXRpb24ubm9uZTtcbiAgICAgICAgdGhpcy53YWl0Rm9yQ29weSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmxhc3RLZXlkb3duID0gJyc7XG4gICAgICAgIHRoaXMudXNlTmV4dFRleHRJbnB1dCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmNvbXBvc2l0aW9uVGV4dCA9ICcnO1xuICAgICAgICB0aGlzLnZpZXcgPSB2aWV3O1xuICAgICAgICBjb25zdCBjbSA9ICh0aGlzLmNtID0gbmV3IENvZGVNaXJyb3IodmlldykpO1xuICAgICAgICBWaW0uZW50ZXJWaW1Nb2RlKHRoaXMuY20pO1xuICAgICAgICB0aGlzLnZpZXcuY20gPSB0aGlzLmNtO1xuICAgICAgICB0aGlzLmNtLnN0YXRlLnZpbVBsdWdpbiA9IHRoaXM7XG4gICAgICAgIHRoaXMuYmxvY2tDdXJzb3IgPSBuZXcgQmxvY2tDdXJzb3JQbHVnaW4odmlldywgY20pO1xuICAgICAgICB0aGlzLnVwZGF0ZUNsYXNzKCk7XG4gICAgICAgIHRoaXMuY20ub24oXCJ2aW0tY29tbWFuZC1kb25lXCIsICgpID0+IHtcbiAgICAgICAgICAgIGlmIChjbS5zdGF0ZS52aW0pXG4gICAgICAgICAgICAgICAgY20uc3RhdGUudmltLnN0YXR1cyA9IFwiXCI7XG4gICAgICAgICAgICB0aGlzLmJsb2NrQ3Vyc29yLnNjaGVkdWxlUmVkcmF3KCk7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVN0YXR1cygpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jbS5vbihcInZpbS1tb2RlLWNoYW5nZVwiLCAoZSkgPT4ge1xuICAgICAgICAgICAgaWYgKCFjbS5zdGF0ZS52aW0pXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY20uc3RhdGUudmltLm1vZGUgPSBlLm1vZGU7XG4gICAgICAgICAgICBpZiAoZS5zdWJNb2RlKSB7XG4gICAgICAgICAgICAgICAgY20uc3RhdGUudmltLm1vZGUgKz0gXCIgYmxvY2tcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNtLnN0YXRlLnZpbS5zdGF0dXMgPSBcIlwiO1xuICAgICAgICAgICAgdGhpcy5ibG9ja0N1cnNvci5zY2hlZHVsZVJlZHJhdygpO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVDbGFzcygpO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVTdGF0dXMoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY20ub24oXCJkaWFsb2dcIiwgKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuY20uc3RhdGUuc3RhdHVzYmFyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVTdGF0dXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZpZXcuZGlzcGF0Y2goe1xuICAgICAgICAgICAgICAgICAgICBlZmZlY3RzOiBzaG93VmltUGFuZWwub2YoISF0aGlzLmNtLnN0YXRlLmRpYWxvZyksXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmRvbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgICAgICB0aGlzLnNwYWNlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgICAgICB0aGlzLnNwYWNlci5zdHlsZS5mbGV4ID0gXCIxXCI7XG4gICAgICAgIHRoaXMuc3RhdHVzQnV0dG9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgICAgIHRoaXMuc3RhdHVzQnV0dG9uLm9uY2xpY2sgPSAoZSkgPT4ge1xuICAgICAgICAgICAgVmltLmhhbmRsZUtleSh0aGlzLmNtLCBcIjxFc2M+XCIsIFwidXNlclwiKTtcbiAgICAgICAgICAgIHRoaXMuY20uZm9jdXMoKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5zdGF0dXNCdXR0b24uc3R5bGUuY3NzVGV4dCA9IFwiY3Vyc29yOiBwb2ludGVyXCI7XG4gICAgfVxuICAgIHVwZGF0ZSh1cGRhdGUpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAoKHVwZGF0ZS52aWV3cG9ydENoYW5nZWQgfHwgdXBkYXRlLmRvY0NoYW5nZWQpICYmIHRoaXMucXVlcnkpIHtcbiAgICAgICAgICAgIHRoaXMuaGlnaGxpZ2h0KHRoaXMucXVlcnkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1cGRhdGUuZG9jQ2hhbmdlZCkge1xuICAgICAgICAgICAgdGhpcy5jbS5vbkNoYW5nZSh1cGRhdGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1cGRhdGUuc2VsZWN0aW9uU2V0KSB7XG4gICAgICAgICAgICB0aGlzLmNtLm9uU2VsZWN0aW9uQ2hhbmdlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVwZGF0ZS52aWV3cG9ydENoYW5nZWQpIDtcbiAgICAgICAgaWYgKHRoaXMuY20uY3VyT3AgJiYgIXRoaXMuY20uY3VyT3AuaXNWaW1PcCkge1xuICAgICAgICAgICAgdGhpcy5jbS5vbkJlZm9yZUVuZE9wZXJhdGlvbigpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1cGRhdGUudHJhbnNhY3Rpb25zKSB7XG4gICAgICAgICAgICBmb3IgKGxldCB0ciBvZiB1cGRhdGUudHJhbnNhY3Rpb25zKVxuICAgICAgICAgICAgICAgIGZvciAobGV0IGVmZmVjdCBvZiB0ci5lZmZlY3RzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlZmZlY3QuaXMoc2V0U2VhcmNoUXVlcnkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgZm9yVmltID0gKF9hID0gZWZmZWN0LnZhbHVlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZm9yVmltO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFmb3JWaW0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmhpZ2hsaWdodChudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBxdWVyeSA9IGVmZmVjdC52YWx1ZS5jcmVhdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmhpZ2hsaWdodChxdWVyeSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ibG9ja0N1cnNvci51cGRhdGUodXBkYXRlKTtcbiAgICB9XG4gICAgdXBkYXRlQ2xhc3MoKSB7XG4gICAgICAgIGNvbnN0IHN0YXRlID0gdGhpcy5jbS5zdGF0ZTtcbiAgICAgICAgaWYgKCFzdGF0ZS52aW0gfHwgKHN0YXRlLnZpbS5pbnNlcnRNb2RlICYmICFzdGF0ZS5vdmVyd3JpdGUpKVxuICAgICAgICAgICAgdGhpcy52aWV3LnNjcm9sbERPTS5jbGFzc0xpc3QucmVtb3ZlKFwiY20tdmltTW9kZVwiKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhpcy52aWV3LnNjcm9sbERPTS5jbGFzc0xpc3QuYWRkKFwiY20tdmltTW9kZVwiKTtcbiAgICB9XG4gICAgdXBkYXRlU3RhdHVzKCkge1xuICAgICAgICBsZXQgZG9tID0gdGhpcy5jbS5zdGF0ZS5zdGF0dXNiYXI7XG4gICAgICAgIGxldCB2aW0gPSB0aGlzLmNtLnN0YXRlLnZpbTtcbiAgICAgICAgaWYgKCFkb20gfHwgIXZpbSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgbGV0IGRpYWxvZyA9IHRoaXMuY20uc3RhdGUuZGlhbG9nO1xuICAgICAgICBpZiAoZGlhbG9nKSB7XG4gICAgICAgICAgICBpZiAoZGlhbG9nLnBhcmVudEVsZW1lbnQgIT0gZG9tKSB7XG4gICAgICAgICAgICAgICAgZG9tLnRleHRDb250ZW50ID0gXCJcIjtcbiAgICAgICAgICAgICAgICBkb20uYXBwZW5kQ2hpbGQoZGlhbG9nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRvbS50ZXh0Q29udGVudCA9IFwiXCI7XG4gICAgICAgICAgICB2YXIgc3RhdHVzID0gKHZpbS5tb2RlIHx8IFwibm9ybWFsXCIpLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgICAgICBpZiAodmltLmluc2VydE1vZGVSZXR1cm4pXG4gICAgICAgICAgICAgICAgc3RhdHVzICs9IFwiKEMtTylcIjtcbiAgICAgICAgICAgIHRoaXMuc3RhdHVzQnV0dG9uLnRleHRDb250ZW50ID0gYC0tJHtzdGF0dXN9LS1gO1xuICAgICAgICAgICAgZG9tLmFwcGVuZENoaWxkKHRoaXMuc3RhdHVzQnV0dG9uKTtcbiAgICAgICAgICAgIGRvbS5hcHBlbmRDaGlsZCh0aGlzLnNwYWNlcik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kb20udGV4dENvbnRlbnQgPSB2aW0uc3RhdHVzO1xuICAgICAgICBkb20uYXBwZW5kQ2hpbGQodGhpcy5kb20pO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICBWaW0ubGVhdmVWaW1Nb2RlKHRoaXMuY20pO1xuICAgICAgICB0aGlzLnVwZGF0ZUNsYXNzKCk7XG4gICAgICAgIHRoaXMuYmxvY2tDdXJzb3IuZGVzdHJveSgpO1xuICAgICAgICBkZWxldGUgdGhpcy52aWV3LmNtO1xuICAgIH1cbiAgICBoaWdobGlnaHQocXVlcnkpIHtcbiAgICAgICAgdGhpcy5xdWVyeSA9IHF1ZXJ5O1xuICAgICAgICBpZiAoIXF1ZXJ5KVxuICAgICAgICAgICAgcmV0dXJuICh0aGlzLmRlY29yYXRpb25zID0gRGVjb3JhdGlvbi5ub25lKTtcbiAgICAgICAgbGV0IHsgdmlldyB9ID0gdGhpcztcbiAgICAgICAgbGV0IGJ1aWxkZXIgPSBuZXcgUmFuZ2VTZXRCdWlsZGVyKCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCByYW5nZXMgPSB2aWV3LnZpc2libGVSYW5nZXMsIGwgPSByYW5nZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgeyBmcm9tLCB0byB9ID0gcmFuZ2VzW2ldO1xuICAgICAgICAgICAgd2hpbGUgKGkgPCBsIC0gMSAmJiB0byA+IHJhbmdlc1tpICsgMV0uZnJvbSAtIDIgKiBIaWdobGlnaHRNYXJnaW4pXG4gICAgICAgICAgICAgICAgdG8gPSByYW5nZXNbKytpXS50bztcbiAgICAgICAgICAgIHF1ZXJ5LmhpZ2hsaWdodCh2aWV3LnN0YXRlLCBmcm9tLCB0bywgKGZyb20sIHRvKSA9PiB7XG4gICAgICAgICAgICAgICAgYnVpbGRlci5hZGQoZnJvbSwgdG8sIG1hdGNoTWFyayk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKHRoaXMuZGVjb3JhdGlvbnMgPSBidWlsZGVyLmZpbmlzaCgpKTtcbiAgICB9XG4gICAgaGFuZGxlS2V5KGUsIHZpZXcpIHtcbiAgICAgICAgY29uc3QgY20gPSB0aGlzLmNtO1xuICAgICAgICBsZXQgdmltID0gY20uc3RhdGUudmltO1xuICAgICAgICBpZiAoIXZpbSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3Qga2V5ID0gVmltLnZpbUtleUZyb21FdmVudChlLCB2aW0pO1xuICAgICAgICBDb2RlTWlycm9yLnNpZ25hbCh0aGlzLmNtLCAnaW5wdXRFdmVudCcsIHsgdHlwZTogXCJoYW5kbGVLZXlcIiwga2V5IH0pO1xuICAgICAgICBpZiAoIWtleSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgLy8gY2xlYXIgc2VhcmNoIGhpZ2hsaWdodFxuICAgICAgICBpZiAoa2V5ID09IFwiPEVzYz5cIiAmJlxuICAgICAgICAgICAgIXZpbS5pbnNlcnRNb2RlICYmXG4gICAgICAgICAgICAhdmltLnZpc3VhbE1vZGUgJiZcbiAgICAgICAgICAgIHRoaXMucXVlcnkgLyogJiYgIWNtLmluTXVsdGlTZWxlY3RNb2RlKi8pIHtcbiAgICAgICAgICAgIGNvbnN0IHNlYXJjaFN0YXRlID0gdmltLnNlYXJjaFN0YXRlXztcbiAgICAgICAgICAgIGlmIChzZWFyY2hTdGF0ZSkge1xuICAgICAgICAgICAgICAgIGNtLnJlbW92ZU92ZXJsYXkoc2VhcmNoU3RhdGUuZ2V0T3ZlcmxheSgpKTtcbiAgICAgICAgICAgICAgICBzZWFyY2hTdGF0ZS5zZXRPdmVybGF5KG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBpc0NvcHkgPSBrZXkgPT09IFwiPEMtYz5cIiAmJiAhQ29kZU1pcnJvci5pc01hYztcbiAgICAgICAgaWYgKGlzQ29weSAmJiBjbS5zb21ldGhpbmdTZWxlY3RlZCgpKSB7XG4gICAgICAgICAgICB0aGlzLndhaXRGb3JDb3B5ID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHZpbS5zdGF0dXMgPSAodmltLnN0YXR1cyB8fCBcIlwiKSArIGtleTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFZpbS5tdWx0aVNlbGVjdEhhbmRsZUtleShjbSwga2V5LCBcInVzZXJcIik7XG4gICAgICAgIHZpbSA9IFZpbS5tYXliZUluaXRWaW1TdGF0ZV8oY20pOyAvLyB0aGUgb2JqZWN0IGNhbiBjaGFuZ2UgaWYgdGhlcmUgaXMgYW4gZXhjZXB0aW9uIGluIGhhbmRsZUtleVxuICAgICAgICAvLyBpbnNlcnQgbW9kZVxuICAgICAgICBpZiAoIXJlc3VsdCAmJiB2aW0uaW5zZXJ0TW9kZSAmJiBjbS5zdGF0ZS5vdmVyd3JpdGUpIHtcbiAgICAgICAgICAgIGlmIChlLmtleSAmJiBlLmtleS5sZW5ndGggPT0gMSAmJiAhL1xcbi8udGVzdChlLmtleSkpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGNtLm92ZXJXcml0ZVNlbGVjdGlvbihlLmtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChlLmtleSA9PSBcIkJhY2tzcGFjZVwiKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBDb2RlTWlycm9yLmNvbW1hbmRzLmN1cnNvckNoYXJMZWZ0KGNtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICBDb2RlTWlycm9yLnNpZ25hbCh0aGlzLmNtLCAndmltLWtleXByZXNzJywga2V5KTtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICB0aGlzLmJsb2NrQ3Vyc29yLnNjaGVkdWxlUmVkcmF3KCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy51cGRhdGVTdGF0dXMoKTtcbiAgICAgICAgcmV0dXJuICEhcmVzdWx0O1xuICAgIH1cbn0sIHtcbiAgICBldmVudEhhbmRsZXJzOiB7XG4gICAgICAgIGNvcHk6IGZ1bmN0aW9uIChlLCB2aWV3KSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMud2FpdEZvckNvcHkpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgdGhpcy53YWl0Rm9yQ29weSA9IGZhbHNlO1xuICAgICAgICAgICAgUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIGNtID0gdGhpcy5jbTtcbiAgICAgICAgICAgICAgICB2YXIgdmltID0gY20uc3RhdGUudmltO1xuICAgICAgICAgICAgICAgIGlmICghdmltKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgaWYgKHZpbS5pbnNlcnRNb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNtLnNldFNlbGVjdGlvbihjbS5nZXRDdXJzb3IoKSwgY20uZ2V0Q3Vyc29yKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY20ub3BlcmF0aW9uKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjbS5jdXJPcClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbS5jdXJPcC5pc1ZpbU9wID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIFZpbS5oYW5kbGVLZXkoY20sICc8RXNjPicsICd1c2VyJyk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBjb21wb3NpdGlvbnN0YXJ0OiBmdW5jdGlvbiAoZSwgdmlldykge1xuICAgICAgICAgICAgdGhpcy51c2VOZXh0VGV4dElucHV0ID0gdHJ1ZTtcbiAgICAgICAgICAgIENvZGVNaXJyb3Iuc2lnbmFsKHRoaXMuY20sICdpbnB1dEV2ZW50JywgZSk7XG4gICAgICAgIH0sXG4gICAgICAgIGNvbXBvc2l0aW9udXBkYXRlOiBmdW5jdGlvbiAoZSwgdmlldykge1xuICAgICAgICAgICAgQ29kZU1pcnJvci5zaWduYWwodGhpcy5jbSwgJ2lucHV0RXZlbnQnLCBlKTtcbiAgICAgICAgfSxcbiAgICAgICAgY29tcG9zaXRpb25lbmQ6IGZ1bmN0aW9uIChlLCB2aWV3KSB7XG4gICAgICAgICAgICBDb2RlTWlycm9yLnNpZ25hbCh0aGlzLmNtLCAnaW5wdXRFdmVudCcsIGUpO1xuICAgICAgICB9LFxuICAgICAgICBrZXlwcmVzczogZnVuY3Rpb24gKGUsIHZpZXcpIHtcbiAgICAgICAgICAgIENvZGVNaXJyb3Iuc2lnbmFsKHRoaXMuY20sICdpbnB1dEV2ZW50JywgZSk7XG4gICAgICAgICAgICBpZiAodGhpcy5sYXN0S2V5ZG93biA9PSBcIkRlYWRcIilcbiAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZUtleShlLCB2aWV3KTtcbiAgICAgICAgfSxcbiAgICAgICAga2V5ZG93bjogZnVuY3Rpb24gKGUsIHZpZXcpIHtcbiAgICAgICAgICAgIENvZGVNaXJyb3Iuc2lnbmFsKHRoaXMuY20sICdpbnB1dEV2ZW50JywgZSk7XG4gICAgICAgICAgICB0aGlzLmxhc3RLZXlkb3duID0gZS5rZXk7XG4gICAgICAgICAgICBpZiAodGhpcy5sYXN0S2V5ZG93biA9PSBcIlVuaWRlbnRpZmllZFwiXG4gICAgICAgICAgICAgICAgfHwgdGhpcy5sYXN0S2V5ZG93biA9PSBcIlByb2Nlc3NcIlxuICAgICAgICAgICAgICAgIHx8IHRoaXMubGFzdEtleWRvd24gPT0gXCJEZWFkXCIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnVzZU5leHRUZXh0SW5wdXQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy51c2VOZXh0VGV4dElucHV0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVLZXkoZSwgdmlldyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgfSxcbiAgICBwcm92aWRlOiAoKSA9PiB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBFZGl0b3JWaWV3LmlucHV0SGFuZGxlci5vZigodmlldywgZnJvbSwgdG8sIHRleHQpID0+IHtcbiAgICAgICAgICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAgICAgICAgIHZhciBjbSA9IGdldENNKHZpZXcpO1xuICAgICAgICAgICAgICAgIGlmICghY20pXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB2YXIgdmltID0gKF9hID0gY20uc3RhdGUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS52aW07XG4gICAgICAgICAgICAgICAgdmFyIHZpbVBsdWdpbiA9IGNtLnN0YXRlLnZpbVBsdWdpbjtcbiAgICAgICAgICAgICAgICBpZiAodmltICYmICF2aW0uaW5zZXJ0TW9kZSAmJiAhKChfYiA9IGNtLmN1ck9wKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuaXNWaW1PcCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRleHQgPT09IFwiXFwwXFwwXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIENvZGVNaXJyb3Iuc2lnbmFsKGNtLCAnaW5wdXRFdmVudCcsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwidGV4dFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZyb20sXG4gICAgICAgICAgICAgICAgICAgICAgICB0byxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0ZXh0Lmxlbmd0aCA9PSAxICYmIHZpbVBsdWdpbi51c2VOZXh0VGV4dElucHV0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodmltLmV4cGVjdExpdGVyYWxOZXh0ICYmIHZpZXcuY29tcG9zaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmltUGx1Z2luLmNvbXBvc2l0aW9uVGV4dCA9IHRleHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZpbVBsdWdpbi5jb21wb3NpdGlvblRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdG9SZW1vdmUgPSB2aW1QbHVnaW4uY29tcG9zaXRpb25UZXh0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZpbVBsdWdpbi5jb21wb3NpdGlvblRleHQgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaGVhZCA9IHZpZXcuc3RhdGUuc2VsZWN0aW9uLm1haW4uaGVhZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGV4dEluRG9jID0gdmlldy5zdGF0ZS5zbGljZURvYyhoZWFkIC0gdG9SZW1vdmUubGVuZ3RoLCBoZWFkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodG9SZW1vdmUgPT09IHRleHRJbkRvYykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcG9zID0gY20uZ2V0Q3Vyc29yKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNtLnJlcGxhY2VSYW5nZSgnJywgY20ucG9zRnJvbUluZGV4KGhlYWQgLSB0b1JlbW92ZS5sZW5ndGgpLCBwb3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHZpbVBsdWdpbi5oYW5kbGVLZXkoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleTogdGV4dCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmV2ZW50RGVmYXVsdDogKCkgPT4geyB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0b3BQcm9wYWdhdGlvbjogKCkgPT4geyB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvcmNlRW5kQ29tcG9zaXRpb24odmlldyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9KVxuICAgICAgICBdO1xuICAgIH0sXG4gICAgZGVjb3JhdGlvbnM6ICh2KSA9PiB2LmRlY29yYXRpb25zLFxufSk7XG4vKipcbiAqIHJlbW92ZXMgY29udGVudGVkaXRhYmxlIGVsZW1lbnQgYW5kIGFkZHMgaXQgYmFjayB0byBlbmRcbiAqIElNRSBjb21wb3NpdGlvbiBpbiBub3JtYWwgbW9kZVxuICogdGhpcyBtZXRob2Qgd29ya3Mgb24gYWxsIGJyb3dzZXJzIGV4Y2VwdCBmb3IgRmlyZWZveCBvbiBMaW51eFxuICogd2hlcmUgd2UgbmVlZCB0byByZXNldCB0ZXh0Q29udGVudCBvZiBlZGl0b3JcbiAqICh3aGljaCBkb2Vzbid0IHdvcmsgb24gb3RoZXIgYnJvd3NlcnMpXG4gKi9cbmZ1bmN0aW9uIGZvcmNlRW5kQ29tcG9zaXRpb24odmlldykge1xuICAgIHZhciBwYXJlbnQgPSB2aWV3LnNjcm9sbERPTS5wYXJlbnRFbGVtZW50O1xuICAgIGlmICghcGFyZW50KVxuICAgICAgICByZXR1cm47XG4gICAgaWYgKEZJUkVGT1hfTElOVVgpIHtcbiAgICAgICAgdmlldy5jb250ZW50RE9NLnRleHRDb250ZW50ID0gXCJcXDBcXDBcIjtcbiAgICAgICAgdmlldy5jb250ZW50RE9NLmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KFwiY29tcG9zaXRpb25lbmRcIikpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBzaWJsaW5nID0gdmlldy5zY3JvbGxET00ubmV4dFNpYmxpbmc7XG4gICAgdmFyIHNlbGVjdGlvbiA9IHdpbmRvdy5nZXRTZWxlY3Rpb24oKTtcbiAgICB2YXIgc2F2ZWRTZWxlY3Rpb24gPSBzZWxlY3Rpb24gJiYge1xuICAgICAgICBhbmNob3JOb2RlOiBzZWxlY3Rpb24uYW5jaG9yTm9kZSxcbiAgICAgICAgYW5jaG9yT2Zmc2V0OiBzZWxlY3Rpb24uYW5jaG9yT2Zmc2V0LFxuICAgICAgICBmb2N1c05vZGU6IHNlbGVjdGlvbi5mb2N1c05vZGUsXG4gICAgICAgIGZvY3VzT2Zmc2V0OiBzZWxlY3Rpb24uZm9jdXNPZmZzZXRcbiAgICB9O1xuICAgIHZpZXcuc2Nyb2xsRE9NLnJlbW92ZSgpO1xuICAgIHBhcmVudC5pbnNlcnRCZWZvcmUodmlldy5zY3JvbGxET00sIHNpYmxpbmcpO1xuICAgIHRyeSB7XG4gICAgICAgIGlmIChzYXZlZFNlbGVjdGlvbiAmJiBzZWxlY3Rpb24pIHtcbiAgICAgICAgICAgIHNlbGVjdGlvbi5zZXRQb3NpdGlvbihzYXZlZFNlbGVjdGlvbi5hbmNob3JOb2RlLCBzYXZlZFNlbGVjdGlvbi5hbmNob3JPZmZzZXQpO1xuICAgICAgICAgICAgaWYgKHNhdmVkU2VsZWN0aW9uLmZvY3VzTm9kZSkge1xuICAgICAgICAgICAgICAgIHNlbGVjdGlvbi5leHRlbmQoc2F2ZWRTZWxlY3Rpb24uZm9jdXNOb2RlLCBzYXZlZFNlbGVjdGlvbi5mb2N1c09mZnNldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihlKTtcbiAgICB9XG4gICAgdmlldy5mb2N1cygpO1xuICAgIHZpZXcuY29udGVudERPTS5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudChcImNvbXBvc2l0aW9uZW5kXCIpKTtcbn1cbmNvbnN0IG1hdGNoTWFyayA9IC8qQF9fUFVSRV9fKi9EZWNvcmF0aW9uLm1hcmsoeyBjbGFzczogXCJjbS1zZWFyY2hNYXRjaFwiIH0pO1xuY29uc3Qgc2hvd1ZpbVBhbmVsID0gLypAX19QVVJFX18qL1N0YXRlRWZmZWN0LmRlZmluZSgpO1xuY29uc3QgdmltUGFuZWxTdGF0ZSA9IC8qQF9fUFVSRV9fKi9TdGF0ZUZpZWxkLmRlZmluZSh7XG4gICAgY3JlYXRlOiAoKSA9PiBmYWxzZSxcbiAgICB1cGRhdGUodmFsdWUsIHRyKSB7XG4gICAgICAgIGZvciAobGV0IGUgb2YgdHIuZWZmZWN0cylcbiAgICAgICAgICAgIGlmIChlLmlzKHNob3dWaW1QYW5lbCkpXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBlLnZhbHVlO1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSxcbiAgICBwcm92aWRlOiAoZikgPT4ge1xuICAgICAgICByZXR1cm4gc2hvd1BhbmVsLmZyb20oZiwgKG9uKSA9PiAob24gPyBjcmVhdGVWaW1QYW5lbCA6IG51bGwpKTtcbiAgICB9LFxufSk7XG5mdW5jdGlvbiBjcmVhdGVWaW1QYW5lbCh2aWV3KSB7XG4gICAgbGV0IGRvbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgZG9tLmNsYXNzTmFtZSA9IFwiY20tdmltLXBhbmVsXCI7XG4gICAgbGV0IGNtID0gdmlldy5jbTtcbiAgICBpZiAoY20uc3RhdGUuZGlhbG9nKSB7XG4gICAgICAgIGRvbS5hcHBlbmRDaGlsZChjbS5zdGF0ZS5kaWFsb2cpO1xuICAgIH1cbiAgICByZXR1cm4geyB0b3A6IGZhbHNlLCBkb20gfTtcbn1cbmZ1bmN0aW9uIHN0YXR1c1BhbmVsKHZpZXcpIHtcbiAgICBsZXQgZG9tID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICBkb20uY2xhc3NOYW1lID0gXCJjbS12aW0tcGFuZWxcIjtcbiAgICBsZXQgY20gPSB2aWV3LmNtO1xuICAgIGNtLnN0YXRlLnN0YXR1c2JhciA9IGRvbTtcbiAgICBjbS5zdGF0ZS52aW1QbHVnaW4udXBkYXRlU3RhdHVzKCk7XG4gICAgcmV0dXJuIHsgZG9tIH07XG59XG5mdW5jdGlvbiB2aW0ob3B0aW9ucyA9IHt9KSB7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgdmltU3R5bGUsXG4gICAgICAgIHZpbVBsdWdpbixcbiAgICAgICAgaGlkZU5hdGl2ZVNlbGVjdGlvbixcbiAgICAgICAgb3B0aW9ucy5zdGF0dXMgPyBzaG93UGFuZWwub2Yoc3RhdHVzUGFuZWwpIDogdmltUGFuZWxTdGF0ZSxcbiAgICBdO1xufVxuZnVuY3Rpb24gZ2V0Q00odmlldykge1xuICAgIHJldHVybiB2aWV3LmNtIHx8IG51bGw7XG59XG5cbmV4cG9ydCB7IENvZGVNaXJyb3IsIFZpbSwgZ2V0Q00sIHZpbSB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@replit/codemirror-vim/dist/index.js\n"));

/***/ })

});